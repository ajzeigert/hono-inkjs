{"version":3,"file":"ink-full-es2015.js","sources":["../src/compiler/CompilerOptions.ts","../src/compiler/DebugSourceRange.ts","../src/compiler/Parser/ErrorType.ts","../src/engine/Debug.ts","../src/engine/Value.ts","../src/engine/PushPop.ts","../src/compiler/Parser/ParsedHierarchy/SymbolType.ts","../src/compiler/Parser/ParsedHierarchy/Argument.ts","../src/engine/TypeAssertion.ts","../src/compiler/Parser/ParsedHierarchy/Object.ts","../src/compiler/Parser/ParsedHierarchy/AuthorWarning.ts","../src/engine/Path.ts","../src/engine/NullException.ts","../src/engine/Object.ts","../src/engine/StringBuilder.ts","../src/engine/InkList.ts","../src/engine/StoryException.ts","../src/engine/TryGetResult.ts","../src/engine/SearchResult.ts","../src/engine/Container.ts","../src/engine/ControlCommand.ts","../src/compiler/Parser/ParsedHierarchy/Expression/Expression.ts","../src/engine/Void.ts","../src/engine/NativeFunctionCall.ts","../src/compiler/Parser/ParsedHierarchy/Expression/NumberExpression.ts","../src/compiler/Parser/ParsedHierarchy/Expression/UnaryExpression.ts","../src/compiler/Parser/ParsedHierarchy/Expression/BinaryExpression.ts","../src/compiler/Parser/CharacterSet.ts","../src/compiler/Parser/CharacterRange.ts","../src/engine/ChoicePoint.ts","../src/engine/Pointer.ts","../src/engine/Divert.ts","../src/engine/VariableAssignment.ts","../src/compiler/Parser/ParsedHierarchy/Choice.ts","../src/compiler/Parser/StringParser/StringParserElement.ts","../src/compiler/Parser/StringParser/StringParserState.ts","../src/compiler/Parser/StringParser/StringParser.ts","../src/compiler/Parser/CommentEliminator.ts","../src/compiler/Parser/ParsedHierarchy/Conditional/Conditional.ts","../src/compiler/Parser/ParsedHierarchy/Text.ts","../src/compiler/Parser/ParsedHierarchy/Declaration/ConstantDeclaration.ts","../src/compiler/Parser/ParsedHierarchy/Flow/FlowLevel.ts","../src/compiler/Parser/ParsedHierarchy/Sequence/SequenceType.ts","../src/compiler/Parser/CustomFlags.ts","../src/compiler/Parser/StatementLevel.ts","../src/engine/Error.ts","../src/compiler/Parser/ParsedHierarchy/Gather/Gather.ts","../src/compiler/Parser/ParsedHierarchy/Path.ts","../src/compiler/Parser/ParsedHierarchy/ReturnType.ts","../src/compiler/Parser/ParsedHierarchy/Flow/ClosestFlowBase.ts","../src/compiler/Parser/ParsedHierarchy/Identifier.ts","../src/compiler/Parser/ParsedHierarchy/Flow/FlowBase.ts","../src/compiler/Parser/ParsedHierarchy/ContentList.ts","../src/engine/VariableReference.ts","../src/compiler/Parser/ParsedHierarchy/Variable/VariableReference.ts","../src/compiler/Parser/ParsedHierarchy/FunctionCall.ts","../src/compiler/Parser/ParsedHierarchy/Expression/MultipleConditionExpression.ts","../src/compiler/Parser/ParsedHierarchy/Divert/DivertTarget.ts","../src/compiler/Parser/ParsedHierarchy/Divert/Divert.ts","../src/compiler/Parser/ParsedHierarchy/Gather/GatherPointToResolve.ts","../src/compiler/Parser/ParsedHierarchy/Sequence/SequenceDivertToResolve.ts","../src/compiler/Parser/ParsedHierarchy/Sequence/Sequence.ts","../src/compiler/Parser/ParsedHierarchy/TunnelOnwards.ts","../src/engine/ListDefinition.ts","../src/compiler/Parser/ParsedHierarchy/List/ListDefinition.ts","../src/compiler/Parser/ParsedHierarchy/Variable/VariableAssignment.ts","../src/compiler/Parser/ParsedHierarchy/Weave.ts","../src/compiler/Parser/ParsedHierarchy/Conditional/ConditionalSingleBranch.ts","../src/engine/DebugMetadata.ts","../src/compiler/Parser/ParsedHierarchy/Declaration/ExternalDeclaration.ts","../src/compiler/Parser/FlowDecl.ts","../src/compiler/Parser/ParsedHierarchy/Wrap.ts","../src/compiler/Parser/ParsedHierarchy/Glue.ts","../src/engine/Glue.ts","../src/compiler/Parser/ParsedHierarchy/Expression/IncDecExpression.ts","../src/compiler/Parser/ParsedHierarchy/IncludedFile.ts","../src/compiler/Parser/InfixOperator.ts","../src/compiler/Parser/ParsedHierarchy/Knot.ts","../src/compiler/Parser/ParsedHierarchy/List/List.ts","../src/compiler/Parser/ParsedHierarchy/List/ListElementDefinition.ts","../src/compiler/Parser/ParsedHierarchy/Stitch.ts","../src/engine/Tag.ts","../src/engine/Choice.ts","../src/engine/ListDefinitionsOrigin.ts","../src/engine/JsonSerialisation.ts","../src/engine/CallStack.ts","../src/engine/VariablesState.ts","../src/engine/PRNG.ts","../src/engine/StatePatch.ts","../src/engine/SimpleJson.ts","../src/engine/Flow.ts","../src/engine/StoryState.ts","../src/engine/StopWatch.ts","../src/engine/Story.ts","../src/compiler/Parser/ParsedHierarchy/Story.ts","../src/compiler/Parser/ParsedHierarchy/Expression/StringExpression.ts","../src/compiler/Parser/ParsedHierarchy/Tag.ts","../src/compiler/FileHandler/DefaultFileHandler.ts","../src/compiler/Parser/InkParser.ts","../src/compiler/Compiler.ts","../src/compiler/FileHandler/JsonFileHandler.ts"],"sourcesContent":["import { ErrorHandler } from \"../engine/Error\";\nimport { IFileHandler } from \"./IFileHandler\";\n\nexport class CompilerOptions {\n  constructor(\n    public readonly sourceFilename: string | null = null,\n    public readonly pluginNames: string[] = [],\n    public readonly countAllVisits: boolean = false,\n    public readonly errorHandler: ErrorHandler | null = null,\n    public readonly fileHandler: IFileHandler | null = null\n  ) {}\n}\n","import { DebugMetadata } from \"../engine/DebugMetadata\";\n\nexport class DebugSourceRange {\n  constructor(\n    public readonly length: number,\n    public readonly debugMetadata: DebugMetadata | null,\n    public text: string\n  ) {}\n}\n","// TODO: Unifify with Engine.\n\nexport enum ErrorType {\n  Author,\n  Warning,\n  Error,\n}\n","export namespace Debug {\n  export function AssertType<T>(\n    variable: any,\n    type: new () => T,\n    message: string\n  ): void | never {\n    Assert(variable instanceof type, message);\n  }\n\n  export function Assert(condition: boolean, message?: string): void | never {\n    if (!condition) {\n      if (typeof message !== \"undefined\") {\n        console.warn(message);\n      }\n\n      if (console.trace) {\n        console.trace();\n      }\n\n      throw new Error(\"\");\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { StoryException } from \"./StoryException\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { tryParseInt, tryParseFloat } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport abstract class AbstractValue extends InkObject {\n  public abstract get valueType(): ValueType;\n  public abstract get isTruthy(): boolean;\n  public abstract get valueObject(): any;\n\n  public abstract Cast(newType: ValueType): Value<any>;\n\n  public static Create(\n    val: any,\n    preferredNumberType?: ValueType\n  ): Value<any> | null {\n    // This code doesn't exist in upstream and is simply here to enforce\n    // the creation of the proper number value.\n    // If `preferredNumberType` is not provided or if value doesn't match\n    // `preferredNumberType`, this conditional does nothing.\n    if (preferredNumberType) {\n      if (\n        preferredNumberType === (ValueType.Int as ValueType) &&\n        Number.isInteger(Number(val))\n      ) {\n        return new IntValue(Number(val));\n      } else if (\n        preferredNumberType === (ValueType.Float as ValueType) &&\n        !isNaN(val)\n      ) {\n        return new FloatValue(Number(val));\n      }\n    }\n\n    if (typeof val === \"boolean\") {\n      return new BoolValue(Boolean(val));\n    }\n\n    // https://github.com/y-lohse/inkjs/issues/425\n    // Changed condition sequence, because Number('') is\n    // parsed to 0, which made setting string to empty\n    // impossible\n    if (typeof val === \"string\") {\n      return new StringValue(String(val));\n    } else if (Number.isInteger(Number(val))) {\n      return new IntValue(Number(val));\n    } else if (!isNaN(val)) {\n      return new FloatValue(Number(val));\n    } else if (val instanceof Path) {\n      return new DivertTargetValue(asOrThrows(val, Path));\n    } else if (val instanceof InkList) {\n      return new ListValue(asOrThrows(val, InkList));\n    }\n\n    return null;\n  }\n  public Copy() {\n    return asOrThrows(AbstractValue.Create(this.valueObject), InkObject);\n  }\n  public BadCastException(targetType: ValueType) {\n    return new StoryException(\n      \"Can't cast \" +\n        this.valueObject +\n        \" from \" +\n        this.valueType +\n        \" to \" +\n        targetType\n    );\n  }\n}\n\nexport abstract class Value<\n  T extends { toString: () => string }\n> extends AbstractValue {\n  public value: T | null;\n\n  constructor(val: T | null) {\n    super();\n    this.value = val;\n  }\n  public get valueObject() {\n    return this.value;\n  }\n  public toString() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.toString();\n  }\n}\n\nexport class BoolValue extends Value<boolean> {\n  constructor(val: boolean) {\n    super(val || false);\n  }\n  public get isTruthy() {\n    return Boolean(this.value);\n  }\n  public get valueType() {\n    return ValueType.Bool;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value ? 1 : 0);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value ? 1.0 : 0.0);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(this.value ? \"true\" : \"false\");\n    }\n\n    throw this.BadCastException(newType);\n  }\n\n  public toString() {\n    return this.value ? \"true\" : \"false\";\n  }\n}\n\nexport class IntValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0);\n  }\n  public get isTruthy() {\n    return this.value != 0;\n  }\n  public get valueType() {\n    return ValueType.Int;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0 ? false : true);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class FloatValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0.0);\n  }\n  public get isTruthy() {\n    return this.value != 0.0;\n  }\n  public get valueType() {\n    return ValueType.Float;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0.0 ? false : true);\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class StringValue extends Value<string> {\n  public _isNewline: boolean;\n  public _isInlineWhitespace: boolean;\n\n  constructor(val: string) {\n    super(val || \"\");\n\n    this._isNewline = this.value == \"\\n\";\n    this._isInlineWhitespace = true;\n\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (this.value.length > 0) {\n      this.value.split(\"\").every((c) => {\n        if (c != \" \" && c != \"\\t\") {\n          this._isInlineWhitespace = false;\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }\n  public get valueType() {\n    return ValueType.String;\n  }\n  public get isTruthy() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.length > 0;\n  }\n  public get isNewline() {\n    return this._isNewline;\n  }\n  public get isInlineWhitespace() {\n    return this._isInlineWhitespace;\n  }\n  public get isNonWhitespace() {\n    return !this.isNewline && !this.isInlineWhitespace;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      let parsedInt = tryParseInt(this.value);\n      if (parsedInt.exists) {\n        return new IntValue(parsedInt.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    if (newType == ValueType.Float) {\n      let parsedFloat = tryParseFloat(this.value);\n      if (parsedFloat.exists) {\n        return new FloatValue(parsedFloat.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class DivertTargetValue extends Value<Path> {\n  constructor(targetPath: Path | null = null) {\n    super(targetPath);\n  }\n  public get valueType() {\n    return ValueType.DivertTarget;\n  }\n  public get targetPath() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set targetPath(value: Path) {\n    this.value = value;\n  }\n  public get isTruthy(): never {\n    throw new Error(\"Shouldn't be checking the truthiness of a divert target\");\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"DivertTargetValue(\" + this.targetPath + \")\";\n  }\n}\n\nexport class VariablePointerValue extends Value<string> {\n  public _contextIndex: number;\n\n  constructor(variableName: string, contextIndex: number = -1) {\n    super(variableName);\n\n    this._contextIndex = contextIndex;\n  }\n\n  public get contextIndex() {\n    return this._contextIndex;\n  }\n  public set contextIndex(value: number) {\n    this._contextIndex = value;\n  }\n  public get variableName() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set variableName(value: string) {\n    this.value = value;\n  }\n  public get valueType() {\n    return ValueType.VariablePointer;\n  }\n\n  public get isTruthy(): never {\n    throw new Error(\n      \"Shouldn't be checking the truthiness of a variable pointer\"\n    );\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"VariablePointerValue(\" + this.variableName + \")\";\n  }\n  public Copy() {\n    return new VariablePointerValue(this.variableName, this.contextIndex);\n  }\n}\n\nexport class ListValue extends Value<InkList> {\n  public get isTruthy() {\n    if (this.value === null) {\n      return throwNullException(\"this.value\");\n    }\n    return this.value.Count > 0;\n  }\n  public get valueType() {\n    return ValueType.List;\n  }\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == ValueType.Int) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new IntValue(0);\n      else return new IntValue(max.Value);\n    } else if (newType == ValueType.Float) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new FloatValue(0.0);\n      else return new FloatValue(max.Value);\n    } else if (newType == ValueType.String) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new StringValue(\"\");\n      else {\n        return new StringValue(max.Key.toString());\n      }\n    }\n\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  constructor();\n  constructor(list: InkList);\n  constructor(listOrSingleItem: InkListItem, singleValue: number);\n  constructor(listOrSingleItem?: InkListItem | InkList, singleValue?: number) {\n    super(null);\n\n    if (!listOrSingleItem && !singleValue) {\n      this.value = new InkList();\n    } else if (listOrSingleItem instanceof InkList) {\n      this.value = new InkList(listOrSingleItem);\n    } else if (\n      listOrSingleItem instanceof InkListItem &&\n      typeof singleValue === \"number\"\n    ) {\n      this.value = new InkList({\n        Key: listOrSingleItem,\n        Value: singleValue,\n      });\n    }\n  }\n  public static RetainListOriginsForAssignment(\n    oldValue: InkObject | null,\n    newValue: InkObject\n  ) {\n    let oldList = asOrNull(oldValue, ListValue);\n    let newList = asOrNull(newValue, ListValue);\n\n    if (newList && newList.value === null)\n      return throwNullException(\"newList.value\");\n    if (oldList && oldList.value === null)\n      return throwNullException(\"oldList.value\");\n\n    // When assigning the empty list, try to retain any initial origin names\n    if (oldList && newList && newList.value!.Count == 0)\n      newList.value!.SetInitialOriginNames(oldList.value!.originNames);\n  }\n}\n\nexport enum ValueType {\n  Bool = -1,\n  Int = 0,\n  Float = 1,\n  List = 2,\n  String = 3,\n  DivertTarget = 4,\n  VariablePointer = 5,\n}\n","export enum PushPopType {\n  Tunnel = 0,\n  Function = 1,\n  FunctionEvaluationFromGame = 2,\n}\n","export enum SymbolType {\n  Knot = 0,\n  List = 1,\n  ListItem = 2,\n  Var = 3,\n  SubFlowAndWeave = 4,\n  Arg = 5,\n  Temp = 6,\n}\n","import { Identifier } from \"./Identifier\";\n\nexport class Argument {\n  constructor(\n    public identifier: Identifier | null = null,\n    public isByReference: boolean | null = null,\n    public isDivertTarget: boolean | null = null\n  ) {}\n\n  get typeName(): string {\n    return \"Argument\";\n  }\n}\n","import { INamedContent } from \"./INamedContent\";\n\nexport function asOrNull<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | null {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    return null;\n  }\n}\n\nexport function asOrThrows<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | never {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    throw new Error(`${obj} is not of type ${type}`);\n  }\n}\n\nexport function asNumberOrThrows(obj: any) {\n  if (typeof obj === \"number\") {\n    return obj as number;\n  } else {\n    throw new Error(`${obj} is not a number`);\n  }\n}\n\nexport function asBooleanOrThrows(obj: any) {\n  if (typeof obj === \"boolean\") {\n    return obj as boolean;\n  } else {\n    throw new Error(`${obj} is not a boolean`);\n  }\n}\n\n// So here, in the reference implementation, contentObj is casted to an INamedContent\n// but here we use js-style duck typing: if it implements the same props as the interface,\n// we treat it as valid.\nexport function asINamedContentOrNull(obj: any): INamedContent | null {\n  if (obj.hasValidName && obj.name) {\n    return obj as INamedContent;\n  }\n\n  return null;\n}\n\nexport function nullIfUndefined<T>(obj: T | undefined): T | null {\n  if (typeof obj === \"undefined\") {\n    return null;\n  }\n\n  return obj;\n}\n\nexport function isEquatable(type: any) {\n  return typeof type === \"object\" && typeof type.Equals === \"function\";\n}\n\nfunction unsafeTypeAssertion<T>(\n  obj: any,\n  type: (new () => T) | (Function & { prototype: T })\n) {\n  return obj as T;\n}\n\nexport function filterUndef<T>(element: T | undefined): element is T {\n  return element != undefined;\n}\n","import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { DebugMetadata } from \"../../../engine/DebugMetadata\";\nimport { FindQueryFunc } from \"./FindQueryFunc\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Path as RuntimePath } from \"../../../engine/Path\";\nimport { Story } from \"./Story\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\nexport abstract class ParsedObject {\n  public abstract readonly GenerateRuntimeObject: () => RuntimeObject | null;\n\n  private _alreadyHadError: boolean = false;\n  private _alreadyHadWarning: boolean = false;\n  private _debugMetadata: DebugMetadata | null = null;\n  private _runtimeObject: RuntimeObject | null = null;\n\n  public content: ParsedObject[] = [];\n  public parent: ParsedObject | null = null;\n\n  get debugMetadata() {\n    if (this._debugMetadata === null && this.parent) {\n      return this.parent.debugMetadata;\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value: DebugMetadata | null) {\n    this._debugMetadata = value;\n  }\n\n  get hasOwnDebugMetadata(): boolean {\n    return Boolean(this.debugMetadata);\n  }\n\n  get typeName(): string {\n    return \"ParsedObject\";\n  }\n\n  public readonly GetType = (): string => this.typeName;\n\n  get story(): Story {\n    let ancestor: ParsedObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n\n    return ancestor as Story;\n  }\n\n  get runtimeObject(): RuntimeObject {\n    if (!this._runtimeObject) {\n      this._runtimeObject = this.GenerateRuntimeObject();\n      if (this._runtimeObject) {\n        this._runtimeObject.debugMetadata = this.debugMetadata;\n      }\n    }\n\n    return this._runtimeObject as RuntimeObject;\n  }\n\n  set runtimeObject(value: RuntimeObject) {\n    this._runtimeObject = value;\n  }\n\n  get runtimePath(): RuntimePath {\n    if (!this.runtimeObject.path) {\n      throw new Error();\n    }\n\n    return this.runtimeObject.path;\n  }\n\n  // When counting visits and turns since, different object\n  // types may have different containers that needs to be counted.\n  // For most it'll just be the object's main runtime object,\n  // but for e.g. choices, it'll be the target container.\n  get containerForCounting(): RuntimeContainer | null {\n    return this.runtimeObject as RuntimeContainer;\n  }\n\n  get ancestry(): ParsedObject[] {\n    let result = [];\n\n    let ancestor = this.parent;\n    while (ancestor) {\n      result.push(ancestor);\n      ancestor = ancestor.parent;\n    }\n\n    result = result.reverse();\n\n    return result;\n  }\n\n  /*\n  get descriptionOfScope(): string {\n    const locationNames: string[] = [];\n\n    let ancestor: ParsedObject | null = this;\n    while (ancestor) {\n      var ancestorFlow = ancestor as FlowBase;\n      if (ancestorFlow && ancestorFlow.name != null) {\n        locationNames.push(`'${ancestorFlow.name}'`);\n      }\n      ancestor = ancestor.parent;\n    }\n\n    let scopeSB = '';\n    if (locationNames.length > 0) {\n      const locationsListStr = locationNames.join(', ');\n      scopeSB += `${locationsListStr} and`;\n    }\n\n    scopeSB += 'at top scope';\n\n    return scopeSB;\n  }\n*/\n\n  // Return the object so that method can be chained easily\n  public readonly AddContent = <T extends ParsedObject, V extends T | T[]>(\n    subContent: V\n  ) => {\n    if (this.content === null) {\n      this.content = [];\n    }\n\n    const sub = Array.isArray(subContent) ? subContent : [subContent];\n\n    // Make resilient to content not existing, which can happen\n    // in the case of parse errors where we've already reported\n    // an error but still want a valid structure so we can\n    // carry on parsing.\n    for (const ss of sub) {\n      if (ss.hasOwnProperty(\"parent\")) {\n        ss.parent = this;\n      }\n      this.content.push(ss);\n    }\n\n    if (Array.isArray(subContent)) {\n      return;\n    } else {\n      return subContent;\n    }\n  };\n\n  public readonly InsertContent = <T extends ParsedObject>(\n    index: number,\n    subContent: T\n  ): T => {\n    if (this.content === null) {\n      this.content = [];\n    }\n\n    subContent.parent = this;\n    this.content.splice(index, 0, subContent);\n\n    return subContent;\n  };\n\n  public readonly Find =\n    <T extends ParsedObject>(\n      type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n    ) =>\n    (queryFunc: FindQueryFunc<T> | null = null): T | null => {\n      let tObj = asOrNull(this, type) as any as T;\n      if (tObj !== null && (queryFunc === null || queryFunc(tObj) === true)) {\n        return tObj;\n      }\n\n      if (this.content === null) {\n        return null;\n      }\n\n      for (const obj of this.content) {\n        let nestedResult = obj.Find && obj.Find(type)(queryFunc);\n        if (nestedResult) {\n          return nestedResult as T;\n        }\n      }\n\n      return null;\n    };\n\n  public readonly FindAll =\n    <T extends ParsedObject>(\n      type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n    ) =>\n    (queryFunc?: FindQueryFunc<T>, foundSoFar?: T[]): T[] => {\n      const found = Array.isArray(foundSoFar) ? foundSoFar : [];\n\n      const tObj = asOrNull(this, type);\n      if (tObj !== null && (!queryFunc || queryFunc(tObj) === true)) {\n        found.push(tObj);\n      }\n\n      if (this.content === null) {\n        return [];\n      }\n\n      for (const obj of this.content) {\n        obj.FindAll && obj.FindAll(type)(queryFunc, found);\n      }\n\n      return found;\n    };\n\n  public ResolveReferences(context: Story) {\n    if (this.content !== null) {\n      for (const obj of this.content) {\n        obj.ResolveReferences(context);\n      }\n    }\n  }\n\n  public Error(\n    message: string,\n    source: ParsedObject | null = null,\n    isWarning: boolean = false\n  ): void {\n    if (source === null) {\n      source = this;\n    }\n\n    // Only allow a single parsed object to have a single error *directly* associated with it\n    if (\n      (source._alreadyHadError && !isWarning) ||\n      (source._alreadyHadWarning && isWarning)\n    ) {\n      return;\n    }\n\n    if (this.parent) {\n      this.parent.Error(message, source, isWarning);\n    } else {\n      throw new Error(`No parent object to send error to: ${message}`);\n    }\n\n    if (isWarning) {\n      source._alreadyHadWarning = true;\n    } else {\n      source._alreadyHadError = true;\n    }\n  }\n\n  public readonly Warning = (\n    message: string,\n    source: ParsedObject | null = null\n  ): void => {\n    this.Error(message, source, true);\n  };\n}\n","﻿import { ParsedObject } from \"./Object\";\n\nexport class AuthorWarning extends ParsedObject {\n  constructor(public readonly warningMessage: string) {\n    super();\n  }\n\n  get typeName(): string {\n    return \"AuthorWarning\";\n  }\n\n  public readonly GenerateRuntimeObject = (): null => {\n    this.Warning(this.warningMessage);\n    return null;\n  };\n}\n","export class Path {\n  public static parentId = \"^\";\n\n  public _isRelative: boolean;\n  public _components: Path.Component[];\n  public _componentsString: string | null;\n\n  constructor();\n  constructor(componentsString: string);\n  constructor(head: Path.Component, tail: Path);\n  constructor(head: Path.Component[], relative?: boolean);\n  constructor() {\n    this._components = [];\n    this._componentsString = null;\n    this._isRelative = false;\n\n    if (typeof arguments[0] == \"string\") {\n      let componentsString = arguments[0] as string;\n      this.componentsString = componentsString;\n    } else if (\n      arguments[0] instanceof Path.Component &&\n      arguments[1] instanceof Path\n    ) {\n      let head = arguments[0] as Path.Component;\n      let tail = arguments[1] as Path;\n      this._components.push(head);\n      this._components = this._components.concat(tail._components);\n    } else if (arguments[0] instanceof Array) {\n      let head = arguments[0] as Path.Component[];\n      let relative = !!arguments[1] as boolean;\n      this._components = this._components.concat(head);\n      this._isRelative = relative;\n    }\n  }\n  get isRelative() {\n    return this._isRelative;\n  }\n  get componentCount(): number {\n    return this._components.length;\n  }\n  get head(): Path.Component | null {\n    if (this._components.length > 0) {\n      return this._components[0];\n    } else {\n      return null;\n    }\n  }\n  get tail(): Path {\n    if (this._components.length >= 2) {\n      // careful, the original code uses length-1 here. This is because the second argument of\n      // List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n      let tailComps = this._components.slice(1, this._components.length);\n      return new Path(tailComps);\n    } else {\n      return Path.self;\n    }\n  }\n  get length(): number {\n    return this._components.length;\n  }\n  get lastComponent(): Path.Component | null {\n    let lastComponentIdx = this._components.length - 1;\n    if (lastComponentIdx >= 0) {\n      return this._components[lastComponentIdx];\n    } else {\n      return null;\n    }\n  }\n  get containsNamedComponent(): boolean {\n    for (let i = 0, l = this._components.length; i < l; i++) {\n      if (!this._components[i].isIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static get self(): Path {\n    let path = new Path();\n    path._isRelative = true;\n    return path;\n  }\n\n  public GetComponent(index: number): Path.Component {\n    return this._components[index];\n  }\n  public PathByAppendingPath(pathToAppend: Path): Path {\n    let p = new Path();\n\n    let upwardMoves = 0;\n    for (let i = 0; i < pathToAppend._components.length; ++i) {\n      if (pathToAppend._components[i].isParent) {\n        upwardMoves++;\n      } else {\n        break;\n      }\n    }\n\n    for (let i = 0; i < this._components.length - upwardMoves; ++i) {\n      p._components.push(this._components[i]);\n    }\n\n    for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {\n      p._components.push(pathToAppend._components[i]);\n    }\n\n    return p;\n  }\n  get componentsString(): string {\n    if (this._componentsString == null) {\n      this._componentsString = this._components.join(\".\");\n      if (this.isRelative)\n        this._componentsString = \".\" + this._componentsString;\n    }\n\n    return this._componentsString;\n  }\n  set componentsString(value: string) {\n    this._components.length = 0;\n\n    this._componentsString = value;\n\n    if (this._componentsString == null || this._componentsString == \"\") return;\n\n    if (this._componentsString[0] == \".\") {\n      this._isRelative = true;\n      this._componentsString = this._componentsString.substring(1);\n    }\n\n    let componentStrings = this._componentsString.split(\".\");\n    for (let str of componentStrings) {\n      // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n      // the normal parseInt won't do for the detection because it's too relaxed.\n      // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n      if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {\n        this._components.push(new Path.Component(parseInt(str)));\n      } else {\n        this._components.push(new Path.Component(str));\n      }\n    }\n  }\n  public toString(): string {\n    return this.componentsString;\n  }\n  public Equals(otherPath: Path | null): boolean {\n    if (otherPath == null) return false;\n\n    if (otherPath._components.length != this._components.length) return false;\n\n    if (otherPath.isRelative != this.isRelative) return false;\n\n    // the original code uses SequenceEqual here, so we need to iterate over the components manually.\n    for (let i = 0, l = otherPath._components.length; i < l; i++) {\n      // it's not quite clear whether this test should use Equals or a simple == operator,\n      // see https://github.com/y-lohse/inkjs/issues/22\n      if (!otherPath._components[i].Equals(this._components[i])) return false;\n    }\n\n    return true;\n  }\n  public PathByAppendingComponent(c: Path.Component): Path {\n    let p = new Path();\n    p._components.push(...this._components);\n    p._components.push(c);\n    return p;\n  }\n}\n\nexport namespace Path {\n  export class Component {\n    public readonly index: number;\n    public readonly name: string | null;\n\n    constructor(indexOrName: string | number) {\n      this.index = -1;\n      this.name = null;\n      if (typeof indexOrName == \"string\") {\n        this.name = indexOrName;\n      } else {\n        this.index = indexOrName;\n      }\n    }\n    get isIndex(): boolean {\n      return this.index >= 0;\n    }\n    get isParent(): boolean {\n      return this.name == Path.parentId;\n    }\n\n    public static ToParent(): Component {\n      return new Component(Path.parentId);\n    }\n    public toString(): string | null {\n      if (this.isIndex) {\n        return this.index.toString();\n      } else {\n        return this.name;\n      }\n    }\n    public Equals(otherComp: Component): boolean {\n      if (otherComp != null && otherComp.isIndex == this.isIndex) {\n        if (this.isIndex) {\n          return this.index == otherComp.index;\n        } else {\n          return this.name == otherComp.name;\n        }\n      }\n\n      return false;\n    }\n  }\n}\n","/**\n * In the original C# code, a SystemException would be thrown when passing\n * null to methods expected a valid instance. Javascript has no such\n * concept, but TypeScript will not allow `null` to be passed to methods\n * explicitely requiring a valid type.\n *\n * Whenever TypeScript complain about the possibility of a `null` value,\n * check the offending value and it it's null, throw this exception using\n * `throwNullException(name: string)`.\n */\nexport class NullException extends Error {}\n\n/**\n * Throw a NullException.\n *\n * @param name a short description of the offending value (often its name within the code).\n */\nexport function throwNullException(name: string): never {\n  throw new NullException(`${name} is null or undefined`);\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { asOrNull, asINamedContentOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SearchResult } from \"./SearchResult\";\nimport { DebugMetadata } from \"./DebugMetadata\";\n\nexport class InkObject {\n  public parent: InkObject | null = null;\n\n  get debugMetadata(): DebugMetadata | null {\n    if (this._debugMetadata === null) {\n      if (this.parent) {\n        return this.parent.debugMetadata;\n      }\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value) {\n    this._debugMetadata = value;\n  }\n\n  get ownDebugMetadata() {\n    return this._debugMetadata;\n  }\n\n  private _debugMetadata: DebugMetadata | null = null;\n\n  public DebugLineNumberOfPath(path: Path) {\n    if (path === null) return null;\n\n    // Try to get a line number from debug metadata\n    let root = this.rootContentContainer;\n    if (root) {\n      let targetContent = root.ContentAtPath(path).obj;\n      if (targetContent) {\n        let dm = targetContent.debugMetadata;\n        if (dm !== null) {\n          return dm.startLineNumber;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get path() {\n    if (this._path == null) {\n      if (this.parent == null) {\n        this._path = new Path();\n      } else {\n        let comps: Path.Component[] = [];\n\n        let child: InkObject = this;\n        let container = asOrNull(child.parent, Container);\n\n        while (container !== null) {\n          let namedChild = asINamedContentOrNull(child);\n          if (namedChild != null && namedChild.hasValidName) {\n            if (namedChild.name === null)\n              return throwNullException(\"namedChild.name\");\n            comps.unshift(new Path.Component(namedChild.name!));\n          } else {\n            comps.unshift(new Path.Component(container.content.indexOf(child)));\n          }\n\n          child = container;\n          container = asOrNull(container.parent, Container);\n        }\n\n        this._path = new Path(comps);\n      }\n    }\n\n    return this._path;\n  }\n  private _path: Path | null = null;\n\n  public ResolvePath(path: Path | null): SearchResult {\n    if (path === null) return throwNullException(\"path\");\n    if (path.isRelative) {\n      let nearestContainer = asOrNull(this, Container);\n\n      if (nearestContainer === null) {\n        Debug.Assert(\n          this.parent !== null,\n          \"Can't resolve relative path because we don't have a parent\"\n        );\n        nearestContainer = asOrNull(this.parent, Container);\n        Debug.Assert(\n          nearestContainer !== null,\n          \"Expected parent to be a container\"\n        );\n        Debug.Assert(path.GetComponent(0).isParent);\n        path = path.tail;\n      }\n\n      if (nearestContainer === null) {\n        return throwNullException(\"nearestContainer\");\n      }\n      return nearestContainer.ContentAtPath(path);\n    } else {\n      let contentContainer = this.rootContentContainer;\n      if (contentContainer === null) {\n        return throwNullException(\"contentContainer\");\n      }\n      return contentContainer.ContentAtPath(path);\n    }\n  }\n\n  public ConvertPathToRelative(globalPath: Path) {\n    let ownPath = this.path;\n\n    let minPathLength = Math.min(globalPath.length, ownPath.length);\n    let lastSharedPathCompIndex = -1;\n\n    for (let i = 0; i < minPathLength; ++i) {\n      let ownComp = ownPath.GetComponent(i);\n      let otherComp = globalPath.GetComponent(i);\n\n      if (ownComp.Equals(otherComp)) {\n        lastSharedPathCompIndex = i;\n      } else {\n        break;\n      }\n    }\n\n    // No shared path components, so just use global path\n    if (lastSharedPathCompIndex == -1) return globalPath;\n\n    let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;\n\n    let newPathComps: Path.Component[] = [];\n\n    for (let up = 0; up < numUpwardsMoves; ++up)\n      newPathComps.push(Path.Component.ToParent());\n\n    for (\n      let down = lastSharedPathCompIndex + 1;\n      down < globalPath.componentCount;\n      ++down\n    )\n      newPathComps.push(globalPath.GetComponent(down));\n\n    let relativePath = new Path(newPathComps, true);\n    return relativePath;\n  }\n\n  public CompactPathString(otherPath: Path) {\n    let globalPathStr = null;\n    let relativePathStr = null;\n\n    if (otherPath.isRelative) {\n      relativePathStr = otherPath.componentsString;\n      globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n    } else {\n      let relativePath = this.ConvertPathToRelative(otherPath);\n      relativePathStr = relativePath.componentsString;\n      globalPathStr = otherPath.componentsString;\n    }\n\n    if (relativePathStr.length < globalPathStr.length) return relativePathStr;\n    else return globalPathStr;\n  }\n\n  get rootContentContainer() {\n    let ancestor: InkObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n    return asOrNull(ancestor, Container);\n  }\n\n  public Copy(): InkObject {\n    throw Error(\"Not Implemented: Doesn't support copying\");\n  }\n  // SetChild works slightly diferently in the js implementation.\n  // Since we can't pass an objets property by reference, we instead pass\n  // the object and the property string.\n  // TODO: This method can probably be rewritten with type-safety in mind.\n  public SetChild(obj: any, prop: any, value: any) {\n    if (obj[prop]) obj[prop] = null;\n\n    obj[prop] = value;\n\n    if (obj[prop]) obj[prop].parent = this;\n  }\n\n  public Equals(obj: any) {\n    return obj === this;\n  }\n}\n","export class StringBuilder {\n  private string: string;\n\n  constructor(str?: string) {\n    str = typeof str !== \"undefined\" ? str.toString() : \"\";\n    this.string = str;\n  }\n  get Length(): number {\n    return this.string.length;\n  }\n  public Append(str: string | null) {\n    if (str !== null) {\n      this.string += str;\n    }\n  }\n  public AppendLine(str?: string) {\n    if (typeof str !== \"undefined\") this.Append(str);\n    this.string += \"\\n\";\n  }\n  public AppendFormat(format: string, ...args: any[]) {\n    // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n    this.string += format.replace(/{(\\d+)}/g, (match: string, num: number) =>\n      typeof args[num] != \"undefined\" ? args[num] : match\n    );\n  }\n  public toString(): string {\n    return this.string;\n  }\n\n  public Clear() {\n    this.string = \"\";\n  }\n}\n","import { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Story } from \"./Story\";\n\nexport class InkListItem implements IInkListItem {\n  // InkListItem is a struct\n\n  public readonly originName: string | null = null;\n  public readonly itemName: string | null = null;\n\n  constructor(originName: string | null, itemName: string | null);\n  constructor(fullName: string | null);\n  constructor() {\n    if (typeof arguments[1] !== \"undefined\") {\n      let originName = arguments[0] as string | null;\n      let itemName = arguments[1] as string | null;\n\n      this.originName = originName;\n      this.itemName = itemName;\n    } else if (arguments[0]) {\n      let fullName = arguments[0] as string;\n\n      let nameParts = fullName.toString().split(\".\");\n      this.originName = nameParts[0];\n      this.itemName = nameParts[1];\n    }\n  }\n  public static get Null() {\n    return new InkListItem(null, null);\n  }\n  public get isNull() {\n    return this.originName == null && this.itemName == null;\n  }\n  get fullName() {\n    return (\n      (this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName\n    );\n  }\n  public toString(): string {\n    return this.fullName;\n  }\n  public Equals(obj: InkListItem) {\n    if (obj instanceof InkListItem) {\n      let otherItem = obj;\n      return (\n        otherItem.itemName == this.itemName &&\n        otherItem.originName == this.originName\n      );\n    }\n\n    return false;\n  }\n\n  // These methods did not exist in the original C# code. Their purpose is to\n  // make `InkListItem` mimics the value-type semantics of the original\n  // struct. Please refer to the end of this file, for a more in-depth\n  // explanation.\n\n  /**\n   * Returns a shallow clone of the current instance.\n   */\n  public copy() {\n    return new InkListItem(this.originName, this.itemName);\n  }\n  /**\n   * Returns a `SerializedInkListItem` representing the current\n   * instance. The result is intended to be used as a key inside a Map.\n   */\n  public serialized(): SerializedInkListItem {\n    // We are simply using a JSON representation as a value-typed key.\n    return JSON.stringify({\n      originName: this.originName,\n      itemName: this.itemName,\n    });\n  }\n\n  /**\n   * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n   */\n  public static fromSerializedKey(key: SerializedInkListItem): InkListItem {\n    let obj = JSON.parse(key);\n    if (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;\n\n    let inkListItem = obj as IInkListItem;\n\n    return new InkListItem(inkListItem.originName, inkListItem.itemName);\n  }\n\n  /**\n   * Determines whether the given item is sufficiently `InkListItem`-like\n   * to be used as a template when reconstructing the InkListItem.\n   */\n  private static isLikeInkListItem(item: any) {\n    if (typeof item !== \"object\") return false;\n    if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\"))\n      return false;\n    if (typeof item.originName !== \"string\" && typeof item.originName !== null)\n      return false;\n    if (typeof item.itemName !== \"string\" && typeof item.itemName !== null)\n      return false;\n\n    return true;\n  }\n}\n\nexport class InkList extends Map<SerializedInkListItem, number> {\n  public origins: ListDefinition[] | null = null;\n  public _originNames: string[] | null = [];\n\n  constructor();\n  constructor(otherList: InkList);\n  constructor(singleOriginListName: string, originStory: Story);\n  constructor(singleElement: KeyValuePair<InkListItem, number>);\n  constructor() {\n    // Trying to be smart here, this emulates the constructor inheritance found\n    // in the original code, but only if otherList is an InkList. IIFE FTW.\n    super(\n      (() => {\n        if (arguments[0] instanceof InkList) {\n          return arguments[0];\n        } else {\n          return [];\n        }\n      })()\n    );\n\n    if (arguments[0] instanceof InkList) {\n      let otherList = arguments[0] as InkList;\n\n      let otherOriginNames = otherList.originNames as string[];\n      if (otherOriginNames !== null)\n        this._originNames = otherOriginNames.slice();\n      if (otherList.origins !== null) {\n        this.origins = otherList.origins.slice();\n      }\n    } else if (typeof arguments[0] === \"string\") {\n      let singleOriginListName = arguments[0] as string;\n      let originStory = arguments[1] as Story;\n      this.SetInitialOriginName(singleOriginListName);\n\n      if (originStory.listDefinitions === null) {\n        return throwNullException(\"originStory.listDefinitions\");\n      }\n      let def = originStory.listDefinitions.TryListGetDefinition(\n        singleOriginListName,\n        null\n      );\n      if (def.exists) {\n        // Throwing now, because if the value is `null` it will\n        // eventually throw down the line.\n        if (def.result === null) {\n          return throwNullException(\"def.result\");\n        }\n        this.origins = [def.result];\n      } else {\n        throw new Error(\n          \"InkList origin could not be found in story when constructing new list: \" +\n            singleOriginListName\n        );\n      }\n    } else if (\n      typeof arguments[0] === \"object\" &&\n      arguments[0].hasOwnProperty(\"Key\") &&\n      arguments[0].hasOwnProperty(\"Value\")\n    ) {\n      let singleElement = arguments[0] as KeyValuePair<InkListItem, number>;\n      this.Add(singleElement.Key, singleElement.Value);\n    }\n  }\n\n  public static FromString(myListItem: string, originStory: Story) {\n    let listValue =\n      originStory.listDefinitions?.FindSingleItemListWithName(myListItem);\n    if (listValue) {\n      if (listValue.value === null) {\n        return throwNullException(\"listValue.value\");\n      }\n      return new InkList(listValue.value);\n    } else {\n      throw new Error(\n        \"Could not find the InkListItem from the string '\" +\n          myListItem +\n          \"' to create an InkList because it doesn't exist in the original list definition in ink.\"\n      );\n    }\n  }\n\n  public AddItem(itemOrItemName: InkListItem | string | null) {\n    if (itemOrItemName instanceof InkListItem) {\n      let item = itemOrItemName;\n\n      if (item.originName == null) {\n        this.AddItem(item.itemName);\n        return;\n      }\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (origin.name == item.originName) {\n          let intVal = origin.TryGetValueForItem(item, 0);\n          if (intVal.exists) {\n            this.Add(item, intVal.result);\n            return;\n          } else {\n            throw new Error(\n              \"Could not add the item \" +\n                item +\n                \" to this list because it doesn't exist in the original list definition in ink.\"\n            );\n          }\n        }\n      }\n\n      throw new Error(\n        \"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\"\n      );\n    } else {\n      let itemName = itemOrItemName as string | null;\n\n      let foundListDef: ListDefinition | null = null;\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (itemName === null) return throwNullException(\"itemName\");\n\n        if (origin.ContainsItemWithName(itemName)) {\n          if (foundListDef != null) {\n            throw new Error(\n              \"Could not add the item \" +\n                itemName +\n                \" to this list because it could come from either \" +\n                origin.name +\n                \" or \" +\n                foundListDef.name\n            );\n          } else {\n            foundListDef = origin;\n          }\n        }\n      }\n\n      if (foundListDef == null)\n        throw new Error(\n          \"Could not add the item \" +\n            itemName +\n            \" to this list because it isn't known to any list definitions previously associated with this list.\"\n        );\n\n      let item = new InkListItem(foundListDef.name, itemName);\n      let itemVal = foundListDef.ValueForItem(item);\n      this.Add(item, itemVal);\n    }\n  }\n  public ContainsItemNamed(itemName: string | null) {\n    for (let [key] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (item.itemName == itemName) return true;\n    }\n\n    return false;\n  }\n  public ContainsKey(key: InkListItem) {\n    return this.has(key.serialized());\n  }\n  public Add(key: InkListItem, value: number) {\n    let serializedKey = key.serialized();\n    if (this.has(serializedKey)) {\n      // Throw an exception to match the C# behavior.\n      throw new Error(`The Map already contains an entry for ${key}`);\n    }\n    this.set(serializedKey, value);\n  }\n  public Remove(key: InkListItem) {\n    return this.delete(key.serialized());\n  }\n  get Count() {\n    return this.size;\n  }\n  get originOfMaxItem(): ListDefinition | null {\n    if (this.origins == null) return null;\n\n    let maxOriginName = this.maxItem.Key.originName;\n    let result = null;\n    this.origins.every((origin) => {\n      if (origin.name == maxOriginName) {\n        result = origin;\n        return false;\n      } else return true;\n    });\n\n    return result;\n  }\n  get originNames(): string[] {\n    if (this.Count > 0) {\n      if (this._originNames == null && this.Count > 0) this._originNames = [];\n      else {\n        if (!this._originNames) this._originNames = [];\n        this._originNames.length = 0;\n      }\n\n      for (let [key] of this) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.originName === null)\n          return throwNullException(\"item.originName\");\n        this._originNames.push(item.originName);\n      }\n    }\n\n    return this._originNames as string[];\n  }\n  public SetInitialOriginName(initialOriginName: string) {\n    this._originNames = [initialOriginName];\n  }\n  public SetInitialOriginNames(initialOriginNames: string[]) {\n    if (initialOriginNames == null) this._originNames = null;\n    else this._originNames = initialOriginNames.slice(); // store a copy\n  }\n  get maxItem() {\n    let max: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (max.Key.isNull || value > max.Value)\n        max = { Key: item, Value: value };\n    }\n\n    return max;\n  }\n  get minItem() {\n    let min: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (min.Key.isNull || value < min.Value) {\n        min = { Key: item, Value: value };\n      }\n    }\n    return min;\n  }\n  get inverse() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          if (!this.ContainsKey(item)) list.Add(item, value);\n        }\n      }\n    }\n    return list;\n  }\n  get all() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          list.set(item.serialized(), value);\n        }\n      }\n    }\n    return list;\n  }\n  public Union(otherList: InkList) {\n    let union = new InkList(this);\n    for (let [key, value] of otherList) {\n      union.set(key, value);\n    }\n    return union;\n  }\n  public Intersect(otherList: InkList) {\n    let intersection = new InkList();\n    for (let [key, value] of this) {\n      if (otherList.has(key)) intersection.set(key, value);\n    }\n\n    return intersection;\n  }\n  public HasIntersection(otherList: InkList): boolean {\n    for (let [key] of this) {\n      if (otherList.has(key)) return true;\n    }\n    return false;\n  }\n  public Without(listToRemove: InkList) {\n    let result = new InkList(this);\n    for (let [key] of listToRemove) {\n      result.delete(key);\n    }\n\n    return result;\n  }\n\n  public Contains(key: string): boolean;\n  public Contains(otherList: InkList): boolean;\n  public Contains(what: string | InkList): boolean {\n    if (typeof what == \"string\") return this.ContainsItemNamed(what);\n    const otherList = what;\n    if (otherList.size == 0 || this.size == 0) return false;\n    for (let [key] of otherList) {\n      if (!this.has(key)) return false;\n    }\n\n    return true;\n  }\n  public GreaterThan(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return this.minItem.Value > otherList.maxItem.Value;\n  }\n  public GreaterThanOrEquals(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return (\n      this.minItem.Value >= otherList.minItem.Value &&\n      this.maxItem.Value >= otherList.maxItem.Value\n    );\n  }\n  public LessThan(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return this.maxItem.Value < otherList.minItem.Value;\n  }\n  public LessThanOrEquals(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return (\n      this.maxItem.Value <= otherList.maxItem.Value &&\n      this.minItem.Value <= otherList.minItem.Value\n    );\n  }\n  public MaxAsList() {\n    if (this.Count > 0) return new InkList(this.maxItem);\n    else return new InkList();\n  }\n  public MinAsList() {\n    if (this.Count > 0) return new InkList(this.minItem);\n    else return new InkList();\n  }\n  public ListWithSubRange(minBound: any, maxBound: any) {\n    if (this.Count == 0) return new InkList();\n\n    let ordered = this.orderedItems;\n\n    let minValue = 0;\n    let maxValue = Number.MAX_SAFE_INTEGER;\n\n    if (Number.isInteger(minBound)) {\n      minValue = minBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        minValue = minBound.minItem.Value;\n    }\n\n    if (Number.isInteger(maxBound)) {\n      maxValue = maxBound;\n    } else {\n      if (maxBound instanceof InkList && maxBound.Count > 0)\n        maxValue = maxBound.maxItem.Value;\n    }\n\n    let subList = new InkList();\n    subList.SetInitialOriginNames(this.originNames);\n    for (let item of ordered) {\n      if (item.Value >= minValue && item.Value <= maxValue) {\n        subList.Add(item.Key, item.Value);\n      }\n    }\n\n    return subList;\n  }\n  public Equals(otherInkList: InkList) {\n    if (otherInkList instanceof InkList === false) return false;\n    if (otherInkList.Count != this.Count) return false;\n\n    for (let [key] of this) {\n      if (!otherInkList.has(key)) return false;\n    }\n\n    return true;\n  }\n  // GetHashCode not implemented\n  get orderedItems() {\n    // List<KeyValuePair<InkListItem, int>>\n    let ordered = new Array<KeyValuePair<InkListItem, number>>();\n\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      ordered.push({ Key: item, Value: value });\n    }\n\n    ordered.sort((x, y) => {\n      if (x.Key.originName === null) {\n        return throwNullException(\"x.Key.originName\");\n      }\n      if (y.Key.originName === null) {\n        return throwNullException(\"y.Key.originName\");\n      }\n\n      if (x.Value == y.Value) {\n        return x.Key.originName.localeCompare(y.Key.originName);\n      } else {\n        // TODO: refactor this bit into a numberCompareTo method?\n        if (x.Value < y.Value) return -1;\n        return x.Value > y.Value ? 1 : 0;\n      }\n    });\n\n    return ordered;\n  }\n  public toString() {\n    let ordered = this.orderedItems;\n\n    let sb = new StringBuilder();\n    for (let i = 0; i < ordered.length; i++) {\n      if (i > 0) sb.Append(\", \");\n\n      let item = ordered[i].Key;\n      if (item.itemName === null) return throwNullException(\"item.itemName\");\n      sb.Append(item.itemName);\n    }\n\n    return sb.toString();\n  }\n  // casting a InkList to a Number, for somereason, actually gives a number.\n  // This messes up the type detection when creating a Value from a InkList.\n  // Returning NaN here prevents that.\n  public valueOf() {\n    return NaN;\n  }\n}\n\n/**\n * In the original C# code, `InkListItem` was defined as value type, meaning\n * that two `InkListItem` would be considered equal as long as they held the\n * same values. This doesn't hold true in Javascript, as `InkListItem` is a\n * reference type (Javascript doesn't allow the creation of custom value types).\n *\n * The key equality of Map objects is based on the \"SameValueZero\" algorithm;\n * since `InkListItem` is a value type, two keys will only be considered\n * equal if they are, in fact, the same object. As we are trying to emulate\n * the original behavior as close as possible, this will lead to unforeseen\n * side effects.\n *\n * In order to have a key equality based on value semantics, we'll convert\n * `InkListItem` to a valid string representation and use this representation\n * as a key (strings are value types in Javascript). Rather than using the\n * type `string` directly, we'll alias it to `SerializedInkListItem` and use\n * this type as the key for our Map-based `InkList`.\n *\n * Reducing `InkListItem` to a JSON representation would not be bulletproof\n * in the general case, but for our needs it works well. The major downside of\n * this method is that we will have to to reconstruct the original `InkListItem`\n * every time we'll need to access its properties.\n */\nexport type SerializedInkListItem = string;\n\n/**\n * An interface inherited by `InkListItem`, defining exposed\n * properties. It's mainly used when deserializing a `InkListItem` from its\n * key (`SerializedInkListItem`)\n */\ninterface IInkListItem {\n  readonly originName: string | null;\n  readonly itemName: string | null;\n}\nexport interface KeyValuePair<K, V> {\n  Key: K;\n  Value: V;\n}\n","export class StoryException extends Error {\n  public useEndLineNumber: boolean;\n  public message: string;\n  public name: string;\n\n  constructor(message: string) {\n    super(message);\n    this.useEndLineNumber = false;\n    this.message = message;\n    this.name = \"StoryException\";\n  }\n}\n","/**\n * This interface normalize the `TryGet` behavior found in the original\n * C# project. Any `TryGet` method will return a object conforming to this\n * interface.\n *\n * The original function returns a boolean and has a second parameter called\n * item that is an `out`. Both are needed and we can't just return the item\n * because it'll always be truthy. Instead, we return an object containing\n * whether the result exists (`exists`) and the result itself (`result`).\n *\n * For instance a `TryGet` prototype would look like this:\n```\nTryGetItemWithValue(val: number, item: InkListItem): TryGetResult<InkListItem>{\n```\n *\n * On the other hand, dealing with the result can be done in the following way:\n```\nvar item = item.TryGetItemWithValue(intVal, InkListItem.Null);\nif (item.exists) {\n\tconsole.log(item.result)\n}\n```\n *\n */\nexport interface TryGetResult<T> {\n  result: T;\n  exists: boolean;\n}\n\nexport function tryGetValueFromMap<K, V>(\n  map: Map<K, V> | null,\n  key: K,\n  /* out */ value: V\n): TryGetResult<V> {\n  if (map === null) {\n    return { result: value, exists: false };\n  }\n\n  let val = map.get(key);\n\n  if (typeof val === \"undefined\") {\n    return { result: value, exists: false };\n  } else {\n    return { result: val, exists: true };\n  }\n}\n\nexport function tryParseInt(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseInt(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n\nexport function tryParseFloat(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseFloat(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class SearchResult {\n  public obj: InkObject | null = null;\n  public approximate: boolean = false;\n\n  get correctObj() {\n    return this.approximate ? null : this.obj;\n  }\n\n  get container() {\n    return this.obj instanceof Container ? this.obj : null;\n  }\n\n  public copy() {\n    let searchResult = new SearchResult();\n    searchResult.obj = this.obj;\n    searchResult.approximate = this.approximate;\n\n    return searchResult;\n  }\n}\n","import { StringValue } from \"./Value\";\nimport { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { INamedContent } from \"./INamedContent\";\nimport { InkObject } from \"./Object\";\nimport { SearchResult } from \"./SearchResult\";\nimport { Path } from \"./Path\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { asINamedContentOrNull, asOrNull, asOrThrows } from \"./TypeAssertion\";\n\nexport class Container extends InkObject implements INamedContent {\n  public name: string | null = null;\n\n  public _content: InkObject[] = [];\n  public namedContent: Map<string, INamedContent> = new Map();\n\n  public visitsShouldBeCounted: boolean = false;\n  public turnIndexShouldBeCounted: boolean = false;\n  public countingAtStartOnly: boolean = false;\n\n  public _pathToFirstLeafContent: Path | null = null;\n\n  get hasValidName() {\n    return this.name != null && this.name.length > 0;\n  }\n  get content() {\n    return this._content;\n  }\n  set content(value: InkObject[]) {\n    this.AddContent(value);\n  }\n  get namedOnlyContent() {\n    let namedOnlyContentDict: Map<string, InkObject> | null = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      let inkObject = asOrThrows(value, InkObject);\n      namedOnlyContentDict.set(key, inkObject);\n    }\n\n    for (let c of this.content) {\n      let named = asINamedContentOrNull(c);\n      if (named != null && named.hasValidName) {\n        namedOnlyContentDict.delete(named.name!);\n      }\n    }\n\n    if (namedOnlyContentDict.size == 0) namedOnlyContentDict = null;\n\n    return namedOnlyContentDict;\n  }\n  set namedOnlyContent(value: Map<string, InkObject> | null) {\n    let existingNamedOnly = this.namedOnlyContent;\n    if (existingNamedOnly != null) {\n      for (let [key] of existingNamedOnly) {\n        this.namedContent.delete(key);\n      }\n    }\n\n    if (value == null) return;\n\n    for (let [, val] of value) {\n      let named = asINamedContentOrNull(val);\n      if (named != null) this.AddToNamedContentOnly(named);\n    }\n  }\n  get countFlags(): number {\n    let flags: Container.CountFlags = 0;\n    if (this.visitsShouldBeCounted) flags |= Container.CountFlags.Visits;\n    if (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;\n    if (this.countingAtStartOnly) flags |= Container.CountFlags.CountStartOnly;\n\n    if (flags == Container.CountFlags.CountStartOnly) {\n      flags = 0;\n    }\n\n    return flags;\n  }\n  set countFlags(value: number) {\n    let flag: Container.CountFlags = value;\n    if ((flag & Container.CountFlags.Visits) > 0)\n      this.visitsShouldBeCounted = true;\n    if ((flag & Container.CountFlags.Turns) > 0)\n      this.turnIndexShouldBeCounted = true;\n    if ((flag & Container.CountFlags.CountStartOnly) > 0)\n      this.countingAtStartOnly = true;\n  }\n  get pathToFirstLeafContent() {\n    if (this._pathToFirstLeafContent == null)\n      this._pathToFirstLeafContent = this.path.PathByAppendingPath(\n        this.internalPathToFirstLeafContent\n      );\n\n    return this._pathToFirstLeafContent;\n  }\n  get internalPathToFirstLeafContent() {\n    let components: Path.Component[] = [];\n    let container: Container = this;\n    while (container instanceof Container) {\n      if (container.content.length > 0) {\n        components.push(new Path.Component(0));\n        container = container.content[0] as Container;\n      }\n    }\n    return new Path(components);\n  }\n\n  public AddContent(contentObjOrList: InkObject | InkObject[]) {\n    if (contentObjOrList instanceof Array) {\n      let contentList = contentObjOrList as InkObject[];\n\n      for (let c of contentList) {\n        this.AddContent(c);\n      }\n    } else {\n      let contentObj = contentObjOrList as InkObject;\n\n      this._content.push(contentObj);\n\n      if (contentObj.parent) {\n        throw new Error(\"content is already in \" + contentObj.parent);\n      }\n\n      contentObj.parent = this;\n\n      this.TryAddNamedContent(contentObj);\n    }\n  }\n  public TryAddNamedContent(contentObj: InkObject) {\n    let namedContentObj = asINamedContentOrNull(contentObj);\n    if (namedContentObj != null && namedContentObj.hasValidName) {\n      this.AddToNamedContentOnly(namedContentObj);\n    }\n  }\n  public AddToNamedContentOnly(namedContentObj: INamedContent) {\n    Debug.AssertType(\n      namedContentObj,\n      InkObject,\n      \"Can only add Runtime.Objects to a Runtime.Container\"\n    );\n    let runtimeObj = asOrThrows(namedContentObj, InkObject);\n    runtimeObj.parent = this;\n\n    if (namedContentObj.name === null)\n      return throwNullException(\"namedContentObj.name\");\n    this.namedContent.set(namedContentObj.name!, namedContentObj);\n  }\n  public ContentAtPath(\n    path: Path,\n    partialPathStart: number = 0,\n    partialPathLength: number = -1\n  ) {\n    if (partialPathLength == -1) partialPathLength = path.length;\n\n    let result = new SearchResult();\n    result.approximate = false;\n\n    let currentContainer: Container | null = this;\n    let currentObj: InkObject = this;\n\n    for (let i = partialPathStart; i < partialPathLength; ++i) {\n      let comp = path.GetComponent(i);\n      if (currentContainer == null) {\n        result.approximate = true;\n        break;\n      }\n\n      let foundObj: InkObject | null =\n        currentContainer.ContentWithPathComponent(comp);\n\n      if (foundObj == null) {\n        result.approximate = true;\n        break;\n      }\n\n      currentObj = foundObj;\n      currentContainer = asOrNull(foundObj, Container);\n    }\n\n    result.obj = currentObj;\n\n    return result;\n  }\n  public InsertContent(contentObj: InkObject, index: number) {\n    this.content.splice(index, 0, contentObj);\n\n    if (contentObj.parent) {\n      throw new Error(\"content is already in \" + contentObj.parent);\n    }\n\n    contentObj.parent = this;\n\n    this.TryAddNamedContent(contentObj);\n  }\n  public AddContentsOfContainer(otherContainer: Container) {\n    this.content.push(...otherContainer.content);\n\n    for (let obj of otherContainer.content) {\n      obj.parent = this;\n      this.TryAddNamedContent(obj);\n    }\n  }\n  public ContentWithPathComponent(component: Path.Component): InkObject | null {\n    if (component.isIndex) {\n      if (component.index >= 0 && component.index < this.content.length) {\n        return this.content[component.index];\n      } else {\n        return null;\n      }\n    } else if (component.isParent) {\n      return this.parent;\n    } else {\n      if (component.name === null) {\n        return throwNullException(\"component.name\");\n      }\n      let foundContent = tryGetValueFromMap(\n        this.namedContent,\n        component.name,\n        null\n      );\n      if (foundContent.exists) {\n        return asOrThrows(foundContent.result, InkObject);\n      } else {\n        return null;\n      }\n    }\n  }\n  public BuildStringOfHierarchy(): string;\n  public BuildStringOfHierarchy(\n    sb: StringBuilder,\n    indentation: number,\n    pointedObj: InkObject | null\n  ): string;\n  public BuildStringOfHierarchy() {\n    let sb: StringBuilder;\n    if (arguments.length == 0) {\n      sb = new StringBuilder();\n      this.BuildStringOfHierarchy(sb, 0, null);\n      return sb.toString();\n    }\n\n    sb = arguments[0] as StringBuilder;\n    let indentation = arguments[1] as number;\n    let pointedObj = arguments[2] as InkObject | null;\n\n    function appendIndentation() {\n      const spacesPerIndent = 4; // Truly const in the original code\n      for (let i = 0; i < spacesPerIndent * indentation; ++i) {\n        sb.Append(\" \");\n      }\n    }\n\n    appendIndentation();\n    sb.Append(\"[\");\n\n    if (this.hasValidName) {\n      sb.AppendFormat(\" ({0})\", this.name);\n    }\n\n    if (this == pointedObj) {\n      sb.Append(\"  <---\");\n    }\n\n    sb.AppendLine();\n\n    indentation++;\n\n    for (let i = 0; i < this.content.length; ++i) {\n      let obj = this.content[i];\n\n      if (obj instanceof Container) {\n        let container = obj as Container;\n\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n      } else {\n        appendIndentation();\n        if (obj instanceof StringValue) {\n          sb.Append('\"');\n          sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));\n          sb.Append('\"');\n        } else {\n          sb.Append(obj.toString());\n        }\n      }\n\n      if (i != this.content.length - 1) {\n        sb.Append(\",\");\n      }\n\n      if (!(obj instanceof Container) && obj == pointedObj) {\n        sb.Append(\"  <---\");\n      }\n\n      sb.AppendLine();\n    }\n\n    let onlyNamed: Map<string, INamedContent> = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      if (this.content.indexOf(asOrThrows(value, InkObject)) >= 0) {\n        continue;\n      } else {\n        onlyNamed.set(key, value);\n      }\n    }\n\n    if (onlyNamed.size > 0) {\n      appendIndentation();\n      sb.AppendLine(\"-- named: --\");\n\n      for (let [, value] of onlyNamed) {\n        Debug.AssertType(\n          value,\n          Container,\n          \"Can only print out named Containers\"\n        );\n        let container = value as Container;\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n        sb.AppendLine();\n      }\n    }\n\n    indentation--;\n\n    appendIndentation();\n    sb.Append(\"]\");\n  }\n}\n\nexport namespace Container {\n  export enum CountFlags {\n    Visits = 1,\n    Turns = 2,\n    CountStartOnly = 4,\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class ControlCommand extends InkObject {\n  private _commandType: ControlCommand.CommandType;\n\n  get commandType(): ControlCommand.CommandType {\n    return this._commandType;\n  }\n\n  constructor(\n    commandType: ControlCommand.CommandType = ControlCommand.CommandType.NotSet\n  ) {\n    super();\n    this._commandType = commandType;\n  }\n\n  public Copy() {\n    return new ControlCommand(this.commandType);\n  }\n  public static EvalStart() {\n    return new ControlCommand(ControlCommand.CommandType.EvalStart);\n  }\n  public static EvalOutput() {\n    return new ControlCommand(ControlCommand.CommandType.EvalOutput);\n  }\n  public static EvalEnd() {\n    return new ControlCommand(ControlCommand.CommandType.EvalEnd);\n  }\n  public static Duplicate() {\n    return new ControlCommand(ControlCommand.CommandType.Duplicate);\n  }\n  public static PopEvaluatedValue() {\n    return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n  }\n  public static PopFunction() {\n    return new ControlCommand(ControlCommand.CommandType.PopFunction);\n  }\n  public static PopTunnel() {\n    return new ControlCommand(ControlCommand.CommandType.PopTunnel);\n  }\n  public static BeginString() {\n    return new ControlCommand(ControlCommand.CommandType.BeginString);\n  }\n  public static EndString() {\n    return new ControlCommand(ControlCommand.CommandType.EndString);\n  }\n  public static NoOp() {\n    return new ControlCommand(ControlCommand.CommandType.NoOp);\n  }\n  public static ChoiceCount() {\n    return new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n  }\n  public static Turns() {\n    return new ControlCommand(ControlCommand.CommandType.Turns);\n  }\n  public static TurnsSince() {\n    return new ControlCommand(ControlCommand.CommandType.TurnsSince);\n  }\n  public static ReadCount() {\n    return new ControlCommand(ControlCommand.CommandType.ReadCount);\n  }\n  public static Random() {\n    return new ControlCommand(ControlCommand.CommandType.Random);\n  }\n  public static SeedRandom() {\n    return new ControlCommand(ControlCommand.CommandType.SeedRandom);\n  }\n  public static VisitIndex() {\n    return new ControlCommand(ControlCommand.CommandType.VisitIndex);\n  }\n  public static SequenceShuffleIndex() {\n    return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n  }\n  public static StartThread() {\n    return new ControlCommand(ControlCommand.CommandType.StartThread);\n  }\n  public static Done() {\n    return new ControlCommand(ControlCommand.CommandType.Done);\n  }\n  public static End() {\n    return new ControlCommand(ControlCommand.CommandType.End);\n  }\n  public static ListFromInt() {\n    return new ControlCommand(ControlCommand.CommandType.ListFromInt);\n  }\n  public static ListRange() {\n    return new ControlCommand(ControlCommand.CommandType.ListRange);\n  }\n  public static ListRandom() {\n    return new ControlCommand(ControlCommand.CommandType.ListRandom);\n  }\n  public static BeginTag() {\n    return new ControlCommand(ControlCommand.CommandType.BeginTag);\n  }\n  public static EndTag() {\n    return new ControlCommand(ControlCommand.CommandType.EndTag);\n  }\n  public toString() {\n    return this.commandType.toString();\n  }\n}\n\nexport namespace ControlCommand {\n  export enum CommandType {\n    NotSet = -1,\n    EvalStart, // 0\n    EvalOutput, // 1\n    EvalEnd, // 2\n    Duplicate, // 3\n    PopEvaluatedValue, // 4\n    PopFunction, // 5\n    PopTunnel, // 6\n    BeginString, // 7\n    EndString, // 8\n    NoOp, // 9\n    ChoiceCount, // 10\n    Turns, // 11\n    TurnsSince, // 12\n    ReadCount, // 13\n    Random, // 14\n    SeedRandom, // 15\n    VisitIndex, // 16\n    SequenceShuffleIndex, // 17\n    StartThread, // 18\n    Done, // 19\n    End, // 20\n    ListFromInt, // 21\n    ListRange, // 22\n    ListRandom, // 23\n    BeginTag, // 24\n    EndTag, // 25\n\n    TOTAL_VALUES,\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\n\nexport abstract class Expression extends ParsedObject {\n  public abstract GenerateIntoContainer: (container: RuntimeContainer) => void;\n\n  private _prototypeRuntimeConstantExpression: RuntimeContainer | null = null;\n  public outputWhenComplete: boolean = false;\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    // Tell Runtime to start evaluating the following content as an expression\n    container.AddContent(RuntimeControlCommand.EvalStart());\n\n    this.GenerateIntoContainer(container);\n\n    // Tell Runtime to output the result of the expression evaluation to the output stream\n    if (this.outputWhenComplete) {\n      container.AddContent(RuntimeControlCommand.EvalOutput());\n    }\n\n    // Tell Runtime to stop evaluating the content as an expression\n    container.AddContent(RuntimeControlCommand.EvalEnd());\n\n    return container;\n  };\n\n  // When generating the value of a constant expression,\n  // we can't just keep generating the same constant expression into\n  // different places where the constant value is referenced, since then\n  // the same runtime objects would be used in multiple places, which\n  // is impossible since each runtime object should have one parent.\n  // Instead, we generate a prototype of the runtime object(s), then\n  // copy them each time they're used.\n  public readonly GenerateConstantIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    if (this._prototypeRuntimeConstantExpression === null) {\n      this._prototypeRuntimeConstantExpression = new RuntimeContainer();\n      this.GenerateIntoContainer(this._prototypeRuntimeConstantExpression);\n    }\n\n    for (const runtimeObj of this._prototypeRuntimeConstantExpression.content) {\n      const copy = runtimeObj.Copy();\n      if (copy) {\n        container.AddContent(copy);\n      }\n    }\n  };\n\n  get typeName(): string {\n    return \"Expression\";\n  }\n\n  public Equals(obj: ParsedObject): boolean {\n    return false;\n  }\n\n  public readonly toString = () => \"No string value in JavaScript.\";\n}\n","import { InkObject } from \"./Object\";\n\nexport class Void extends InkObject {}\n","import { Value, ValueType, IntValue, ListValue, BoolValue } from \"./Value\";\nimport { StoryException } from \"./StoryException\";\nimport { Void } from \"./Void\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull, asOrThrows, asBooleanOrThrows } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\n\ntype BinaryOp<T> = (left: T, right: T) => any;\ntype UnaryOp<T> = (val: T) => any;\n\nexport class NativeFunctionCall extends InkObject {\n  public static readonly Add: string = \"+\";\n  public static readonly Subtract: string = \"-\";\n  public static readonly Divide: string = \"/\";\n  public static readonly Multiply: string = \"*\";\n  public static readonly Mod: string = \"%\";\n  public static readonly Negate: string = \"_\";\n  public static readonly Equal: string = \"==\";\n  public static readonly Greater: string = \">\";\n  public static readonly Less: string = \"<\";\n  public static readonly GreaterThanOrEquals: string = \">=\";\n  public static readonly LessThanOrEquals: string = \"<=\";\n  public static readonly NotEquals: string = \"!=\";\n  public static readonly Not: string = \"!\";\n  public static readonly And: string = \"&&\";\n  public static readonly Or: string = \"||\";\n  public static readonly Min: string = \"MIN\";\n  public static readonly Max: string = \"MAX\";\n  public static readonly Pow: string = \"POW\";\n  public static readonly Floor: string = \"FLOOR\";\n  public static readonly Ceiling: string = \"CEILING\";\n  public static readonly Int: string = \"INT\";\n  public static readonly Float: string = \"FLOAT\";\n  public static readonly Has: string = \"?\";\n  public static readonly Hasnt: string = \"!?\";\n  public static readonly Intersect: string = \"^\";\n  public static readonly ListMin: string = \"LIST_MIN\";\n  public static readonly ListMax: string = \"LIST_MAX\";\n  public static readonly All: string = \"LIST_ALL\";\n  public static readonly Count: string = \"LIST_COUNT\";\n  public static readonly ValueOfList: string = \"LIST_VALUE\";\n  public static readonly Invert: string = \"LIST_INVERT\";\n\n  public static CallWithName(functionName: string) {\n    return new NativeFunctionCall(functionName);\n  }\n\n  public static CallExistsWithName(functionName: string) {\n    this.GenerateNativeFunctionsIfNecessary();\n    return this._nativeFunctions!.get(functionName);\n  }\n\n  get name() {\n    if (this._name === null)\n      return throwNullException(\"NativeFunctionCall._name\");\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    if (!this._isPrototype) {\n      if (NativeFunctionCall._nativeFunctions === null)\n        throwNullException(\"NativeFunctionCall._nativeFunctions\");\n      else\n        this._prototype =\n          NativeFunctionCall._nativeFunctions.get(this._name) || null;\n    }\n  }\n  public _name: string | null = null;\n\n  get numberOfParameters() {\n    if (this._prototype) {\n      return this._prototype.numberOfParameters;\n    } else {\n      return this._numberOfParameters;\n    }\n  }\n  set numberOfParameters(value: number) {\n    this._numberOfParameters = value;\n  }\n  public _numberOfParameters: number = 0;\n\n  public Call(parameters: InkObject[]): InkObject | null {\n    if (this._prototype) {\n      return this._prototype.Call(parameters);\n    }\n\n    if (this.numberOfParameters != parameters.length) {\n      throw new Error(\"Unexpected number of parameters\");\n    }\n\n    let hasList = false;\n    for (let p of parameters) {\n      if (p instanceof Void)\n        throw new StoryException(\n          'Attempting to perform operation on a void value. Did you forget to \"return\" a value from a function you called here?'\n        );\n      if (p instanceof ListValue) hasList = true;\n    }\n\n    if (parameters.length == 2 && hasList) {\n      return this.CallBinaryListOperation(parameters);\n    }\n\n    let coercedParams = this.CoerceValuesToSingleType(parameters);\n    let coercedType = coercedParams[0].valueType;\n\n    if (coercedType == ValueType.Int) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.Float) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.String) {\n      return this.CallType<string>(coercedParams);\n    } else if (coercedType == ValueType.DivertTarget) {\n      return this.CallType<Path>(coercedParams);\n    } else if (coercedType == ValueType.List) {\n      return this.CallType<InkList>(coercedParams);\n    }\n\n    return null;\n  }\n\n  public CallType<T extends { toString: () => string }>(\n    parametersOfSingleType: Array<Value<T>>\n  ) {\n    let param1 = asOrThrows(parametersOfSingleType[0], Value);\n    let valType = param1.valueType;\n\n    let val1 = param1 as Value<T>;\n\n    let paramCount = parametersOfSingleType.length;\n\n    if (paramCount == 2 || paramCount == 1) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let opForTypeObj = this._operationFuncs.get(valType);\n      if (!opForTypeObj) {\n        const key = ValueType[valType];\n        throw new StoryException(\n          \"Cannot perform operation \" + this.name + \" on \" + key\n        );\n      }\n\n      if (paramCount == 2) {\n        let param2 = asOrThrows(parametersOfSingleType[1], Value);\n\n        let val2 = param2 as Value<T>;\n\n        let opForType = opForTypeObj as BinaryOp<T>;\n\n        if (val1.value === null || val2.value === null)\n          return throwNullException(\"NativeFunctionCall.Call BinaryOp values\");\n        let resultVal = opForType(val1.value, val2.value);\n\n        return Value.Create(resultVal);\n      } else {\n        let opForType = opForTypeObj as UnaryOp<T>;\n\n        if (val1.value === null)\n          return throwNullException(\"NativeFunctionCall.Call UnaryOp value\");\n        let resultVal = opForType(val1.value);\n\n        // This code is different from upstream. Since JavaScript treats\n        // integers and floats as the same numbers, it's impossible\n        // to force an number to be either an integer or a float.\n        //\n        // It can be useful to force a specific number type\n        // (especially for divisions), so the result of INT() & FLOAT()\n        // is coerced to the the proper value type.\n        //\n        // Note that we also force all other unary operation to\n        // return the same value type, although this is only\n        // meaningful for numbers. See `Value.Create`.\n        if (this.name === NativeFunctionCall.Int) {\n          return Value.Create(resultVal, ValueType.Int);\n        } else if (this.name === NativeFunctionCall.Float) {\n          return Value.Create(resultVal, ValueType.Float);\n        } else {\n          return Value.Create(resultVal, param1.valueType);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Unexpected number of parameters to NativeFunctionCall: \" +\n          parametersOfSingleType.length\n      );\n    }\n  }\n\n  public CallBinaryListOperation(parameters: InkObject[]) {\n    if (\n      (this.name == \"+\" || this.name == \"-\") &&\n      parameters[0] instanceof ListValue &&\n      parameters[1] instanceof IntValue\n    )\n      return this.CallListIncrementOperation(parameters);\n\n    let v1 = asOrThrows(parameters[0], Value);\n    let v2 = asOrThrows(parameters[1], Value);\n\n    if (\n      (this.name == \"&&\" || this.name == \"||\") &&\n      (v1.valueType != ValueType.List || v2.valueType != ValueType.List)\n    ) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let op = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n      if (op === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallBinaryListOperation op\"\n        );\n      let result = asBooleanOrThrows(\n        op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0)\n      );\n      return new BoolValue(result);\n    }\n\n    if (v1.valueType == ValueType.List && v2.valueType == ValueType.List)\n      return this.CallType<InkList>([v1, v2]);\n\n    throw new StoryException(\n      \"Can not call use \" +\n        this.name +\n        \" operation on \" +\n        ValueType[v1.valueType] +\n        \" and \" +\n        ValueType[v2.valueType]\n    );\n  }\n\n  public CallListIncrementOperation(listIntParams: InkObject[]) {\n    let listVal = asOrThrows(listIntParams[0], ListValue);\n    let intVal = asOrThrows(listIntParams[1], IntValue);\n\n    let resultInkList = new InkList();\n\n    if (listVal.value === null)\n      return throwNullException(\n        \"NativeFunctionCall.CallListIncrementOperation listVal.value\"\n      );\n    for (let [listItemKey, listItemValue] of listVal.value) {\n      let listItem = InkListItem.fromSerializedKey(listItemKey);\n\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let intOp = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n\n      if (intVal.value === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation intVal.value\"\n        );\n      let targetInt = intOp(listItemValue, intVal.value);\n\n      let itemOrigin = null;\n      if (listVal.value.origins === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\"\n        );\n      for (let origin of listVal.value.origins) {\n        if (origin.name == listItem.originName) {\n          itemOrigin = origin;\n          break;\n        }\n      }\n      if (itemOrigin != null) {\n        let incrementedItem = itemOrigin.TryGetItemWithValue(\n          targetInt,\n          InkListItem.Null\n        );\n        if (incrementedItem.exists)\n          resultInkList.Add(incrementedItem.result, targetInt);\n      }\n    }\n\n    return new ListValue(resultInkList);\n  }\n\n  public CoerceValuesToSingleType(parametersIn: InkObject[]) {\n    let valType = ValueType.Int;\n\n    let specialCaseList: null | ListValue = null;\n\n    for (let obj of parametersIn) {\n      let val = asOrThrows(obj, Value);\n      if (val.valueType > valType) {\n        valType = val.valueType;\n      }\n\n      if (val.valueType == ValueType.List) {\n        specialCaseList = asOrNull(val, ListValue);\n      }\n    }\n\n    let parametersOut = [];\n\n    if (ValueType[valType] == ValueType[ValueType.List]) {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        if (val.valueType == ValueType.List) {\n          parametersOut.push(val);\n        } else if (val.valueType == ValueType.Int) {\n          let intVal = parseInt(val.valueObject);\n\n          specialCaseList = asOrThrows(specialCaseList, ListValue);\n          if (specialCaseList.value === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\"\n            );\n          let list = specialCaseList.value.originOfMaxItem;\n\n          if (list === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType list\"\n            );\n          let item = list.TryGetItemWithValue(intVal, InkListItem.Null);\n          if (item.exists) {\n            let castedValue = new ListValue(item.result, intVal);\n            parametersOut.push(castedValue);\n          } else\n            throw new StoryException(\n              \"Could not find List item with the value \" +\n                intVal +\n                \" in \" +\n                list.name\n            );\n        } else {\n          const key = ValueType[val.valueType];\n          throw new StoryException(\n            \"Cannot mix Lists and \" + key + \" values in this operation\"\n          );\n        }\n      }\n    } else {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        let castedValue = val.Cast(valType);\n        parametersOut.push(castedValue);\n      }\n    }\n\n    return parametersOut;\n  }\n\n  constructor(name: string);\n  constructor(name: string, numberOfParameters: number);\n  constructor();\n  constructor() {\n    super();\n\n    if (arguments.length === 0) {\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n    } else if (arguments.length === 1) {\n      let name = arguments[0];\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n      this.name = name;\n    } else if (arguments.length === 2) {\n      let name = arguments[0];\n      let numberOfParameters = arguments[1];\n\n      this._isPrototype = true;\n      this.name = name;\n      this.numberOfParameters = numberOfParameters;\n    }\n  }\n\n  public static Identity<T>(t: T): any {\n    return t;\n  }\n\n  public static GenerateNativeFunctionsIfNecessary() {\n    if (this._nativeFunctions == null) {\n      this._nativeFunctions = new Map();\n\n      // Int operations\n      this.AddIntBinaryOp(this.Add, (x, y) => x + y);\n      this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));\n      this.AddIntBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddIntUnaryOp(this.Negate, (x) => -x);\n\n      this.AddIntBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddIntBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddIntBinaryOp(this.Less, (x, y) => x < y);\n      this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddIntBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddIntUnaryOp(this.Not, (x) => x == 0);\n\n      this.AddIntBinaryOp(this.And, (x, y) => x != 0 && y != 0);\n      this.AddIntBinaryOp(this.Or, (x, y) => x != 0 || y != 0);\n\n      this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Float, (x) => x);\n\n      // Float operations\n      this.AddFloatBinaryOp(this.Add, (x, y) => x + y);\n      this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);\n      this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddFloatUnaryOp(this.Negate, (x) => -x);\n\n      this.AddFloatBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddFloatBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddFloatBinaryOp(this.Less, (x, y) => x < y);\n      this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddFloatUnaryOp(this.Not, (x) => x == 0.0);\n\n      this.AddFloatBinaryOp(this.And, (x, y) => x != 0.0 && y != 0.0);\n      this.AddFloatBinaryOp(this.Or, (x, y) => x != 0.0 || y != 0.0);\n\n      this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));\n      this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);\n\n      // String operations\n      this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat\n      this.AddStringBinaryOp(this.Equal, (x, y) => x === y);\n      this.AddStringBinaryOp(this.NotEquals, (x, y) => !(x === y));\n      this.AddStringBinaryOp(this.Has, (x, y) => x.includes(y));\n      this.AddStringBinaryOp(this.Hasnt, (x, y) => !x.includes(y));\n\n      this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));\n      this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));\n      this.AddListBinaryOp(this.Has, (x, y) => x.Contains(y));\n      this.AddListBinaryOp(this.Hasnt, (x, y) => !x.Contains(y));\n      this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n\n      this.AddListBinaryOp(this.Equal, (x, y) => x.Equals(y));\n      this.AddListBinaryOp(this.Greater, (x, y) => x.GreaterThan(y));\n      this.AddListBinaryOp(this.Less, (x, y) => x.LessThan(y));\n      this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) =>\n        x.GreaterThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.LessThanOrEquals, (x, y) =>\n        x.LessThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.NotEquals, (x, y) => !x.Equals(y));\n\n      this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0);\n      this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0);\n\n      this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));\n\n      this.AddListUnaryOp(this.Invert, (x) => x.inverse);\n      this.AddListUnaryOp(this.All, (x) => x.all);\n      this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());\n      this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());\n      this.AddListUnaryOp(this.Count, (x) => x.Count);\n      this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);\n\n      let divertTargetsEqual = (d1: Path, d2: Path) => d1.Equals(d2);\n      let divertTargetsNotEqual = (d1: Path, d2: Path) => !d1.Equals(d2);\n      this.AddOpToNativeFunc(\n        this.Equal,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsEqual\n      );\n      this.AddOpToNativeFunc(\n        this.NotEquals,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsNotEqual\n      );\n    }\n  }\n\n  public AddOpFuncForType(\n    valType: ValueType,\n    op: UnaryOp<number | InkList> | BinaryOp<number | string | InkList | Path>\n  ): void {\n    if (this._operationFuncs == null) {\n      this._operationFuncs = new Map();\n    }\n\n    this._operationFuncs.set(valType, op);\n  }\n\n  public static AddOpToNativeFunc(\n    name: string,\n    args: number,\n    valType: ValueType,\n    op: UnaryOp<any> | BinaryOp<any>\n  ): void {\n    if (this._nativeFunctions === null)\n      return throwNullException(\"NativeFunctionCall._nativeFunctions\");\n    let nativeFunc = this._nativeFunctions.get(name);\n    if (!nativeFunc) {\n      nativeFunc = new NativeFunctionCall(name, args);\n      this._nativeFunctions.set(name, nativeFunc);\n    }\n\n    nativeFunc.AddOpFuncForType(valType, op);\n  }\n\n  public static AddIntBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Int, op);\n  }\n  public static AddIntUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Int, op);\n  }\n\n  public static AddFloatBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Float, op);\n  }\n  public static AddFloatUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Float, op);\n  }\n\n  public static AddStringBinaryOp(name: string, op: BinaryOp<string>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.String, op);\n  }\n\n  public static AddListBinaryOp(name: string, op: BinaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.List, op);\n  }\n  public static AddListUnaryOp(name: string, op: UnaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.List, op);\n  }\n\n  public toString() {\n    return 'Native \"' + this.name + '\"';\n  }\n\n  public _prototype: NativeFunctionCall | null = null;\n  public _isPrototype: boolean = false;\n  public _operationFuncs: Map<ValueType, BinaryOp<any> | UnaryOp<any>> | null =\n    null;\n  public static _nativeFunctions: Map<string, NativeFunctionCall> | null = null;\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { BoolValue, FloatValue, IntValue } from \"../../../../engine/Value\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\nimport { ParsedObject } from \"../Object\";\n\n// This class is named Number in the C# codebase\n// but this conflict with the built-in Number class\nexport class NumberExpression extends Expression {\n  public value: number | boolean;\n  public subtype: \"int\" | \"float\" | \"bool\";\n\n  constructor(value: number | boolean, subtype: \"int\" | \"float\" | \"bool\") {\n    super();\n\n    if (\n      (typeof value === \"number\" && !Number.isNaN(value)) ||\n      typeof value == \"boolean\"\n    ) {\n      this.value = value;\n      this.subtype = subtype;\n    } else {\n      throw new Error(\"Unexpected object type in NumberExpression.\");\n    }\n  }\n\n  get typeName(): string {\n    return \"Number\";\n  }\n\n  public isInt = (): boolean => this.subtype == \"int\";\n\n  public isFloat = (): boolean => this.subtype == \"float\";\n\n  public isBool = (): boolean => this.subtype == \"bool\";\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    if (this.isInt()) {\n      container.AddContent(new IntValue(this.value as number));\n    } else if (this.isFloat()) {\n      container.AddContent(new FloatValue(this.value as number));\n    } else if (this.isBool()) {\n      container.AddContent(new BoolValue(this.value as boolean));\n    }\n  };\n\n  public readonly toString = (): string => String(this.value);\n\n  public Equals(obj: ParsedObject): boolean {\n    const numberExpression = asOrNull(obj, NumberExpression);\n    if (!numberExpression) return false;\n\n    return (\n      numberExpression.subtype == this.subtype &&\n      numberExpression.value == this.value\n    );\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { NumberExpression } from \"./NumberExpression\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class UnaryExpression extends Expression {\n  get nativeNameForOp(): string {\n    // Replace \"-\" with \"_\" to make it unique (compared to subtraction)\n    if (this.op === \"-\") {\n      return \"_\";\n    } else if (this.op === \"not\") {\n      return \"!\";\n    }\n\n    return this.op;\n  }\n\n  public innerExpression: Expression;\n\n  // Attempt to flatten inner expression immediately\n  // e.g. convert (-(5)) into (-5)\n  public static readonly WithInner = (\n    inner: Expression,\n    op: string\n  ): Expression => {\n    const innerNumber = asOrNull(inner, NumberExpression);\n\n    if (innerNumber) {\n      if (op === \"-\") {\n        if (innerNumber.isInt()) {\n          return new NumberExpression(-innerNumber.value, \"int\");\n        } else if (innerNumber.isFloat()) {\n          return new NumberExpression(-innerNumber.value, \"float\");\n        }\n      } else if (op == \"!\" || op == \"not\") {\n        if (innerNumber.isInt()) {\n          return new NumberExpression(innerNumber.value == 0, \"bool\");\n        } else if (innerNumber.isFloat()) {\n          return new NumberExpression(innerNumber.value == 0.0, \"bool\");\n        } else if (innerNumber.isBool()) {\n          return new NumberExpression(!innerNumber.value, \"bool\");\n        }\n      }\n\n      throw new Error(\"Unexpected operation or number type\");\n    }\n\n    // Normal fallback\n    const unary = new UnaryExpression(inner, op);\n\n    return unary;\n  };\n\n  constructor(inner: Expression, public readonly op: string) {\n    super();\n\n    this.innerExpression = this.AddContent(inner) as Expression;\n  }\n\n  get typeName(): string {\n    return \"UnaryExpression\";\n  }\n\n  public readonly GenerateIntoContainer = (container: RuntimeContainer) => {\n    this.innerExpression.GenerateIntoContainer(container);\n    container.AddContent(NativeFunctionCall.CallWithName(this.nativeNameForOp));\n  };\n\n  public readonly toString = (): string =>\n    this.nativeNameForOp + this.innerExpression;\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { Story } from \"../Story\";\nimport { UnaryExpression } from \"./UnaryExpression\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class BinaryExpression extends Expression {\n  public readonly leftExpression: Expression;\n  public readonly rightExpression: Expression;\n\n  constructor(left: Expression, right: Expression, public opName: string) {\n    super();\n\n    this.leftExpression = this.AddContent(left) as Expression;\n    this.rightExpression = this.AddContent(right) as Expression;\n\n    this.opName = opName;\n  }\n\n  get typeName(): string {\n    return \"BinaryExpression\";\n  }\n\n  public readonly GenerateIntoContainer = (container: RuntimeContainer) => {\n    this.leftExpression.GenerateIntoContainer(container);\n    this.rightExpression.GenerateIntoContainer(container);\n    this.opName = this.NativeNameForOp(this.opName);\n    container.AddContent(NativeFunctionCall.CallWithName(this.opName));\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // Check for the following case:\n    //\n    //    (not A) ? B\n    //\n    // Since this easy to accidentally do:\n    //\n    //    not A ? B\n    //\n    // when you intend:\n    //\n    //    not (A ? B)\n    if (this.NativeNameForOp(this.opName) === \"?\") {\n      const leftUnary = asOrNull(this.leftExpression, UnaryExpression);\n      if (\n        leftUnary !== null &&\n        (leftUnary.op === \"not\" || leftUnary.op === \"!\")\n      ) {\n        this.Error(\n          `Using 'not' or '!' here negates '${leftUnary.innerExpression}' rather than the result of the '?' or 'has' operator. You need to add parentheses around the (A ? B) expression.`\n        );\n      }\n    }\n  }\n\n  public readonly NativeNameForOp = (opName: string): string => {\n    if (opName === \"and\") {\n      return \"&&\";\n    } else if (opName === \"or\") {\n      return \"||\";\n    } else if (opName === \"mod\") {\n      return \"%\";\n    } else if (opName === \"has\") {\n      return \"?\";\n    } else if (opName === \"hasnt\") {\n      return \"!?\";\n    }\n\n    return opName;\n  };\n\n  public readonly toString = (): string =>\n    `(${this.leftExpression} ${this.opName} ${this.rightExpression})`;\n}\n","export class CharacterSet {\n  public static readonly FromRange = (\n    start: string,\n    end: string\n  ): CharacterSet => new CharacterSet().AddRange(start, end);\n\n  public set: Set<string> = new Set<string>();\n\n  constructor(arg?: string | string[] | CharacterSet) {\n    if (arg) {\n      this.AddCharacters(arg);\n    }\n  }\n\n  public readonly Add = (arg: string) => this.set.add(arg);\n\n  public readonly AddRange = (start: string, end: string): CharacterSet => {\n    for (let c = start.charCodeAt(0); c <= end.charCodeAt(0); ++c) {\n      this.Add(String.fromCharCode(c));\n    }\n\n    return this;\n  };\n\n  public readonly AddCharacters = (\n    chars: string | string[] | CharacterSet\n  ): CharacterSet => {\n    if (typeof chars === \"string\" || Array.isArray(chars)) {\n      for (const c of chars) {\n        this.Add(c);\n      }\n    } else {\n      for (const c of chars.set) {\n        this.Add(c);\n      }\n    }\n\n    return this;\n  };\n}\n","import { CharacterSet } from \"./CharacterSet\";\n\n/// <summary>\n/// A class representing a character range. Allows for lazy-loading a corresponding <see cref=\"CharacterSet\">character set</see>.\n/// </summary>\nexport class CharacterRange {\n  public static Define = (\n    start: string,\n    end: string,\n    excludes: string[] | CharacterSet = []\n  ): CharacterRange => new CharacterRange(start, end, excludes);\n\n  private _correspondingCharSet: CharacterSet = new CharacterSet();\n  private _excludes = new Set<string>();\n\n  constructor(\n    private _start: string,\n    private _end: string,\n    excludes: string[] | CharacterSet = []\n  ) {\n    if (excludes instanceof CharacterSet) {\n      this._excludes = excludes.set;\n    } else {\n      for (const item of excludes) {\n        this._excludes.add(item);\n      }\n    }\n  }\n\n  get start(): string {\n    return this._start;\n  }\n\n  get end(): string {\n    return this._end;\n  }\n\n  /// <summary>\n  /// Returns a <see cref=\"CharacterSet\">character set</see> instance corresponding to the character range\n  /// represented by the current instance.\n  /// </summary>\n  /// <remarks>\n  /// The internal character set is created once and cached in memory.\n  /// </remarks>\n  /// <returns>The char set.</returns>\n  public readonly ToCharacterSet = (): CharacterSet => {\n    if (this._correspondingCharSet.set.size === 0) {\n      for (\n        let ii = this.start.charCodeAt(0), c;\n        ii <= this.end.charCodeAt(0);\n        ii += 1\n      ) {\n        c = String.fromCharCode(ii);\n        if (!this._excludes.has(c)) {\n          this._correspondingCharSet.AddCharacters(c);\n        }\n      }\n    }\n\n    return this._correspondingCharSet;\n  };\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ChoicePoint extends InkObject {\n  public _pathOnChoice: Path | null = null;\n  public hasCondition: boolean = false;\n  public hasStartContent: boolean = false;\n  public hasChoiceOnlyContent: boolean = false;\n  public isInvisibleDefault: boolean = false;\n  public onceOnly: boolean = true;\n\n  constructor(onceOnly: boolean = true) {\n    super();\n    this.onceOnly = onceOnly;\n  }\n  get pathOnChoice(): Path | null {\n    if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n      let choiceTargetObj = this.choiceTarget;\n      if (choiceTargetObj) {\n        this._pathOnChoice = choiceTargetObj.path;\n      }\n    }\n    return this._pathOnChoice;\n  }\n  set pathOnChoice(value: Path | null) {\n    this._pathOnChoice = value;\n  }\n  get choiceTarget(): Container | null {\n    if (this._pathOnChoice === null)\n      return throwNullException(\"ChoicePoint._pathOnChoice\");\n    return this.ResolvePath(this._pathOnChoice).container;\n  }\n  get pathStringOnChoice(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    return this.CompactPathString(this.pathOnChoice);\n  }\n  set pathStringOnChoice(value: string) {\n    this.pathOnChoice = new Path(value);\n  }\n  get flags(): number {\n    let flags = 0;\n    if (this.hasCondition) flags |= 1;\n    if (this.hasStartContent) flags |= 2;\n    if (this.hasChoiceOnlyContent) flags |= 4;\n    if (this.isInvisibleDefault) flags |= 8;\n    if (this.onceOnly) flags |= 16;\n    return flags;\n  }\n  set flags(value: number) {\n    this.hasCondition = (value & 1) > 0;\n    this.hasStartContent = (value & 2) > 0;\n    this.hasChoiceOnlyContent = (value & 4) > 0;\n    this.isInvisibleDefault = (value & 8) > 0;\n    this.onceOnly = (value & 16) > 0;\n  }\n  public toString(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);\n    let targetLineNum = null;\n    let targetString = this.pathOnChoice.toString();\n\n    if (targetLineNum != null) {\n      targetString = \" line \" + targetLineNum + \"(\" + targetString + \")\";\n    }\n\n    return \"Choice: -> \" + targetString;\n  }\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\n\nexport class Pointer {\n  public container: Container | null = null;\n  public index: number = -1;\n\n  constructor();\n  constructor(container: Container | null, index: number);\n  constructor() {\n    if (arguments.length === 2) {\n      this.container = arguments[0];\n      this.index = arguments[1];\n    }\n  }\n\n  public Resolve(): InkObject | null {\n    if (this.index < 0) return this.container;\n    if (this.container == null) return null;\n    if (this.container.content.length == 0) return this.container;\n    if (this.index >= this.container.content.length) return null;\n\n    return this.container.content[this.index];\n  }\n\n  get isNull(): boolean {\n    return this.container == null;\n  }\n\n  get path(): Path | null {\n    if (this.isNull) return null;\n\n    if (this.index >= 0)\n      return this.container!.path.PathByAppendingComponent(\n        new Path.Component(this.index)\n      );\n    else return this.container!.path;\n  }\n\n  public toString(): string {\n    if (!this.container) return \"Ink Pointer (null)\";\n\n    return (\n      \"Ink Pointer -> \" +\n      this.container.path.toString() +\n      \" -- index \" +\n      this.index\n    );\n  }\n\n  // This method does not exist in the original C# code, but is here to maintain the\n  // value semantics of Pointer.\n  public copy(): Pointer {\n    return new Pointer(this.container, this.index);\n  }\n\n  public static StartOf(container: Container | null): Pointer {\n    return new Pointer(container, 0);\n  }\n\n  public static get Null(): Pointer {\n    return new Pointer(null, -1);\n  }\n}\n","import { Path } from \"./Path\";\nimport { PushPopType } from \"./PushPop\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { InkObject } from \"./Object\";\nimport { Pointer } from \"./Pointer\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Divert extends InkObject {\n  get targetPath() {\n    if (this._targetPath != null && this._targetPath.isRelative) {\n      let targetObj = this.targetPointer.Resolve();\n      if (targetObj) {\n        this._targetPath = targetObj.path;\n      }\n    }\n\n    return this._targetPath;\n  }\n  set targetPath(value: Path | null) {\n    this._targetPath = value;\n    this._targetPointer = Pointer.Null;\n  }\n\n  public _targetPath: Path | null = null;\n\n  get targetPointer() {\n    if (this._targetPointer.isNull) {\n      let targetObj = this.ResolvePath(this._targetPath).obj;\n\n      if (this._targetPath === null)\n        return throwNullException(\"this._targetPath\");\n      if (this._targetPath.lastComponent === null)\n        return throwNullException(\"this._targetPath.lastComponent\");\n\n      if (this._targetPath.lastComponent.isIndex) {\n        if (targetObj === null) return throwNullException(\"targetObj\");\n        this._targetPointer.container =\n          targetObj.parent instanceof Container ? targetObj.parent : null;\n        this._targetPointer.index = this._targetPath.lastComponent.index;\n      } else {\n        this._targetPointer = Pointer.StartOf(\n          targetObj instanceof Container ? targetObj : null\n        );\n      }\n    }\n\n    return this._targetPointer.copy();\n  }\n\n  public _targetPointer: Pointer = Pointer.Null;\n\n  get targetPathString() {\n    if (this.targetPath == null) return null;\n\n    return this.CompactPathString(this.targetPath);\n  }\n  set targetPathString(value: string | null) {\n    if (value == null) {\n      this.targetPath = null;\n    } else {\n      this.targetPath = new Path(value);\n    }\n  }\n\n  public variableDivertName: string | null = null;\n  get hasVariableTarget() {\n    return this.variableDivertName != null;\n  }\n\n  public pushesToStack: boolean = false;\n  public stackPushType: PushPopType = 0;\n\n  public isExternal: boolean = false;\n  public externalArgs: number = 0;\n\n  public isConditional: boolean = false;\n\n  constructor(stackPushType?: PushPopType) {\n    super();\n    this.pushesToStack = false;\n\n    if (typeof stackPushType !== \"undefined\") {\n      this.pushesToStack = true;\n      this.stackPushType = stackPushType;\n    }\n  }\n\n  public Equals(obj: Divert | null) {\n    let otherDivert = obj;\n    if (otherDivert instanceof Divert) {\n      if (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n        if (this.hasVariableTarget) {\n          return this.variableDivertName == otherDivert.variableDivertName;\n        } else {\n          if (this.targetPath === null)\n            return throwNullException(\"this.targetPath\");\n          return this.targetPath.Equals(otherDivert.targetPath);\n        }\n      }\n    }\n    return false;\n  }\n\n  public toString() {\n    if (this.hasVariableTarget) {\n      return \"Divert(variable: \" + this.variableDivertName + \")\";\n    } else if (this.targetPath == null) {\n      return \"Divert(null)\";\n    } else {\n      let sb = new StringBuilder();\n\n      let targetStr = this.targetPath.toString();\n      // int? targetLineNum = DebugLineNumberOfPath (targetPath);\n      let targetLineNum = null;\n      if (targetLineNum != null) {\n        targetStr = \"line \" + targetLineNum;\n      }\n\n      sb.Append(\"Divert\");\n\n      if (this.isConditional) sb.Append(\"?\");\n\n      if (this.pushesToStack) {\n        if (this.stackPushType == PushPopType.Function) {\n          sb.Append(\" function\");\n        } else {\n          sb.Append(\" tunnel\");\n        }\n      }\n\n      sb.Append(\" -> \");\n      sb.Append(this.targetPathString);\n\n      sb.Append(\" (\");\n      sb.Append(targetStr);\n      sb.Append(\")\");\n\n      return sb.toString();\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class VariableAssignment extends InkObject {\n  public readonly variableName: string | null;\n  public readonly isNewDeclaration: boolean;\n  public isGlobal: boolean;\n\n  constructor(variableName: string | null, isNewDeclaration: boolean) {\n    super();\n    this.variableName = variableName || null;\n    this.isNewDeclaration = !!isNewDeclaration;\n    this.isGlobal = false;\n  }\n\n  public toString(): string {\n    return \"VarAssign to \" + this.variableName;\n  }\n}\n","import { ChoicePoint } from \"../../../engine/ChoicePoint\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ContentList } from \"./ContentList\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTargetValue } from \"../../../engine/Value\";\nimport { INamedContent } from \"../../../engine/INamedContent\";\nimport { IWeavePoint } from \"./IWeavePoint\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Path as RuntimePath } from \"../../../engine/Path\";\nimport { Story } from \"./Story\";\nimport { SymbolType } from \"./SymbolType\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../engine/VariableAssignment\";\nimport { Expression } from \"./Expression/Expression\";\nimport { Identifier } from \"./Identifier\";\n\nexport class Choice extends ParsedObject implements IWeavePoint, INamedContent {\n  private _condition: Expression | null = null;\n  private _innerContentContainer: RuntimeContainer | null = null;\n  private _outerContainer: RuntimeContainer | null = null;\n  private _runtimeChoice: ChoicePoint | null = null;\n  get runtimeChoice(): ChoicePoint {\n    if (!this._runtimeChoice) {\n      throw new Error();\n    }\n\n    return this._runtimeChoice;\n  }\n\n  private _returnToR1: DivertTargetValue | null = null;\n  private _returnToR2: DivertTargetValue | null = null;\n  private _r1Label: RuntimeContainer | null = null;\n  private _r2Label: RuntimeContainer | null = null;\n  private _divertToStartContentOuter: RuntimeDivert | null = null;\n  private _divertToStartContentInner: RuntimeDivert | null = null;\n  private _startContentRuntimeContainer: RuntimeContainer | null = null;\n\n  public startContent: ContentList;\n  public choiceOnlyContent: ContentList;\n  public innerContent: ContentList;\n  public identifier?: Identifier;\n  get name() {\n    return this.identifier?.name || null;\n  }\n  public onceOnly: boolean;\n  public isInvisibleDefault: boolean = false;\n  public indentationDepth: number;\n  public hasWeaveStyleInlineBrackets: boolean = false;\n\n  get condition() {\n    return this._condition;\n  }\n\n  set condition(value) {\n    this._condition = value;\n    if (value) {\n      this.AddContent(value as ParsedObject);\n    }\n  }\n\n  // Required for IWeavePoint interface\n  // Choice's target container. Used by weave to append any extra\n  // nested weave content into.\n  get runtimeContainer() {\n    return this._innerContentContainer;\n  }\n\n  get innerContentContainer() {\n    return this._innerContentContainer;\n  }\n\n  get containerForCounting() {\n    return this._innerContentContainer;\n  }\n\n  // Override runtimePath to point to the Choice's target content (after it's chosen),\n  // as opposed to the default implementation which would point to the choice itself\n  // (or it's outer container), which is what runtimeObject is.\n  get runtimePath(): RuntimePath {\n    if (!this.innerContentContainer || !this.innerContentContainer.path) {\n      throw new Error();\n    }\n\n    return this.innerContentContainer.path;\n  }\n\n  constructor(\n    startContent: ContentList,\n    choiceOnlyContent: ContentList,\n    innerContent: ContentList\n  ) {\n    super();\n\n    this.startContent = startContent;\n    this.choiceOnlyContent = choiceOnlyContent;\n    this.innerContent = innerContent;\n    this.indentationDepth = 1;\n\n    if (startContent) {\n      this.AddContent(this.startContent);\n    }\n\n    if (choiceOnlyContent) {\n      this.AddContent(this.choiceOnlyContent);\n    }\n\n    if (innerContent) {\n      this.AddContent(this.innerContent);\n    }\n\n    this.onceOnly = true; // default\n  }\n\n  get typeName(): string {\n    return \"Choice\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    this._outerContainer = new RuntimeContainer();\n\n    // Content names for different types of choice:\n    //  * start content [choice only content] inner content\n    //  * start content   -> divert\n    //  * start content\n    //  * [choice only content]\n\n    // Hmm, this structure has become slightly insane!\n    //\n    // [\n    //     EvalStart\n    //     assign $r = $r1   -- return target = return label 1\n    //     BeginString\n    //     -> s\n    //     [(r1)]            -- return label 1 (after start content)\n    //     EndString\n    //     BeginString\n    //     ... choice only content\n    //     EndEval\n    //     Condition expression\n    //     choice: -> \"c-0\"\n    //     (s) = [\n    //         start content\n    //         -> r          -- goto return label 1 or 2\n    //     ]\n    //  ]\n    //\n    //  in parent's container: (the inner content for the choice)\n    //\n    //  (c-0) = [\n    //      EvalStart\n    //      assign $r = $r2   -- return target = return label 2\n    //      EndEval\n    //      -> s\n    //      [(r2)]            -- return label 1 (after start content)\n    //      inner content\n    //  ]\n    //\n\n    this._runtimeChoice = new ChoicePoint(this.onceOnly);\n    this._runtimeChoice.isInvisibleDefault = this.isInvisibleDefault;\n\n    if (this.startContent || this.choiceOnlyContent || this.condition) {\n      this._outerContainer.AddContent(RuntimeControlCommand.EvalStart());\n    }\n\n    // Start content is put into a named container that's referenced both\n    // when displaying the choice initially, and when generating the text\n    // when the choice is chosen.\n    if (this.startContent) {\n      // Generate start content and return\n      //  - We can't use a function since it uses a call stack element, which would\n      //    put temporary values out of scope. Instead we manually divert around.\n      //  - $r is a variable divert target contains the return point\n      this._returnToR1 = new DivertTargetValue();\n      this._outerContainer.AddContent(this._returnToR1);\n\n      const varAssign = new RuntimeVariableAssignment(\"$r\", true);\n      this._outerContainer.AddContent(varAssign);\n\n      // Mark the start of the choice text generation, so that the runtime\n      // knows where to rewind to to extract the content from the output stream.\n      this._outerContainer.AddContent(RuntimeControlCommand.BeginString());\n\n      this._divertToStartContentOuter = new RuntimeDivert();\n      this._outerContainer.AddContent(this._divertToStartContentOuter);\n\n      // Start content itself in a named container\n      this._startContentRuntimeContainer =\n        this.startContent.GenerateRuntimeObject() as RuntimeContainer;\n      this._startContentRuntimeContainer.name = \"s\";\n\n      // Effectively, the \"return\" statement - return to the point specified by $r\n      const varDivert = new RuntimeDivert();\n      varDivert.variableDivertName = \"$r\";\n      this._startContentRuntimeContainer.AddContent(varDivert);\n\n      // Add the container\n      this._outerContainer.AddToNamedContentOnly(\n        this._startContentRuntimeContainer\n      );\n\n      // This is the label to return to\n      this._r1Label = new RuntimeContainer();\n      this._r1Label.name = \"$r1\";\n      this._outerContainer.AddContent(this._r1Label);\n\n      this._outerContainer.AddContent(RuntimeControlCommand.EndString());\n\n      this._runtimeChoice.hasStartContent = true;\n    }\n\n    // Choice only content - mark the start, then generate it directly into the outer container\n    if (this.choiceOnlyContent) {\n      this._outerContainer.AddContent(RuntimeControlCommand.BeginString());\n\n      const choiceOnlyRuntimeContent =\n        this.choiceOnlyContent.GenerateRuntimeObject() as RuntimeContainer;\n      this._outerContainer.AddContentsOfContainer(choiceOnlyRuntimeContent);\n\n      this._outerContainer.AddContent(RuntimeControlCommand.EndString());\n\n      this._runtimeChoice.hasChoiceOnlyContent = true;\n    }\n\n    // Generate any condition for this choice\n    if (this.condition) {\n      this.condition.GenerateIntoContainer(this._outerContainer);\n      this._runtimeChoice.hasCondition = true;\n    }\n\n    if (this.startContent || this.choiceOnlyContent || this.condition) {\n      this._outerContainer.AddContent(RuntimeControlCommand.EvalEnd());\n    }\n\n    // Add choice itself\n    this._outerContainer.AddContent(this._runtimeChoice);\n\n    // Container that choice points to for when it's chosen\n    this._innerContentContainer = new RuntimeContainer();\n\n    // Repeat start content by diverting to its container\n    if (this.startContent) {\n      // Set the return point when jumping back into the start content\n      //  - In this case, it's the $r2 point, within the choice content \"c\".\n      this._returnToR2 = new DivertTargetValue();\n      this._innerContentContainer.AddContent(RuntimeControlCommand.EvalStart());\n      this._innerContentContainer.AddContent(this._returnToR2);\n      this._innerContentContainer.AddContent(RuntimeControlCommand.EvalEnd());\n      const varAssign = new RuntimeVariableAssignment(\"$r\", true);\n      this._innerContentContainer.AddContent(varAssign);\n\n      // Main divert into start content\n      this._divertToStartContentInner = new RuntimeDivert();\n      this._innerContentContainer.AddContent(this._divertToStartContentInner);\n\n      // Define label to return to\n      this._r2Label = new RuntimeContainer();\n      this._r2Label.name = \"$r2\";\n      this._innerContentContainer.AddContent(this._r2Label);\n    }\n\n    // Choice's own inner content\n    if (this.innerContent) {\n      const innerChoiceOnlyContent =\n        this.innerContent.GenerateRuntimeObject() as RuntimeContainer;\n      this._innerContentContainer.AddContentsOfContainer(\n        innerChoiceOnlyContent\n      );\n    }\n\n    if (this.story.countAllVisits) {\n      this._innerContentContainer.visitsShouldBeCounted = true;\n    }\n\n    this._innerContentContainer.countingAtStartOnly = true;\n\n    return this._outerContainer;\n  };\n\n  public ResolveReferences(context: Story): void {\n    // Weave style choice - target own content container\n    if (this._innerContentContainer) {\n      this.runtimeChoice.pathOnChoice = this._innerContentContainer.path;\n\n      if (this.onceOnly) {\n        this._innerContentContainer.visitsShouldBeCounted = true;\n      }\n    }\n\n    if (this._returnToR1) {\n      if (!this._r1Label) {\n        throw new Error();\n      }\n\n      this._returnToR1.targetPath = this._r1Label.path;\n    }\n\n    if (this._returnToR2) {\n      if (!this._r2Label) {\n        throw new Error();\n      }\n\n      this._returnToR2.targetPath = this._r2Label.path;\n    }\n\n    if (this._divertToStartContentOuter) {\n      if (!this._startContentRuntimeContainer) {\n        throw new Error();\n      }\n\n      this._divertToStartContentOuter.targetPath =\n        this._startContentRuntimeContainer.path;\n    }\n\n    if (this._divertToStartContentInner) {\n      if (!this._startContentRuntimeContainer) {\n        throw new Error();\n      }\n\n      this._divertToStartContentInner.targetPath =\n        this._startContentRuntimeContainer.path;\n    }\n\n    super.ResolveReferences(context);\n\n    if (this.identifier && (this.identifier?.name || \"\").length > 0) {\n      context.CheckForNamingCollisions(\n        this as ParsedObject,\n        this.identifier,\n        SymbolType.SubFlowAndWeave\n      );\n    }\n  }\n\n  public readonly toString = () => {\n    if (this.choiceOnlyContent !== null) {\n      return `* ${this.startContent}[${this.choiceOnlyContent}]...`;\n    }\n\n    return `* ${this.startContent}...`;\n  };\n}\n","export class StringParserElement {\n  public static _uniqueIdCounter: number = 1000;\n\n  public characterIndex: number = 0;\n  public characterInLineIndex: number = 0;\n  public lineIndex: number = 0;\n  public reportedErrorInScope: boolean = false;\n  public uniqueId: number = 0;\n  public customFlags: number = 0;\n\n  public readonly CopyFrom = (fromElement: StringParserElement): void => {\n    StringParserElement._uniqueIdCounter++;\n    this.uniqueId = StringParserElement._uniqueIdCounter;\n    this.characterIndex = fromElement.characterIndex;\n    this.characterInLineIndex = fromElement.characterInLineIndex;\n    this.lineIndex = fromElement.lineIndex;\n    this.customFlags = fromElement.customFlags;\n    this.reportedErrorInScope = false;\n  };\n\n  // Squash is used when succeeding from a rule,\n  // so only the state information we wanted to carry forward is\n  // retained. e.g. characterIndex and lineIndex are global,\n  // however uniqueId is specific to the individual rule,\n  // and likewise, custom flags are designed for the temporary\n  // state of the individual rule too.\n  public readonly SquashFrom = (fromElement: StringParserElement): void => {\n    this.characterIndex = fromElement.characterIndex;\n    this.characterInLineIndex = fromElement.characterInLineIndex;\n    this.lineIndex = fromElement.lineIndex;\n    this.reportedErrorInScope = fromElement.reportedErrorInScope;\n    this.customFlags = fromElement.customFlags;\n  };\n}\n","import { StringParserElement } from \"./StringParserElement\";\n\nexport class StringParserState {\n  private _stack: StringParserElement[] = [];\n  private _numElements: number = 0;\n\n  get currentElement(): StringParserElement {\n    return this._stack[this._numElements - 1];\n  }\n\n  get lineIndex(): number {\n    return this.currentElement.lineIndex;\n  }\n\n  set lineIndex(value: number) {\n    this.currentElement.lineIndex = value;\n  }\n\n  get characterIndex(): number {\n    return this.currentElement.characterIndex;\n  }\n\n  set characterIndex(value: number) {\n    this.currentElement.characterIndex = value;\n  }\n\n  get characterInLineIndex(): number {\n    return this.currentElement.characterInLineIndex;\n  }\n\n  set characterInLineIndex(value: number) {\n    this.currentElement.characterInLineIndex = value;\n  }\n\n  get customFlags(): number {\n    return this.currentElement.customFlags;\n  }\n\n  set customFlags(value: number) {\n    this.currentElement.customFlags = value;\n  }\n\n  get errorReportedAlreadyInScope(): boolean {\n    return this.currentElement.reportedErrorInScope;\n  }\n\n  get stackHeight(): number {\n    return this._numElements;\n  }\n\n  constructor() {\n    const kExpectedMaxStackDepth = 200;\n    for (let i = 0; i < kExpectedMaxStackDepth; i++) {\n      this._stack[i] = new StringParserElement();\n    }\n    this._numElements = 1;\n  }\n\n  public readonly StringParserState = (): void => {\n    const kExpectedMaxStackDepth: number = 200;\n    this._stack = new Array(kExpectedMaxStackDepth);\n\n    for (let ii = 0; ii < kExpectedMaxStackDepth; ++ii) {\n      this._stack[ii] = new StringParserElement();\n    }\n\n    this._numElements = 1;\n  };\n\n  public readonly Push = (): number => {\n    if (this._numElements >= this._stack.length && this._numElements > 0) {\n      throw new Error(\"Stack overflow in parser state.\");\n    }\n\n    const prevElement = this._stack[this._numElements - 1];\n    const newElement = this._stack[this._numElements];\n    this._numElements++;\n\n    newElement.CopyFrom(prevElement);\n\n    return newElement.uniqueId;\n  };\n\n  public readonly Pop = (expectedRuleId: number): void => {\n    if (this._numElements == 1) {\n      throw new Error(\n        \"Attempting to remove final stack element is illegal! Mismatched Begin/Succceed/Fail?\"\n      );\n    }\n\n    if (this.currentElement.uniqueId != expectedRuleId) {\n      throw new Error(\n        \"Mismatched rule IDs while Poping - do you have mismatched Begin/Succeed/Fail?\"\n      );\n    }\n\n    // Restore state\n    this._numElements -= 1;\n  };\n\n  public Peek = (expectedRuleId: number) => {\n    if (this.currentElement.uniqueId != expectedRuleId) {\n      throw new Error(\n        \"Mismatched rule IDs while Peeking - do you have mismatched Begin/Succeed/Fail?\"\n      );\n    }\n\n    return this._stack[this._numElements - 1];\n  };\n\n  public readonly PeekPenultimate = (): StringParserElement | null => {\n    if (this._numElements >= 2) {\n      return this._stack[this._numElements - 2];\n    }\n\n    return null;\n  };\n\n  // Reduce stack height while maintaining currentElement\n  // Remove second last element: i.e. \"squash last two elements together\"\n  // Used when succeeding from a rule (and ONLY when succeeding, since\n  // the state of the top element is retained).\n  public readonly Squash = (): void => {\n    if (this._numElements < 2) {\n      throw new Error(\n        \"Attempting to remove final stack element is illegal! Mismatched Begin/Succceed/Fail?\"\n      );\n    }\n\n    const penultimateEl = this._stack[this._numElements - 2];\n    const lastEl = this._stack[this._numElements - 1];\n\n    penultimateEl.SquashFrom(lastEl);\n\n    this._numElements -= 1;\n  };\n\n  public readonly NoteErrorReported = (): void => {\n    for (const el of this._stack) {\n      el.reportedErrorInScope = true;\n    }\n  };\n}\n","import { CharacterSet } from \"../CharacterSet\";\nimport { ParsedObject } from \"../ParsedHierarchy/Object\";\nimport { StringParserState } from \"./StringParserState\";\nimport { StringParserElement } from \"./StringParserElement\";\n\nexport const ParseSuccess = Symbol(\"ParseSuccessStruct\");\n\nexport type ParseRule = () => ParseRuleReturn;\n\nexport type ParseRuleReturn =\n  | object\n  | string\n  | null\n  | number\n  | (typeof StringParser)[\"ParseSuccess\"];\n\nexport type SpecificParseRule<T extends ParseRule> = T;\n\nexport class StringParser {\n  public ParseRule: ParseRule | null = null;\n\n  public static readonly ParseSuccess: typeof ParseSuccess = ParseSuccess;\n  public static readonly numbersCharacterSet = new CharacterSet(\"0123456789\");\n\n  private _chars: string[];\n\n  public errorHandler:\n    | null\n    | ((\n        message: string,\n        index: number,\n        lineIndex?: number,\n        isWarning?: boolean\n      ) => void) = null;\n  public state: StringParserState;\n  public hadError: boolean = false;\n\n  constructor(str: string) {\n    const strPreProc = this.PreProcessInputString(str);\n    this.state = new StringParserState();\n\n    if (str) {\n      this._chars = strPreProc.split(\"\");\n    } else {\n      this._chars = [];\n    }\n\n    this.inputString = strPreProc;\n  }\n\n  get currentCharacter(): string {\n    if (this.index >= 0 && this.remainingLength > 0) {\n      return this._chars[this.index];\n    }\n\n    return \"0\";\n  }\n\n  // Don't do anything by default, but provide ability for subclasses\n  // to manipulate the string before it's used as input (converted to a char array)\n  public PreProcessInputString(str: string): string {\n    return str;\n  }\n\n  //--------------------------------\n  // Parse state\n  //--------------------------------\n\n  public readonly BeginRule = (): number => this.state.Push();\n\n  public readonly FailRule = (expectedRuleId: number): ParseRuleReturn => {\n    this.state.Pop(expectedRuleId);\n    return null;\n  };\n\n  public readonly CancelRule = (expectedRuleId: number): void => {\n    this.state.Pop(expectedRuleId);\n  };\n\n  public readonly SucceedRule = (\n    expectedRuleId: number,\n    result: ParseRuleReturn = null\n  ): ParseRuleReturn => {\n    // Get state at point where this rule stared evaluating\n    const stateAtSucceedRule = this.state.Peek(expectedRuleId);\n    const stateAtBeginRule = this.state.PeekPenultimate();\n\n    // Allow subclass to receive callback\n    if (this.RuleDidSucceed) {\n      this.RuleDidSucceed(result, stateAtBeginRule, stateAtSucceedRule);\n    }\n\n    // Flatten state stack so that we maintain the same values,\n    // but remove one level in the stack.\n    this.state.Squash();\n\n    let finalResult: ParseRuleReturn = result;\n    if (finalResult === null) {\n      finalResult = StringParser.ParseSuccess;\n    }\n\n    return finalResult;\n  };\n\n  public RuleDidSucceed?: (\n    result: ParseRuleReturn,\n    startState: StringParserElement | null,\n    endState: StringParserElement\n  ) => void;\n\n  public readonly Expect = (\n    rule: ParseRule,\n    message: string | null = null,\n    recoveryRule: ParseRule | null = null\n  ): ParseRuleReturn => {\n    let result: ParseRuleReturn = this.ParseObject(rule);\n    if (result === null) {\n      if (message === null) {\n        message = rule.name;\n      }\n\n      let butSaw: string;\n      const lineRemainder: string = this.LineRemainder();\n      if (lineRemainder === null || lineRemainder.length === 0) {\n        butSaw = \"end of line\";\n      } else {\n        butSaw = `'${lineRemainder}'`;\n      }\n\n      this.Error(`Expected ${message} but saw ${butSaw}`);\n\n      if (recoveryRule !== null) {\n        result = recoveryRule();\n      }\n    }\n\n    return result;\n  };\n\n  public Error = (message: string, isWarning: boolean = false): void => {\n    this.ErrorOnLine(message, this.lineIndex + 1, isWarning);\n  };\n\n  public readonly ErrorWithParsedObject = (\n    message: string,\n    result: ParsedObject,\n    isWarning: boolean = false\n  ): void => {\n    this.ErrorOnLine(\n      message,\n      result.debugMetadata ? result.debugMetadata.startLineNumber : -1,\n      isWarning\n    );\n  };\n\n  public readonly ErrorOnLine = (\n    message: string,\n    lineNumber: number,\n    isWarning: boolean\n  ): void => {\n    if (!this.state.errorReportedAlreadyInScope) {\n      const errorType = isWarning ? \"Warning\" : \"Error\";\n\n      if (!this.errorHandler) {\n        throw new Error(`${errorType} on line ${lineNumber}: ${message}`);\n      } else {\n        this.errorHandler(message, this.index, lineNumber - 1, isWarning);\n      }\n\n      this.state.NoteErrorReported();\n    }\n\n    if (!isWarning) {\n      this.hadError = true;\n    }\n  };\n\n  public readonly Warning = (message: string): void =>\n    this.Error(message, true);\n\n  get endOfInput(): boolean {\n    return this.index >= this._chars.length;\n  }\n\n  get remainingString(): string {\n    return this._chars\n      .slice(this.index, this.index + this.remainingLength)\n      .join(\"\");\n  }\n\n  public readonly LineRemainder = (): string =>\n    this.Peek(() => this.ParseUntilCharactersFromString(\"\\n\\r\")) as string;\n\n  get remainingLength() {\n    return this._chars.length - this.index;\n  }\n\n  public inputString: string;\n\n  get lineIndex() {\n    return this.state.lineIndex;\n  }\n\n  set lineIndex(value: number) {\n    this.state.lineIndex = value;\n  }\n\n  set characterInLineIndex(value: number) {\n    this.state.characterInLineIndex = value;\n  }\n\n  get characterInLineIndex() {\n    return this.state.characterInLineIndex;\n  }\n\n  get index(): number {\n    // If we want subclass parsers to be able to set the index directly,\n    // then we would need to know what the lineIndex of the new\n    // index would be - would we have to step through manually\n    // counting the newlines to do so?\n    return this.state.characterIndex;\n  }\n\n  set index(value: number) {\n    this.state.characterIndex = value;\n  }\n\n  public readonly SetFlag = (flag: number, trueOrFalse: boolean): void => {\n    if (trueOrFalse) {\n      this.state.customFlags |= flag;\n    } else {\n      this.state.customFlags &= ~flag;\n    }\n  };\n\n  public readonly GetFlag = (flag: number): boolean =>\n    Boolean(this.state.customFlags & flag);\n\n  //--------------------------------\n  // Structuring\n  //--------------------------------\n\n  public ParseObject = (rule: ParseRule): ParseRuleReturn => {\n    const ruleId: number = this.BeginRule();\n    const stackHeightBefore = this.state.stackHeight;\n    const result = rule();\n\n    if (stackHeightBefore !== this.state.stackHeight) {\n      throw new Error(\"Mismatched Begin/Fail/Succeed rules\");\n    }\n\n    if (result === null) {\n      return this.FailRule(ruleId);\n    }\n\n    this.SucceedRule(ruleId, result);\n\n    return result;\n  };\n\n  public readonly Parse = <T extends ParseRule>(\n    rule: SpecificParseRule<T>\n  ): ParseRuleReturn => {\n    const ruleId: number = this.BeginRule();\n\n    const result: ParseRuleReturn = rule();\n    if (result === null) {\n      this.FailRule(ruleId);\n      return null;\n    }\n\n    this.SucceedRule(ruleId, result);\n\n    return result;\n  };\n\n  public readonly OneOf = (array: ParseRule[]): ParseRuleReturn => {\n    for (const rule of array) {\n      const result = this.ParseObject(rule);\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    return null;\n  };\n\n  public readonly OneOrMore = (rule: ParseRule): ParseRuleReturn[] | null => {\n    const results: ParseRuleReturn[] = [];\n    let result: ParseRuleReturn = null;\n\n    do {\n      result = this.ParseObject(rule);\n      if (result !== null) {\n        results.push(result);\n      }\n    } while (result !== null);\n\n    if (results.length > 0) {\n      return results;\n    }\n\n    return null;\n  };\n\n  public readonly Optional =\n    (rule: ParseRule): ParseRule =>\n    () => {\n      const result = this.ParseObject(rule);\n      if (result === null) return StringParser.ParseSuccess;\n      return result;\n    };\n\n  // Return ParseSuccess instead the real result so that it gets excluded\n  // from result arrays (e.g. Interleave)\n  public readonly Exclude =\n    (rule: ParseRule): ParseRule =>\n    () =>\n      this.ParseObject(rule) && StringParser.ParseSuccess;\n\n  // Combination of both of the above\n  public readonly OptionalExclude =\n    (rule: ParseRule): ParseRule =>\n    () => {\n      this.ParseObject(rule);\n      return StringParser.ParseSuccess;\n    };\n\n  // Convenience method for creating more readable ParseString rules that can be combined\n  // in other structuring rules (like OneOf etc)\n  // e.g. OneOf(String(\"one\"), String(\"two\"))\n  public readonly String =\n    (str: string): ParseRule =>\n    () =>\n      this.ParseString(str);\n\n  private readonly TryAddResultToList = <T>(\n    result: ParseRuleReturn,\n    list: T[],\n    flatten: boolean = true\n  ): void => {\n    if (result === StringParser.ParseSuccess) {\n      return;\n    }\n\n    if (flatten && Array.isArray(result)) {\n      const resultCollection = result as ParseRuleReturn[];\n      if (resultCollection !== null) {\n        for (const obj of resultCollection) {\n          list.push(obj as any);\n        }\n\n        return;\n      }\n    }\n\n    list.push(result as any);\n  };\n\n  public readonly Interleave = <T>(\n    ruleA: ParseRule,\n    ruleB: ParseRule,\n    untilTerminator: ParseRule | null = null,\n    flatten: boolean = true\n  ): T[] => {\n    const ruleId: number = this.BeginRule();\n    const results: T[] = [];\n\n    // First outer padding\n    const firstA = this.ParseObject(ruleA);\n    if (firstA === null) {\n      return this.FailRule(ruleId) as any;\n    } else {\n      this.TryAddResultToList(firstA, results, flatten);\n    }\n\n    let lastMainResult: ParseRuleReturn | null = null;\n    let outerResult: ParseRuleReturn | null = null;\n    do {\n      // \"until\" condition hit?\n      if (untilTerminator !== null && this.Peek(untilTerminator) !== null) {\n        break;\n      }\n\n      // Main inner\n      lastMainResult = this.ParseObject(ruleB);\n      if (lastMainResult === null) {\n        break;\n      } else {\n        this.TryAddResultToList(lastMainResult, results, flatten);\n      }\n\n      // Outer result (i.e. last A in ABA)\n      outerResult = null;\n      if (lastMainResult !== null) {\n        outerResult = this.ParseObject(ruleA);\n\n        if (outerResult === null) {\n          break;\n        } else {\n          this.TryAddResultToList(outerResult, results, flatten);\n        }\n      }\n\n      // Stop if there are no results, or if both are the placeholder \"ParseSuccess\" (i.e. Optional success rather than a true value)\n    } while (\n      (lastMainResult !== null || outerResult !== null) &&\n      !(\n        (lastMainResult as any) === StringParser.ParseSuccess &&\n        outerResult == StringParser.ParseSuccess\n      ) &&\n      this.remainingLength > 0\n    );\n\n    if (results.length === 0) {\n      return this.FailRule(ruleId) as T[];\n    }\n\n    return this.SucceedRule(ruleId, results) as T[];\n  };\n\n  //--------------------------------\n  // Basic string parsing\n  //--------------------------------\n\n  public readonly ParseString = (str: string): string | null => {\n    if (str.length > this.remainingLength) {\n      return null;\n    }\n\n    const ruleId: number = this.BeginRule();\n\n    // Optimisation from profiling:\n    // Store in temporary local variables\n    // since they're properties that would have to access\n    // the rule stack every time otherwise.\n    let i: number = this.index;\n    let cli: number = this.characterInLineIndex;\n    let li: number = this.lineIndex;\n\n    let success: boolean = true;\n    for (let tempIdx = 0; tempIdx < str.length; tempIdx += 1) {\n      const c = str[tempIdx];\n\n      if (this._chars[i] !== c) {\n        success = false;\n        break;\n      }\n      if (c === \"\\n\") {\n        li++;\n        cli = -1;\n      }\n\n      i++;\n      cli++;\n    }\n\n    this.index = i;\n    this.characterInLineIndex = cli;\n    this.lineIndex = li;\n\n    if (success) {\n      return this.SucceedRule(ruleId, str) as any;\n    }\n\n    return this.FailRule(ruleId) as any;\n  };\n\n  public readonly ParseSingleCharacter = (): string => {\n    if (this.remainingLength > 0) {\n      const c = this._chars[this.index];\n      if (c === \"\\n\") {\n        this.lineIndex += 1;\n        this.characterInLineIndex = -1;\n      }\n\n      this.index += 1;\n      this.characterInLineIndex += 1;\n\n      return c;\n    }\n\n    return \"0\";\n  };\n\n  public readonly ParseUntilCharactersFromString = (\n    str: string,\n    maxCount: number = -1\n  ): string | null => this.ParseCharactersFromString(str, false, maxCount);\n\n  public readonly ParseUntilCharactersFromCharSet = (\n    charSet: CharacterSet,\n    maxCount: number = -1\n  ): string | null => this.ParseCharactersFromCharSet(charSet, false, maxCount);\n\n  public readonly ParseCharactersFromString = (\n    str: string,\n    maxCountOrShouldIncludeStrChars: boolean | number = -1,\n    maxCount: number = -1\n  ): string | null => {\n    const charSet = new CharacterSet(str);\n    if (typeof maxCountOrShouldIncludeStrChars === \"number\") {\n      return this.ParseCharactersFromCharSet(\n        charSet,\n        true,\n        maxCountOrShouldIncludeStrChars\n      );\n    }\n\n    return this.ParseCharactersFromCharSet(\n      charSet,\n      maxCountOrShouldIncludeStrChars,\n      maxCount\n    );\n  };\n\n  public readonly ParseCharactersFromCharSet = (\n    charSet: CharacterSet,\n    shouldIncludeChars: boolean = true,\n    maxCount: number = -1\n  ): string | null => {\n    if (maxCount === -1) {\n      maxCount = Number.MAX_SAFE_INTEGER;\n    }\n\n    const startIndex: number = this.index;\n\n    // Optimisation from profiling:\n    // Store in temporary local variables\n    // since they're properties that would have to access\n    // the rule stack every time otherwise.\n    let ii: number = this.index;\n    let cli: number = this.characterInLineIndex;\n    let li: number = this.lineIndex;\n    let count: number = 0;\n    while (\n      ii < this._chars.length &&\n      charSet.set.has(this._chars[ii]) === shouldIncludeChars &&\n      count < maxCount\n    ) {\n      if (this._chars[ii] === \"\\n\") {\n        li += 1;\n        cli = -1;\n      }\n\n      ii += 1;\n      cli += 1;\n      count += 1;\n    }\n\n    this.index = ii;\n    this.characterInLineIndex = cli;\n    this.lineIndex = li;\n\n    const lastCharIndex: number = this.index;\n    if (lastCharIndex > startIndex) {\n      return this._chars.slice(startIndex, this.index).join(\"\");\n    }\n\n    return null;\n  };\n\n  public readonly Peek = (rule: ParseRule): ParseRuleReturn => {\n    const ruleId: number = this.BeginRule();\n    const result: ParseRuleReturn = rule();\n    this.CancelRule(ruleId);\n\n    return result;\n  };\n\n  public ParseUntil(\n    stopRule: ParseRule,\n    pauseCharacters: CharacterSet | null = null,\n    endCharacters: CharacterSet | null = null\n  ): string {\n    const ruleId: number = this.BeginRule();\n    const pauseAndEnd: CharacterSet = new CharacterSet();\n    if (pauseCharacters !== null) {\n      pauseAndEnd.set = new Set([\n        ...pauseAndEnd.set.values(),\n        ...pauseCharacters.set.values(),\n      ]);\n    }\n\n    if (endCharacters !== null) {\n      pauseAndEnd.set = new Set([\n        ...pauseAndEnd.set.values(),\n        ...endCharacters.set.values(),\n      ]);\n    }\n\n    let parsedString = \"\";\n    let ruleResultAtPause: ParseRuleReturn | null = null;\n\n    // Keep attempting to parse strings up to the pause (and end) points.\n    //  - At each of the pause points, attempt to parse according to the rule\n    //  - When the end point is reached (or EOF), we're done\n    do {\n      // TODO: Perhaps if no pause or end characters are passed, we should check *every* character for stopRule?\n      const partialParsedString: string | null =\n        this.ParseUntilCharactersFromCharSet(pauseAndEnd);\n\n      if (partialParsedString) {\n        parsedString += partialParsedString;\n      }\n\n      // Attempt to run the parse rule at this pause point\n      ruleResultAtPause = this.Peek(stopRule);\n\n      // Rule completed - we're done\n      if (ruleResultAtPause !== null) {\n        break;\n      } else {\n        if (this.endOfInput) {\n          break;\n        }\n\n        // Reached a pause point, but rule failed. Step past and continue parsing string\n        const pauseCharacter: string = this.currentCharacter;\n        if (\n          pauseCharacters !== null &&\n          pauseCharacters.set.has(pauseCharacter)\n        ) {\n          parsedString += pauseCharacter;\n          if (pauseCharacter === \"\\n\") {\n            this.lineIndex += 1;\n            this.characterInLineIndex = -1;\n          }\n\n          this.index += 1;\n          this.characterInLineIndex += 1;\n\n          continue;\n        } else {\n          break;\n        }\n      }\n    } while (true);\n\n    if (parsedString.length > 0) {\n      return this.SucceedRule(ruleId, String(parsedString)) as string;\n    }\n\n    return this.FailRule(ruleId) as string;\n  }\n\n  // No need to Begin/End rule since we never parse a newline, so keeping oldIndex is good enough\n  public readonly ParseInt = (): number | null => {\n    const oldIndex: number = this.index;\n    const oldCharacterInLineIndex: number = this.characterInLineIndex;\n    const negative: boolean = this.ParseString(\"-\") !== null;\n\n    // Optional whitespace\n    this.ParseCharactersFromString(\" \\t\");\n\n    const parsedString = this.ParseCharactersFromCharSet(\n      StringParser.numbersCharacterSet\n    );\n    if (parsedString === null) {\n      // Roll back and fail\n      this.index = oldIndex;\n      this.characterInLineIndex = oldCharacterInLineIndex;\n\n      return null;\n    }\n\n    let parsedInt: number;\n    if (!Number.isNaN(Number(parsedString))) {\n      parsedInt = Number(parsedString);\n      return negative ? -parsedInt : parsedInt;\n    }\n\n    this.Error(\n      \"Failed to read integer value: \" +\n        parsedString +\n        \". Perhaps it's out of the range of acceptable numbers ink supports? (\" +\n        Number.MIN_SAFE_INTEGER +\n        \" to \" +\n        Number.MAX_SAFE_INTEGER +\n        \")\"\n    );\n\n    return null;\n  };\n\n  // No need to Begin/End rule since we never parse a newline, so keeping oldIndex is good enough\n  public readonly ParseFloat = (): number | null => {\n    const oldIndex: number = this.index;\n    const oldCharacterInLineIndex: number = this.characterInLineIndex;\n\n    const leadingInt: number | null = this.ParseInt();\n    if (leadingInt !== null) {\n      if (this.ParseString(\".\") !== null) {\n        const afterDecimalPointStr = this.ParseCharactersFromCharSet(\n          StringParser.numbersCharacterSet\n        );\n\n        return Number(`${leadingInt}.${afterDecimalPointStr}`);\n      }\n    }\n\n    // Roll back and fail\n    this.index = oldIndex;\n    this.characterInLineIndex = oldCharacterInLineIndex;\n\n    return null;\n  };\n\n  public readonly ParseNewline = (): string => {\n    const ruleId: number = this.BeginRule();\n\n    // Optional \\r, definite \\n to support Windows (\\r\\n) and Mac/Unix (\\n)\n    // 2nd May 2016: Always collapse \\r\\n to just \\n\n    this.ParseString(\"\\r\");\n\n    if (this.ParseString(\"\\n\") === null) {\n      return this.FailRule(ruleId) as string;\n    }\n\n    return this.SucceedRule(ruleId, \"\\n\") as string;\n  };\n}\n","import { CharacterSet } from \"./CharacterSet\";\nimport { StringParser } from \"./StringParser/StringParser\";\n\n/// <summary>\n/// Pre-pass before main ink parser runs. It actually performs two main tasks:\n///  - comment elimination to simplify the parse rules in the main parser\n///  - Conversion of Windows line endings (\\r\\n) to the simpler Unix style (\\n), so\n///    we don't have to worry about them later.\n/// </summary>\nexport class CommentEliminator extends StringParser {\n  public _commentOrNewlineStartCharacter = new CharacterSet(\"/\\r\\n\");\n  public _commentBlockEndCharacter = new CharacterSet(\"*\");\n  public _newlineCharacters = new CharacterSet(\"\\n\\r\");\n\n  public readonly Process = (): string => {\n    // Make both comments and non-comments optional to handle trivial empty file case (or *only* comments)\n    const stringList: string[] = this.Interleave<string>(\n      this.Optional(this.CommentsAndNewlines),\n      this.Optional(this.MainInk)\n    );\n\n    if (stringList !== null) {\n      return stringList.join(\"\");\n    } else {\n      return \"\";\n    }\n  };\n\n  public readonly MainInk = () =>\n    this.ParseUntil(\n      this.CommentsAndNewlines,\n      this._commentOrNewlineStartCharacter,\n      null\n    );\n\n  public readonly CommentsAndNewlines = () => {\n    let newLines: string[] = this.Interleave<string>(\n      this.Optional(this.ParseNewline),\n      this.Optional(this.ParseSingleComment)\n    );\n\n    if (newLines !== null) {\n      return newLines.join(\"\");\n    }\n\n    return null;\n  };\n\n  // Valid comments always return either an empty string or pure newlines,\n  // which we want to keep so that line numbers stay the same\n  public readonly ParseSingleComment = () =>\n    this.OneOf([this.EndOfLineComment, this.BlockComment]);\n\n  public readonly EndOfLineComment = () => {\n    if (this.ParseString(\"//\") === null) {\n      return null;\n    }\n\n    this.ParseUntilCharactersFromCharSet(this._newlineCharacters);\n\n    return \"\";\n  };\n\n  public readonly BlockComment = () => {\n    if (this.ParseString(\"/*\") === null) {\n      return null;\n    }\n\n    const startLineIndex: number = this.lineIndex;\n    const commentResult = this.ParseUntil(\n      this.String(\"*/\"),\n      this._commentBlockEndCharacter,\n      null\n    );\n\n    if (!this.endOfInput) {\n      this.ParseString(\"*/\");\n    }\n\n    // Count the number of lines that were inside the block, and replicate them as newlines\n    // so that the line indexing still works from the original source\n    if (commentResult != null) {\n      return \"\\n\".repeat(this.lineIndex - startLineIndex);\n    }\n\n    // No comment at all\n    return null;\n  };\n\n  public PreProcessInputString(str: string): string {\n    return str;\n  }\n}\n","import { ConditionalSingleBranch } from \"./ConditionalSingleBranch\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Expression } from \"../Expression/Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\n\nexport class Conditional extends ParsedObject {\n  private _reJoinTarget: RuntimeControlCommand | null = null;\n\n  constructor(\n    public initialCondition: Expression,\n    public branches: ConditionalSingleBranch[]\n  ) {\n    super();\n\n    if (this.initialCondition) {\n      this.AddContent(this.initialCondition);\n    }\n\n    if (this.branches !== null) {\n      this.AddContent(this.branches);\n    }\n  }\n\n  get typeName(): string {\n    return \"Conditional\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    // Initial condition\n    if (this.initialCondition) {\n      container.AddContent(this.initialCondition.runtimeObject);\n    }\n\n    // Individual branches\n    for (const branch of this.branches) {\n      const branchContainer = branch.runtimeObject;\n      container.AddContent(branchContainer);\n    }\n\n    // If it's a switch-like conditional, each branch\n    // will have a \"duplicate\" operation for the original\n    // switched value. If there's no final else clause\n    // and we fall all the way through, we need to clean up.\n    // (An else clause doesn't dup but it *does* pop)\n    if (\n      this.initialCondition !== null &&\n      this.branches[0].ownExpression !== null &&\n      !this.branches[this.branches.length - 1].isElse\n    ) {\n      container.AddContent(RuntimeControlCommand.PopEvaluatedValue());\n    }\n\n    // Target for branches to rejoin to\n    this._reJoinTarget = RuntimeControlCommand.NoOp();\n    container.AddContent(this._reJoinTarget);\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    const pathToReJoin = this._reJoinTarget!.path;\n\n    for (const branch of this.branches) {\n      if (!branch.returnDivert) {\n        throw new Error();\n      }\n\n      branch.returnDivert.targetPath = pathToReJoin;\n    }\n\n    super.ResolveReferences(context);\n  }\n}\n","﻿import { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { StringValue } from \"../../../engine/Value\";\n\nexport class Text extends ParsedObject {\n  constructor(public text: string) {\n    super();\n  }\n  get typeName(): string {\n    return \"Text\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject =>\n    new StringValue(this.text);\n\n  public readonly toString = (): string => this.text;\n}\n","import { Expression } from \"../Expression/Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ConstantDeclaration extends ParsedObject {\n  get constantName(): string | undefined {\n    return this.constantIdentifier?.name;\n  }\n  public constantIdentifier: Identifier;\n\n  private _expression: Expression | null = null;\n\n  get expression(): Expression {\n    if (!this._expression) {\n      throw new Error();\n    }\n\n    return this._expression;\n  }\n\n  constructor(name: Identifier, assignedExpression: Expression) {\n    super();\n\n    this.constantIdentifier = name;\n\n    // Defensive programming in case parsing of assignedExpression failed\n    if (assignedExpression) {\n      this._expression = this.AddContent(assignedExpression) as Expression;\n    }\n  }\n\n  get typeName(): string {\n    return \"CONST\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    // Global declarations don't generate actual procedural\n    // runtime objects, but instead add a global variable to the story itself.\n    // The story then initialises them all in one go at the start of the game.\n    return null;\n  };\n\n  public ResolveReferences(context: Story) {\n    super.ResolveReferences(context);\n    context.CheckForNamingCollisions(\n      this,\n      this.constantIdentifier,\n      SymbolType.Var\n    );\n  }\n}\n","export enum FlowLevel {\n  Story, // 0\n  Knot, // 1\n  Stitch, // 2\n  // not actually a FlowBase, but used for diverts\n  WeavePoint, // 3\n}\n","export enum SequenceType {\n  Stopping = 1, // default\n  Cycle = 2,\n  Shuffle = 4,\n  Once = 8,\n}\n","export enum CustomFlags {\n  ParsingString = 0x1,\n  TagActive = 0x2,\n}\n","export enum StatementLevel {\n  InnerBlock,\n  Stitch,\n  Knot,\n  Top,\n}\n","// TODO: Unify with Compiler.\n\nexport type ErrorHandler = (message: string, type: ErrorType) => void;\n\nexport enum ErrorType {\n  Author,\n  Warning,\n  Error,\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { INamedContent } from \"../../../../engine/INamedContent\";\nimport { IWeavePoint } from \"../IWeavePoint\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { Identifier } from \"../Identifier\";\n\nexport class Gather extends ParsedObject implements INamedContent, IWeavePoint {\n  get name(): string | null {\n    return this.identifier?.name || null;\n  }\n  public identifier?: Identifier;\n\n  get runtimeContainer(): RuntimeContainer {\n    return this.runtimeObject as RuntimeContainer;\n  }\n\n  constructor(\n    identifier: Identifier | null,\n    public readonly indentationDepth: number\n  ) {\n    super();\n\n    if (identifier) this.identifier = identifier;\n  }\n\n  get typeName(): string {\n    return \"Gather\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n    container.name = this.name;\n\n    if (this.story.countAllVisits) {\n      container.visitsShouldBeCounted = true;\n    }\n\n    container.countingAtStartOnly = true;\n\n    // A gather can have null content, e.g. it's just purely a line with \"-\"\n    if (this.content) {\n      for (const c of this.content) {\n        container.AddContent(c.runtimeObject);\n      }\n    }\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    if (this.identifier && (this.identifier.name || \"\").length > 0) {\n      context.CheckForNamingCollisions(\n        this,\n        this.identifier,\n        SymbolType.SubFlowAndWeave\n      );\n    }\n  }\n\n  public readonly toString = (): string =>\n    `- ${this.identifier?.name ? \"(\" + this.identifier?.name + \")\" : \"gather\"}`;\n}\n","import { asOrNull, filterUndef } from \"../../../engine/TypeAssertion\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { Identifier } from \"./Identifier\";\nimport { ParsedObject } from \"./Object\";\nimport { Weave } from \"./Weave\";\n\nexport class Path {\n  private _baseTargetLevel: FlowLevel | null;\n  private components: Identifier[] | null;\n\n  get baseTargetLevel() {\n    if (this.baseLevelIsAmbiguous) {\n      return FlowLevel.Story;\n    }\n\n    return this._baseTargetLevel;\n  }\n\n  get baseLevelIsAmbiguous(): boolean {\n    return !this._baseTargetLevel;\n  }\n\n  get firstComponent(): string | null {\n    if (this.components == null || !this.components.length) {\n      return null;\n    }\n\n    return this.components[0].name;\n  }\n\n  get numberOfComponents(): number {\n    return this.components ? this.components.length : 0;\n  }\n\n  private _dotSeparatedComponents: string | null = null;\n\n  get dotSeparatedComponents(): string {\n    if (this._dotSeparatedComponents == null) {\n      this._dotSeparatedComponents = (this.components ? this.components : [])\n        .map((c) => c.name)\n        .filter(filterUndef)\n        .join(\".\");\n    }\n    return this._dotSeparatedComponents;\n  }\n\n  constructor(\n    argOne: FlowLevel | Identifier[] | Identifier,\n    argTwo?: Identifier[]\n  ) {\n    if (Object.values(FlowLevel).includes(argOne as FlowLevel)) {\n      this._baseTargetLevel = argOne as FlowLevel;\n      this.components = argTwo || [];\n    } else if (Array.isArray(argOne)) {\n      this._baseTargetLevel = null;\n      this.components = argOne || [];\n    } else {\n      this._baseTargetLevel = null;\n      this.components = [argOne as Identifier];\n    }\n  }\n\n  get typeName(): string {\n    return \"Path\";\n  }\n\n  public readonly toString = (): string => {\n    if (this.components === null || this.components.length === 0) {\n      if (this.baseTargetLevel === FlowLevel.WeavePoint) {\n        return \"-> <next gather point>\";\n      }\n\n      return \"<invalid Path>\";\n    }\n\n    return `-> ${this.dotSeparatedComponents}`;\n  };\n\n  public readonly ResolveFromContext = (\n    context: ParsedObject\n  ): ParsedObject | null => {\n    if (this.components == null || this.components.length == 0) {\n      return null;\n    }\n\n    // Find base target of path from current context. e.g.\n    //   ==> BASE.sub.sub\n    let baseTargetObject = this.ResolveBaseTarget(context);\n    if (baseTargetObject === null) {\n      return null;\n    }\n\n    // Given base of path, resolve final target by working deeper into hierarchy\n    //  e.g. ==> base.mid.FINAL\n    if (this.components.length > 1) {\n      return this.ResolveTailComponents(baseTargetObject);\n    }\n\n    return baseTargetObject;\n  };\n\n  // Find the root object from the base, i.e. root from:\n  //    root.sub1.sub2\n  public readonly ResolveBaseTarget = (\n    originalContext: ParsedObject\n  ): ParsedObject | null => {\n    const firstComp = this.firstComponent;\n\n    // Work up the ancestry to find the node that has the named object\n    let ancestorContext: ParsedObject | null = originalContext;\n    while (ancestorContext) {\n      // Only allow deep search when searching deeper from original context.\n      // Don't allow search upward *then* downward, since that's searching *everywhere*!\n      // Allowed examples:\n      //  - From an inner gather of a stitch, you should search up to find a knot called 'x'\n      //    at the root of a story, but not a stitch called 'x' in that knot.\n      //  - However, from within a knot, you should be able to find a gather/choice\n      //    anywhere called 'x'\n      // (that latter example is quite loose, but we allow it)\n      const deepSearch: boolean = ancestorContext === originalContext;\n\n      const foundBase = this.GetChildFromContext(\n        ancestorContext,\n        firstComp,\n        null,\n        deepSearch\n      );\n\n      if (foundBase) {\n        return foundBase;\n      }\n\n      ancestorContext = ancestorContext.parent;\n    }\n\n    return null;\n  };\n\n  // Find the final child from path given root, i.e.:\n  //   root.sub.finalChild\n  public readonly ResolveTailComponents = (\n    rootTarget: ParsedObject\n  ): ParsedObject | null => {\n    let foundComponent: ParsedObject | null = rootTarget;\n\n    if (!this.components) return null;\n\n    for (let ii = 1; ii < this.components.length; ++ii) {\n      const compName = this.components[ii].name;\n\n      let minimumExpectedLevel: FlowLevel;\n      let foundFlow = asOrNull(foundComponent, FlowBase);\n      if (foundFlow !== null) {\n        minimumExpectedLevel = (foundFlow.flowLevel + 1) as FlowLevel;\n      } else {\n        minimumExpectedLevel = FlowLevel.WeavePoint;\n      }\n\n      foundComponent = this.GetChildFromContext(\n        foundComponent,\n        compName,\n        minimumExpectedLevel\n      );\n\n      if (foundComponent === null) {\n        break;\n      }\n    }\n\n    return foundComponent;\n  };\n\n  // See whether \"context\" contains a child with a given name at a given flow level\n  // Can either be a named knot/stitch (a FlowBase) or a weave point within a Weave (Choice or Gather)\n  // This function also ignores any other object types that are neither FlowBase nor Weave.\n  // Called from both ResolveBase (force deep) and ResolveTail for the individual components.\n  public readonly GetChildFromContext = (\n    context: ParsedObject,\n    childName: string | null,\n    minimumLevel: FlowLevel | null,\n    forceDeepSearch: boolean = false\n  ): ParsedObject | null => {\n    // null childLevel means that we don't know where to find it\n    const ambiguousChildLevel: boolean = minimumLevel === null;\n\n    // Search for WeavePoint within Weave\n    const weaveContext = asOrNull(context, Weave);\n    if (\n      childName &&\n      weaveContext !== null &&\n      (ambiguousChildLevel || minimumLevel === FlowLevel.WeavePoint)\n    ) {\n      return weaveContext.WeavePointNamed(childName) as ParsedObject;\n    }\n\n    // Search for content within Flow (either a sub-Flow or a WeavePoint)\n    let flowContext = asOrNull(context, FlowBase);\n    if (childName && flowContext !== null) {\n      // When searching within a Knot, allow a deep searches so that\n      // named weave points (choices and gathers) can be found within any stitch\n      // Otherwise, we just search within the immediate object.\n      const shouldDeepSearch =\n        forceDeepSearch || flowContext.flowLevel === FlowLevel.Knot;\n\n      return flowContext.ContentWithNameAtLevel(\n        childName,\n        minimumLevel,\n        shouldDeepSearch\n      );\n    }\n\n    return null;\n  };\n}\n","import { Expression } from \"./Expression/Expression\";\nimport { ParsedObject } from \"./Object\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Void } from \"../../../engine/Void\";\n\nexport class ReturnType extends ParsedObject {\n  public returnedExpression: Expression | null = null;\n\n  constructor(returnedExpression: Expression | null = null) {\n    super();\n\n    if (returnedExpression) {\n      this.returnedExpression = this.AddContent(\n        returnedExpression\n      ) as Expression;\n    }\n  }\n\n  get typeName(): string {\n    return \"ReturnType\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    if (this.returnedExpression) {\n      // Evaluate expression\n      container.AddContent(this.returnedExpression.runtimeObject);\n    } else {\n      // Return Runtime.Void when there's no expression to evaluate\n      // (This evaluation will just add the Void object to the evaluation stack)\n      container.AddContent(RuntimeControlCommand.EvalStart());\n      container.AddContent(new Void());\n      container.AddContent(RuntimeControlCommand.EvalEnd());\n    }\n\n    // Then pop the call stack\n    // (the evaluated expression will leave the return value on the evaluation stack)\n    container.AddContent(RuntimeControlCommand.PopFunction());\n\n    return container;\n  };\n}\n","// import { FlowBase } from './FlowBase';\n\nexport function ClosestFlowBase(obj: any): any | null {\n  let ancestor = obj.parent;\n  while (ancestor) {\n    if (ancestor.hasOwnProperty(\"iamFlowbase\") && ancestor.iamFlowbase()) {\n      return ancestor as any;\n    }\n\n    ancestor = ancestor.parent;\n  }\n\n  return null;\n}\n","import { DebugMetadata } from \"../../../engine/DebugMetadata\";\n\nexport class Identifier {\n  public name: string;\n  public debugMetadata: DebugMetadata | null = null;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  get typeName(): string {\n    return \"Identifier\";\n  }\n\n  public static Done(): Identifier {\n    return new Identifier(\"DONE\");\n  }\n\n  public readonly toString = (): string => this.name || \"undefined identifer\";\n}\n","import { Argument } from \"../Argument\";\nimport { Choice } from \"../Choice\";\nimport { Divert } from \"../Divert/Divert\";\nimport { DivertTarget } from \"../Divert/DivertTarget\";\nimport { FlowLevel } from \"./FlowLevel\";\nimport { Gather } from \"../Gather/Gather\";\nimport { INamedContent } from \"../../../../engine/INamedContent\";\n// import { Knot } from '../Knot';\nimport { ParsedObject } from \"../Object\";\nimport { Path } from \"../Path\";\nimport { ReturnType } from \"../ReturnType\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../../engine/VariableAssignment\";\n//import { Story } from '../Story';\nimport { SymbolType } from \"../SymbolType\";\nimport { VariableAssignment } from \"../Variable/VariableAssignment\";\nimport { Weave } from \"../Weave\";\nimport { ClosestFlowBase } from \"./ClosestFlowBase\";\nimport { Identifier } from \"../Identifier\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\ntype VariableResolveResult = {\n  found: boolean;\n  isGlobal: boolean;\n  isArgument: boolean;\n  isTemporary: boolean;\n  ownerFlow: FlowBase;\n};\n\n// Base class for Knots and Stitches\nexport abstract class FlowBase extends ParsedObject implements INamedContent {\n  public abstract readonly flowLevel: FlowLevel;\n\n  public _rootWeave: Weave | null = null;\n  public _subFlowsByName: Map<string, FlowBase> = new Map();\n  public _startingSubFlowDivert: RuntimeDivert | null = null;\n  public _startingSubFlowRuntime: RuntimeObject | null = null;\n  public _firstChildFlow: FlowBase | null = null;\n  public variableDeclarations: Map<string, VariableAssignment> = new Map();\n\n  get hasParameters() {\n    return this.args !== null && this.args.length > 0;\n  }\n\n  get subFlowsByName() {\n    return this._subFlowsByName;\n  }\n\n  get typeName(): string {\n    if (this.isFunction) {\n      return \"Function\";\n    }\n\n    return String(this.flowLevel);\n  }\n\n  get name(): string | null {\n    return this.identifier?.name || null;\n  }\n\n  public identifier: Identifier | null = null;\n  public args: Argument[] | null = null;\n\n  constructor(\n    identifier: Identifier | null,\n    topLevelObjects: ParsedObject[] | null = null,\n    args: Argument[] | null = null,\n    public readonly isFunction: boolean = false,\n    isIncludedStory: boolean = false\n  ) {\n    super();\n\n    this.identifier = identifier;\n    this.args = args;\n\n    if (topLevelObjects === null) {\n      topLevelObjects = [];\n    }\n\n    // Used by story to add includes\n    this.PreProcessTopLevelObjects(topLevelObjects);\n\n    topLevelObjects = this.SplitWeaveAndSubFlowContent(\n      topLevelObjects,\n      this.GetType() == \"Story\" && !isIncludedStory\n    );\n\n    this.AddContent(topLevelObjects);\n  }\n\n  public iamFlowbase = () => true;\n\n  public readonly SplitWeaveAndSubFlowContent = (\n    contentObjs: ParsedObject[],\n    isRootStory: boolean\n  ): ParsedObject[] => {\n    const weaveObjs: ParsedObject[] = [];\n    const subFlowObjs: ParsedObject[] = [];\n\n    this._subFlowsByName = new Map();\n\n    for (const obj of contentObjs) {\n      const subFlow = asOrNull(obj, FlowBase);\n      if (subFlow) {\n        if (this._firstChildFlow === null) {\n          this._firstChildFlow = subFlow;\n        }\n\n        subFlowObjs.push(obj);\n        if (subFlow.identifier?.name) {\n          this._subFlowsByName.set(subFlow.identifier?.name, subFlow);\n        }\n      } else {\n        weaveObjs.push(obj);\n      }\n    }\n\n    // Implicit final gather in top level story for ending without warning that you run out of content\n    if (isRootStory) {\n      weaveObjs.push(\n        new Gather(null, 1),\n        new Divert(new Path(Identifier.Done()))\n      );\n    }\n\n    const finalContent: ParsedObject[] = [];\n\n    if (weaveObjs.length > 0) {\n      this._rootWeave = new Weave(weaveObjs, 0);\n      finalContent.push(this._rootWeave);\n    }\n\n    if (subFlowObjs.length > 0) {\n      finalContent.push(...subFlowObjs);\n    }\n    return finalContent;\n  };\n\n  public PreProcessTopLevelObjects(_: ParsedObject[]): void {\n    // empty by default, used by Story to process included file references\n  }\n\n  public VariableResolveResult?: VariableResolveResult | null | undefined;\n\n  public ResolveVariableWithName = (\n    varName: string,\n    fromNode: ParsedObject\n  ): VariableResolveResult => {\n    const result: VariableResolveResult = {} as any;\n\n    // Search in the stitch / knot that owns the node first\n    const ownerFlow = fromNode === null ? this : ClosestFlowBase(fromNode);\n\n    if (ownerFlow) {\n      // Argument\n      if (ownerFlow.args !== null) {\n        for (const arg of ownerFlow.args) {\n          if (arg.identifier?.name === varName) {\n            result.found = true;\n            result.isArgument = true;\n            result.ownerFlow = ownerFlow;\n            return result;\n          }\n        }\n      }\n\n      // Temp\n      if (\n        ownerFlow !== this.story &&\n        ownerFlow.variableDeclarations.has(varName)\n      ) {\n        result.found = true;\n        result.ownerFlow = ownerFlow;\n        result.isTemporary = true;\n\n        return result;\n      }\n    }\n\n    // Global\n    if (this.story.variableDeclarations.has(varName)) {\n      result.found = true;\n      result.ownerFlow = this.story;\n      result.isGlobal = true;\n\n      return result;\n    }\n\n    result.found = false;\n\n    return result;\n  };\n\n  public AddNewVariableDeclaration = (varDecl: VariableAssignment): void => {\n    const varName = varDecl.variableName;\n    if (this.variableDeclarations.has(varName)) {\n      const varab = this.variableDeclarations.get(varName)!;\n      let prevDeclError = \"\";\n      const debugMetadata = varab.debugMetadata;\n      if (debugMetadata) {\n        prevDeclError = ` (${varab.debugMetadata})`;\n      }\n\n      this.Error(\n        `found declaration variable '${varName}' that was already declared${prevDeclError}`,\n        varDecl,\n        false\n      );\n\n      return;\n    }\n\n    this.variableDeclarations.set(varDecl.variableName, varDecl);\n  };\n\n  public ResolveWeavePointNaming = (): void => {\n    // Find all weave points and organise them by name ready for\n    // diverting. Also detect naming collisions.\n    if (this._rootWeave) {\n      this._rootWeave.ResolveWeavePointNaming();\n    }\n\n    for (const [, value] of this._subFlowsByName) {\n      if (value.hasOwnProperty(\"ResolveWeavePointNaming\")) {\n        value.ResolveWeavePointNaming();\n      }\n    }\n  };\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    let foundReturn: ReturnType | null = null;\n    if (this.isFunction) {\n      this.CheckForDisallowedFunctionFlowControl();\n    } else if (\n      this.flowLevel === FlowLevel.Knot ||\n      this.flowLevel === FlowLevel.Stitch\n    ) {\n      // Non-functon: Make sure knots and stitches don't attempt to use Return statement\n      foundReturn = this.Find(ReturnType)();\n\n      if (foundReturn !== null) {\n        this.Error(\n          `Return statements can only be used in knots that are declared as functions: == function ${this.identifier} ==`,\n          foundReturn\n        );\n      }\n    }\n\n    const container = new RuntimeContainer();\n    container.name = this.identifier?.name as string;\n\n    if (this.story.countAllVisits) {\n      container.visitsShouldBeCounted = true;\n    }\n\n    this.GenerateArgumentVariableAssignments(container);\n\n    // Run through content defined for this knot/stitch:\n    //  - First of all, any initial content before a sub-stitch\n    //    or any weave content is added to the main content container\n    //  - The first inner knot/stitch is automatically entered, while\n    //    the others are only accessible by an explicit divert\n    //       - The exception to this rule is if the knot/stitch takes\n    //         parameters, in which case it can't be auto-entered.\n    //  - Any Choices and Gathers (i.e. IWeavePoint) found are\n    //    processsed by GenerateFlowContent.\n    let contentIdx: number = 0;\n    while (this.content !== null && contentIdx < this.content.length) {\n      const obj: ParsedObject = this.content[contentIdx];\n\n      // Inner knots and stitches\n      if (obj instanceof FlowBase) {\n        const childFlow: FlowBase = obj;\n        const childFlowRuntime = childFlow.runtimeObject;\n\n        // First inner stitch - automatically step into it\n        // 20/09/2016 - let's not auto step into knots\n        if (\n          contentIdx === 0 &&\n          !childFlow.hasParameters &&\n          this.flowLevel === FlowLevel.Knot\n        ) {\n          this._startingSubFlowDivert = new RuntimeDivert();\n          container.AddContent(this._startingSubFlowDivert);\n          this._startingSubFlowRuntime = childFlowRuntime;\n        }\n\n        // Check for duplicate knots/stitches with same name\n        const namedChild = childFlowRuntime as RuntimeObject & INamedContent;\n        const existingChild: INamedContent | null =\n          container.namedContent.get(namedChild.name!) || null;\n\n        if (existingChild) {\n          const errorMsg = `${this.GetType()} already contains flow named '${\n            namedChild.name\n          }' (at ${(existingChild as any as RuntimeObject).debugMetadata})`;\n          this.Error(errorMsg, childFlow);\n        }\n\n        container.AddToNamedContentOnly(namedChild);\n      } else if (obj) {\n        // Other content (including entire Weaves that were grouped in the constructor)\n        // At the time of writing, all FlowBases have a maximum of one piece of \"other content\"\n        // and it's always the root Weave\n        container.AddContent(obj.runtimeObject);\n      }\n\n      contentIdx += 1;\n    }\n\n    // CHECK FOR FINAL LOOSE ENDS!\n    // Notes:\n    //  - Functions don't need to terminate - they just implicitly return\n    //  - If return statement was found, don't continue finding warnings for missing control flow,\n    // since it's likely that a return statement has been used instead of a ->-> or something,\n    // or the writer failed to mark the knot as a function.\n    //  - _rootWeave may be null if it's a knot that only has stitches\n    if (\n      this.flowLevel !== FlowLevel.Story &&\n      !this.isFunction &&\n      this._rootWeave !== null &&\n      foundReturn === null\n    ) {\n      this._rootWeave.ValidateTermination(this.WarningInTermination);\n    }\n\n    return container;\n  };\n\n  public readonly GenerateArgumentVariableAssignments = (\n    container: RuntimeContainer\n  ): void => {\n    if (this.args === null || this.args.length === 0) {\n      return;\n    }\n\n    // Assign parameters in reverse since they'll be popped off the evaluation stack\n    // No need to generate EvalStart and EvalEnd since there's nothing being pushed\n    // back onto the evaluation stack.\n    for (let ii = this.args.length - 1; ii >= 0; --ii) {\n      const paramName = this.args[ii].identifier?.name || null;\n      const assign = new RuntimeVariableAssignment(paramName, true);\n      container.AddContent(assign);\n    }\n  };\n\n  public readonly ContentWithNameAtLevel = (\n    name: string,\n    level: FlowLevel | null = null,\n    deepSearch: boolean = false\n  ): ParsedObject | null => {\n    // Referencing self?\n    if (level === this.flowLevel || level === null) {\n      if (name === this.identifier?.name) {\n        return this;\n      }\n    }\n\n    if (level === FlowLevel.WeavePoint || level === null) {\n      let weavePointResult: ParsedObject | null = null;\n\n      if (this._rootWeave) {\n        weavePointResult = this._rootWeave.WeavePointNamed(\n          name\n        ) as ParsedObject;\n        if (weavePointResult) {\n          return weavePointResult;\n        }\n      }\n\n      // Stop now if we only wanted a result if it's a weave point?\n      if (level === FlowLevel.WeavePoint) {\n        return deepSearch ? this.DeepSearchForAnyLevelContent(name) : null;\n      }\n    }\n\n    // If this flow would be incapable of containing the requested level, early out\n    // (e.g. asking for a Knot from a Stitch)\n    if (level !== null && level < this.flowLevel) {\n      return null;\n    }\n\n    let subFlow: FlowBase | null = this._subFlowsByName.get(name) || null;\n\n    if (subFlow && (level === null || level === subFlow.flowLevel)) {\n      return subFlow;\n    }\n\n    return deepSearch ? this.DeepSearchForAnyLevelContent(name) : null;\n  };\n\n  public readonly DeepSearchForAnyLevelContent = (name: string) => {\n    const weaveResultSelf = this.ContentWithNameAtLevel(\n      name,\n      FlowLevel.WeavePoint,\n      false\n    );\n\n    if (weaveResultSelf) {\n      return weaveResultSelf;\n    }\n\n    for (const [, value] of this._subFlowsByName) {\n      const deepResult = value.ContentWithNameAtLevel(name, null, true);\n\n      if (deepResult) {\n        return deepResult;\n      }\n    }\n\n    return null;\n  };\n\n  public ResolveReferences(context: any): void {\n    if (this._startingSubFlowDivert) {\n      if (!this._startingSubFlowRuntime) {\n        throw new Error();\n      }\n\n      this._startingSubFlowDivert.targetPath =\n        this._startingSubFlowRuntime.path;\n    }\n\n    super.ResolveReferences(context);\n\n    // Check validity of parameter names\n    if (this.args !== null) {\n      for (const arg of this.args) {\n        context.CheckForNamingCollisions(\n          this,\n          arg.identifier,\n          SymbolType.Arg,\n          \"argument\"\n        );\n      }\n\n      // Separately, check for duplicate arugment names, since they aren't Parsed.Objects,\n      // so have to be checked independently.\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        for (let jj = ii + 1; jj < this.args.length; jj += 1) {\n          if (\n            this.args[ii].identifier?.name == this.args[jj].identifier?.name\n          ) {\n            this.Error(\n              `Multiple arguments with the same name: '${this.args[ii].identifier}'`\n            );\n          }\n        }\n      }\n    }\n\n    // Check naming collisions for knots and stitches\n    if (this.flowLevel !== FlowLevel.Story) {\n      // Weave points aren't FlowBases, so this will only be knot or stitch\n      const symbolType =\n        this.flowLevel === FlowLevel.Knot\n          ? SymbolType.Knot\n          : SymbolType.SubFlowAndWeave;\n\n      context.CheckForNamingCollisions(this, this.identifier, symbolType);\n    }\n  }\n\n  public readonly CheckForDisallowedFunctionFlowControl = (): void => {\n    // if (!(this instanceof Knot)) { // cannont use Knot here because of circular dependancy\n    if (this.flowLevel !== FlowLevel.Knot) {\n      this.Error(\n        \"Functions cannot be stitches - i.e. they should be defined as '== function myFunc ==' rather than internal to another knot.\"\n      );\n    }\n\n    // Not allowed sub-flows\n    for (const [key, value] of this._subFlowsByName) {\n      this.Error(\n        `Functions may not contain stitches, but saw '${key}' within the function '${this.identifier}'`,\n        value\n      );\n    }\n\n    if (!this._rootWeave) {\n      throw new Error();\n    }\n\n    const allDiverts = this._rootWeave.FindAll<Divert>(Divert)();\n    for (const divert of allDiverts) {\n      if (!divert.isFunctionCall && !(divert.parent instanceof DivertTarget)) {\n        this.Error(\n          `Functions may not contain diverts, but saw '${divert}'`,\n          divert\n        );\n      }\n    }\n\n    const allChoices = this._rootWeave.FindAll<Choice>(Choice)();\n    for (const choice of allChoices) {\n      this.Error(\n        `Functions may not contain choices, but saw '${choice}'`,\n        choice\n      );\n    }\n  };\n\n  public readonly WarningInTermination = (terminatingObject: ParsedObject) => {\n    let message: string =\n      \"Apparent loose end exists where the flow runs out. Do you need a '-> DONE' statement, choice or divert?\";\n    if (terminatingObject.parent === this._rootWeave && this._firstChildFlow) {\n      message = `${message} Note that if you intend to enter '${this._firstChildFlow.identifier}' next, you need to divert to it explicitly.`;\n    }\n\n    const terminatingDivert = asOrNull(terminatingObject, Divert);\n    if (terminatingDivert && terminatingDivert.isTunnel) {\n      message += ` When final tunnel to '${terminatingDivert.target} ->' returns it won't have anywhere to go.`;\n    }\n\n    this.Warning(message, terminatingObject);\n  };\n\n  public readonly toString = (): string =>\n    `${this.typeName} '${this.identifier}'`;\n}\n","import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Text } from \"./Text\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\nexport class ContentList extends ParsedObject {\n  public dontFlatten: boolean = false;\n\n  get runtimeContainer(): RuntimeContainer {\n    return this.runtimeObject as RuntimeContainer;\n  }\n\n  constructor(objects?: ParsedObject[], ...moreObjects: ParsedObject[]) {\n    super();\n\n    if (objects) {\n      this.AddContent(objects);\n    }\n\n    if (moreObjects) {\n      this.AddContent(moreObjects);\n    }\n  }\n\n  get typeName(): string {\n    return \"ContentList\";\n  }\n\n  public readonly TrimTrailingWhitespace = (): void => {\n    for (let ii = this.content.length - 1; ii >= 0; --ii) {\n      const text = asOrNull(this.content[ii], Text);\n      if (text === null) {\n        break;\n      }\n\n      text.text = text.text.replace(new RegExp(/[ \\t]/g), \"\");\n      if (text.text.length === 0) {\n        this.content.splice(ii, 1);\n      } else {\n        break;\n      }\n    }\n  };\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n    if (this.content !== null) {\n      for (const obj of this.content) {\n        const contentObjRuntime = obj.runtimeObject;\n\n        // Some objects (e.g. author warnings) don't generate runtime objects\n        if (contentObjRuntime) {\n          container.AddContent(contentObjRuntime);\n        }\n      }\n    }\n\n    if (this.dontFlatten) {\n      this.story.DontFlattenContainer(container);\n    }\n\n    return container;\n  };\n\n  public toString = (): string => `ContentList(${this.content.join(\", \")})`;\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\n\nexport class VariableReference extends InkObject {\n  public name: string | null;\n  public pathForCount: Path | null = null;\n\n  get containerForCount() {\n    if (this.pathForCount === null) return null;\n    return this.ResolvePath(this.pathForCount).container;\n  }\n  get pathStringForCount() {\n    if (this.pathForCount === null) return null;\n\n    return this.CompactPathString(this.pathForCount);\n  }\n  set pathStringForCount(value: string | null) {\n    if (value === null) this.pathForCount = null;\n    else this.pathForCount = new Path(value);\n  }\n\n  constructor(name: string | null = null) {\n    super();\n    this.name = name;\n  }\n\n  public toString() {\n    if (this.name != null) {\n      return \"var(\" + this.name + \")\";\n    } else {\n      let pathStr = this.pathStringForCount;\n      return \"read_count(\" + pathStr + \")\";\n    }\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ContentList } from \"../ContentList\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { ParsedObject } from \"../Object\";\nimport { Path } from \"../Path\";\nimport { Story } from \"../Story\";\nimport { VariableReference as RuntimeVariableReference } from \"../../../../engine/VariableReference\";\nimport { Weave } from \"../Weave\";\nimport { Identifier } from \"../Identifier\";\nimport { asOrNull, filterUndef } from \"../../../../engine/TypeAssertion\";\n\nexport class VariableReference extends Expression {\n  private _runtimeVarRef: RuntimeVariableReference | null = null;\n\n  // - Normal variables have a single item in their \"path\"\n  // - Knot/stitch names for read counts are actual dot-separated paths\n  //   (though this isn't actually used at time of writing)\n  // - List names are dot separated: listName.itemName (or just itemName)\n  get name() {\n    return this.path.join(\".\");\n  }\n\n  get path(): string[] {\n    return this.pathIdentifiers.map((id) => id.name!).filter(filterUndef);\n  }\n\n  get identifier(): Identifier | null {\n    if (!this.pathIdentifiers || this.pathIdentifiers.length == 0) {\n      return null;\n    }\n    const name = this.path.join(\".\");\n    const id = new Identifier(name);\n\n    return id;\n  }\n\n  // Only known after GenerateIntoContainer has run\n  public isConstantReference: boolean = false;\n  public isListItemReference: boolean = false;\n\n  get runtimeVarRef() {\n    return this._runtimeVarRef;\n  }\n\n  constructor(public readonly pathIdentifiers: Identifier[]) {\n    super();\n  }\n\n  get typeName(): string {\n    return \"ref\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    let constantValue: Expression | null | undefined = this.story.constants.get(\n      this.name\n    );\n\n    // If it's a constant reference, just generate the literal expression value\n    // It's okay to access the constants at code generation time, since the\n    // first thing the ExportRuntime function does it search for all the constants\n    // in the story hierarchy, so they're all available.\n    if (constantValue) {\n      constantValue.GenerateConstantIntoContainer(container);\n      this.isConstantReference = true;\n\n      return;\n    }\n\n    this._runtimeVarRef = new RuntimeVariableReference(this.name);\n\n    // List item reference?\n    // Path might be to a list (listName.listItemName or just listItemName)\n    if (this.path.length === 1 || this.path.length === 2) {\n      let listItemName: string = \"\";\n      let listName: string = \"\";\n\n      if (this.path.length === 1) {\n        listItemName = this.path[0];\n      } else {\n        listName = this.path[0];\n        listItemName = this.path[1];\n      }\n\n      const listItem = this.story.ResolveListItem(listName, listItemName, this);\n\n      if (listItem) {\n        this.isListItemReference = true;\n      }\n    }\n\n    container.AddContent(this._runtimeVarRef);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // Work is already done if it's a constant or list item reference\n    if (this.isConstantReference || this.isListItemReference) {\n      return;\n    }\n\n    // Is it a read count?\n    const parsedPath = new Path(this.pathIdentifiers);\n    const targetForCount: ParsedObject | null =\n      parsedPath.ResolveFromContext(this);\n    if (targetForCount) {\n      if (!targetForCount.containerForCounting) {\n        throw new Error();\n      }\n\n      targetForCount.containerForCounting.visitsShouldBeCounted = true;\n\n      // If this is an argument to a function that wants a variable to be\n      // passed by reference, then the Parsed.Divert will have generated a\n      // Runtime.VariablePointerValue instead of allowing this object\n      // to generate its RuntimeVariableReference. This only happens under\n      // error condition since we shouldn't be passing a read count by\n      // reference, but we don't want it to crash!\n      if (this._runtimeVarRef === null) {\n        return;\n      }\n\n      this._runtimeVarRef.pathForCount = targetForCount.runtimePath;\n      this._runtimeVarRef.name = null;\n\n      // Check for very specific writer error: getting read count and\n      // printing it as content rather than as a piece of logic\n      // e.g. Writing {myFunc} instead of {myFunc()}\n      let targetFlow = asOrNull(targetForCount, FlowBase);\n      if (targetFlow && targetFlow.isFunction) {\n        // Is parent context content rather than logic?\n        if (\n          this.parent instanceof Weave ||\n          this.parent instanceof ContentList ||\n          this.parent instanceof FlowBase\n        ) {\n          this.Warning(\n            `'${targetFlow.identifier}' being used as read count rather than being called as function. Perhaps you intended to write ${targetFlow.identifier}()`\n          );\n        }\n      }\n\n      return;\n    }\n\n    // Couldn't find this multi-part path at all, whether as a divert\n    // target or as a list item reference.\n    if (this.path.length > 1) {\n      let errorMsg = `Could not find target for read count: ${parsedPath}`;\n      if (this.path.length <= 2) {\n        errorMsg += `, or couldn't find list item with the name ${this.path.join(\n          \",\"\n        )}`;\n      }\n\n      this.Error(errorMsg);\n\n      return;\n    }\n\n    if (!context.ResolveVariableWithName(this.name, this).found) {\n      this.Error(`Unresolved variable: ${this.name}`, this);\n    }\n  }\n\n  public readonly toString = (): string => `{${this.path.join(\".\")}}`;\n}\n","﻿import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { Divert } from \"./Divert/Divert\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTarget } from \"./Divert/DivertTarget\";\nimport { Expression } from \"./Expression/Expression\";\nimport { InkList as RuntimeInkList } from \"../../../engine/InkList\";\nimport { ListValue } from \"../../../engine/Value\";\nimport { NativeFunctionCall } from \"../../../engine/NativeFunctionCall\";\nimport { NumberExpression } from \"./Expression/NumberExpression\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { StringValue } from \"../../../engine/Value\";\nimport { VariableReference } from \"./Variable/VariableReference\";\nimport { Identifier } from \"./Identifier\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\nexport class FunctionCall extends Expression {\n  public static readonly IsBuiltIn = (name: string): boolean => {\n    if (NativeFunctionCall.CallExistsWithName(name)) {\n      return true;\n    }\n\n    return (\n      name === \"CHOICE_COUNT\" ||\n      name === \"TURNS_SINCE\" ||\n      name === \"TURNS\" ||\n      name === \"RANDOM\" ||\n      name === \"SEED_RANDOM\" ||\n      name === \"LIST_VALUE\" ||\n      name === \"LIST_RANDOM\" ||\n      name === \"READ_COUNT\"\n    );\n  };\n\n  private _proxyDivert: Divert;\n  get proxyDivert(): Divert {\n    return this._proxyDivert;\n  }\n  private _divertTargetToCount: DivertTarget | null = null;\n  private _variableReferenceToCount: VariableReference | null = null;\n\n  get name(): string {\n    return (this._proxyDivert.target as Path).firstComponent || \"\";\n  }\n\n  get args(): Expression[] {\n    return this._proxyDivert.args;\n  }\n\n  get runtimeDivert(): RuntimeDivert {\n    return this._proxyDivert.runtimeDivert;\n  }\n\n  get isChoiceCount(): boolean {\n    return this.name === \"CHOICE_COUNT\";\n  }\n\n  get isTurns(): boolean {\n    return this.name === \"TURNS\";\n  }\n\n  get isTurnsSince(): boolean {\n    return this.name === \"TURNS_SINCE\";\n  }\n\n  get isRandom(): boolean {\n    return this.name === \"RANDOM\";\n  }\n\n  get isSeedRandom(): boolean {\n    return this.name === \"SEED_RANDOM\";\n  }\n\n  get isListRange(): boolean {\n    return this.name === \"LIST_RANGE\";\n  }\n\n  get isListRandom(): boolean {\n    return this.name === \"LIST_RANDOM\";\n  }\n\n  get isReadCount(): boolean {\n    return this.name === \"READ_COUNT\";\n  }\n\n  public shouldPopReturnedValue: boolean = false;\n\n  constructor(functionName: Identifier, args: Expression[]) {\n    super();\n\n    this._proxyDivert = new Divert(new Path(functionName), args);\n    this._proxyDivert.isFunctionCall = true;\n    this.AddContent(this._proxyDivert);\n  }\n\n  get typeName(): string {\n    return \"FunctionCall\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    const foundList = this.story.ResolveList(this.name);\n\n    let usingProxyDivert: boolean = false;\n\n    if (this.isChoiceCount) {\n      if (this.args.length > 0) {\n        this.Error(\"The CHOICE_COUNT() function shouldn't take any arguments\");\n      }\n\n      container.AddContent(RuntimeControlCommand.ChoiceCount());\n    } else if (this.isTurns) {\n      if (this.args.length > 0) {\n        this.Error(\"The TURNS() function shouldn't take any arguments\");\n      }\n\n      container.AddContent(RuntimeControlCommand.Turns());\n    } else if (this.isTurnsSince || this.isReadCount) {\n      const divertTarget = asOrNull(this.args[0], DivertTarget);\n      const variableDivertTarget = asOrNull(this.args[0], VariableReference);\n\n      if (\n        this.args.length !== 1 ||\n        (divertTarget === null && variableDivertTarget === null)\n      ) {\n        this.Error(\n          `The ${this.name}() function should take one argument: a divert target to the target knot, stitch, gather or choice you want to check. e.g. TURNS_SINCE(-> myKnot)`\n        );\n        return;\n      }\n\n      if (divertTarget) {\n        this._divertTargetToCount = divertTarget;\n        this.AddContent(this._divertTargetToCount);\n\n        this._divertTargetToCount.GenerateIntoContainer(container);\n      } else if (variableDivertTarget) {\n        this._variableReferenceToCount = variableDivertTarget;\n        this.AddContent(this._variableReferenceToCount);\n\n        this._variableReferenceToCount.GenerateIntoContainer(container);\n      }\n\n      if (this.isTurnsSince) {\n        container.AddContent(RuntimeControlCommand.TurnsSince());\n      } else {\n        container.AddContent(RuntimeControlCommand.ReadCount());\n      }\n    } else if (this.isRandom) {\n      if (this.args.length !== 2) {\n        this.Error(\n          \"RANDOM should take 2 parameters: a minimum and a maximum integer\"\n        );\n      }\n\n      // We can type check single values, but not complex expressions\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        const num = asOrNull(this.args[ii], NumberExpression);\n        if (num && !num.isInt()) {\n          const paramName: string = ii === 0 ? \"minimum\" : \"maximum\";\n          this.Error(`RANDOM's ${paramName} parameter should be an integer`);\n        }\n\n        this.args[ii].GenerateIntoContainer(container);\n      }\n\n      container.AddContent(RuntimeControlCommand.Random());\n    } else if (this.isSeedRandom) {\n      if (this.args.length !== 1) {\n        this.Error(\"SEED_RANDOM should take 1 parameter - an integer seed\");\n      }\n\n      const num = asOrNull(this.args[0], NumberExpression);\n      if (num && !num.isInt()) {\n        this.Error(\"SEED_RANDOM's parameter should be an integer seed\");\n      }\n\n      this.args[0].GenerateIntoContainer(container);\n\n      container.AddContent(RuntimeControlCommand.SeedRandom());\n    } else if (this.isListRange) {\n      if (this.args.length !== 3) {\n        this.Error(\n          \"LIST_RANGE should take 3 parameters - a list, a min and a max\"\n        );\n      }\n\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        this.args[ii].GenerateIntoContainer(container);\n      }\n\n      container.AddContent(RuntimeControlCommand.ListRange());\n    } else if (this.isListRandom) {\n      if (this.args.length !== 1) {\n        this.Error(\"LIST_RANDOM should take 1 parameter - a list\");\n      }\n\n      this.args[0].GenerateIntoContainer(container);\n\n      container.AddContent(RuntimeControlCommand.ListRandom());\n    } else if (NativeFunctionCall.CallExistsWithName(this.name)) {\n      const nativeCall = NativeFunctionCall.CallWithName(this.name);\n      if (nativeCall.numberOfParameters !== this.args.length) {\n        let msg = `${name} should take ${nativeCall.numberOfParameters} parameter`;\n        if (nativeCall.numberOfParameters > 1) {\n          msg += \"s\";\n        }\n\n        this.Error(msg);\n      }\n\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        this.args[ii].GenerateIntoContainer(container);\n      }\n\n      container.AddContent(NativeFunctionCall.CallWithName(this.name));\n    } else if (foundList !== null) {\n      if (this.args.length > 1) {\n        this.Error(\n          \"Can currently only construct a list from one integer (or an empty list from a given list definition)\"\n        );\n      }\n\n      // List item from given int\n      if (this.args.length === 1) {\n        container.AddContent(new StringValue(this.name));\n        this.args[0].GenerateIntoContainer(container);\n        container.AddContent(RuntimeControlCommand.ListFromInt());\n      } else {\n        // Empty list with given origin.\n        const list = new RuntimeInkList();\n        list.SetInitialOriginName(this.name);\n        container.AddContent(new ListValue(list));\n      }\n    } else {\n      // Normal function call\n      container.AddContent(this._proxyDivert.runtimeObject);\n      usingProxyDivert = true;\n    }\n\n    // Don't attempt to resolve as a divert if we're not doing a normal function call\n    if (!usingProxyDivert) {\n      this.content.splice(this.content.indexOf(this._proxyDivert), 1);\n    }\n\n    // Function calls that are used alone on a tilda-based line:\n    //  ~ func()\n    // Should tidy up any returned value from the evaluation stack,\n    // since it's unused.\n    if (this.shouldPopReturnedValue) {\n      container.AddContent(RuntimeControlCommand.PopEvaluatedValue());\n    }\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // If we aren't using the proxy divert after all (e.g. if\n    // it's a native function call), but we still have arguments,\n    // we need to make sure they get resolved since the proxy divert\n    // is no longer in the content array.\n    if (!this.content.includes(this._proxyDivert) && this.args !== null) {\n      for (const arg of this.args) {\n        arg.ResolveReferences(context);\n      }\n    }\n\n    if (this._divertTargetToCount) {\n      const divert = this._divertTargetToCount.divert;\n      const attemptingTurnCountOfVariableTarget =\n        divert.runtimeDivert.variableDivertName != null;\n\n      if (attemptingTurnCountOfVariableTarget) {\n        this.Error(\n          `When getting the TURNS_SINCE() of a variable target, remove the '->' - i.e. it should just be TURNS_SINCE(${divert.runtimeDivert.variableDivertName})`\n        );\n\n        return;\n      }\n\n      const targetObject = divert.targetContent;\n      if (targetObject === null) {\n        if (!attemptingTurnCountOfVariableTarget) {\n          this.Error(\n            `Failed to find target for TURNS_SINCE: '${divert.target}'`\n          );\n        }\n      } else {\n        if (!targetObject.containerForCounting) {\n          throw new Error();\n        }\n\n        targetObject.containerForCounting.turnIndexShouldBeCounted = true;\n      }\n    } else if (this._variableReferenceToCount) {\n      const runtimeVarRef = this._variableReferenceToCount.runtimeVarRef;\n      if (!runtimeVarRef) {\n        throw new Error();\n      }\n\n      if (runtimeVarRef.pathForCount !== null) {\n        this.Error(\n          `Should be '${name}'(-> '${this._variableReferenceToCount.name}). Usage without the '->' only makes sense for variable targets.`\n        );\n      }\n    }\n  }\n\n  public readonly toString = (): string => {\n    const strArgs = this.args.join(\", \");\n    return `${this.name}(${strArgs})`;\n  };\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\n\nexport class MultipleConditionExpression extends Expression {\n  get subExpressions(): Expression[] {\n    return this.content as Expression[];\n  }\n\n  constructor(conditionExpressions: Expression[]) {\n    super();\n\n    this.AddContent(conditionExpressions);\n  }\n\n  get typeName(): string {\n    return \"MultipleConditionExpression\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    //    A && B && C && D\n    // => (((A B &&) C &&) D &&) etc\n    let isFirst: boolean = true;\n    for (const conditionExpr of this.subExpressions) {\n      conditionExpr.GenerateIntoContainer(container);\n\n      if (!isFirst) {\n        container.AddContent(NativeFunctionCall.CallWithName(\"&&\"));\n      }\n\n      isFirst = false;\n    }\n  };\n}\n","﻿import { BinaryExpression } from \"../Expression/BinaryExpression\";\nimport { Choice } from \"../Choice\";\nimport { Conditional } from \"../Conditional/Conditional\";\nimport { ConditionalSingleBranch } from \"../Conditional/ConditionalSingleBranch\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ParsedObject } from \"../Object\";\nimport { Divert } from \"./Divert\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { DivertTargetValue } from \"../../../../engine/Value\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { FunctionCall } from \"../FunctionCall\";\nimport { MultipleConditionExpression } from \"../Expression/MultipleConditionExpression\";\nimport { Story } from \"../Story\";\nimport { VariableReference } from \"../Variable/VariableReference\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class DivertTarget extends Expression {\n  private _runtimeDivert: RuntimeDivert | null = null;\n  get runtimeDivert(): RuntimeDivert {\n    if (!this._runtimeDivert) {\n      throw new Error();\n    }\n\n    return this._runtimeDivert;\n  }\n\n  private _runtimeDivertTargetValue: DivertTargetValue | null = null;\n  get runtimeDivertTargetValue(): DivertTargetValue {\n    if (!this._runtimeDivertTargetValue) {\n      throw new Error();\n    }\n\n    return this._runtimeDivertTargetValue;\n  }\n\n  public divert: Divert;\n\n  constructor(divert: Divert) {\n    super();\n\n    this.divert = this.AddContent(divert) as Divert;\n  }\n\n  get typeName(): string {\n    return \"DivertTarget\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    this.divert.GenerateRuntimeObject();\n\n    this._runtimeDivert = this.divert.runtimeDivert as RuntimeDivert;\n    this._runtimeDivertTargetValue = new DivertTargetValue();\n\n    container.AddContent(this.runtimeDivertTargetValue);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    if (this.divert.isDone || this.divert.isEnd) {\n      this.Error(\n        `Can't use -> DONE or -> END as variable divert targets`,\n        this\n      );\n\n      return;\n    }\n\n    let usageContext: ParsedObject | null = this;\n    while (usageContext && usageContext instanceof Expression) {\n      let badUsage: boolean = false;\n      let foundUsage: boolean = false;\n\n      const usageParent: any = (usageContext as Expression).parent;\n      if (usageParent instanceof BinaryExpression) {\n        // Only allowed to compare for equality\n\n        const binaryExprParent = usageParent;\n        if (\n          binaryExprParent.opName !== \"==\" &&\n          binaryExprParent.opName !== \"!=\"\n        ) {\n          badUsage = true;\n        } else {\n          if (\n            !(\n              binaryExprParent.leftExpression instanceof DivertTarget ||\n              binaryExprParent.leftExpression instanceof VariableReference\n            )\n          ) {\n            badUsage = true;\n          } else if (\n            !(\n              binaryExprParent.rightExpression instanceof DivertTarget ||\n              binaryExprParent.rightExpression instanceof VariableReference\n            )\n          ) {\n            badUsage = true;\n          }\n        }\n\n        foundUsage = true;\n      } else if (usageParent instanceof FunctionCall) {\n        const funcCall = usageParent;\n        if (!funcCall.isTurnsSince && !funcCall.isReadCount) {\n          badUsage = true;\n        }\n\n        foundUsage = true;\n      } else if (usageParent instanceof Expression) {\n        badUsage = true;\n        foundUsage = true;\n      } else if (usageParent instanceof MultipleConditionExpression) {\n        badUsage = true;\n        foundUsage = true;\n      } else if (\n        usageParent instanceof Choice &&\n        (usageParent as Choice).condition === usageContext\n      ) {\n        badUsage = true;\n        foundUsage = true;\n      } else if (\n        usageParent instanceof Conditional ||\n        usageParent instanceof ConditionalSingleBranch\n      ) {\n        badUsage = true;\n        foundUsage = true;\n      }\n\n      if (badUsage) {\n        this.Error(\n          `Can't use a divert target like that. Did you intend to call '${this.divert.target}' as a function: likeThis(), or check the read count: likeThis, with no arrows?`,\n          this\n        );\n      }\n\n      if (foundUsage) {\n        break;\n      }\n\n      usageContext = usageParent;\n    }\n\n    // Example ink for this case:\n    //\n    //     VAR x = -> blah\n    //\n    // ...which means that \"blah\" is expected to be a literal stitch target rather\n    // than a variable name. We can't really intelligently recover from this (e.g. if blah happens to\n    // contain a divert target itself) since really we should be generating a variable reference\n    // rather than a concrete DivertTarget, so we list it as an error.\n    if (this.runtimeDivert.hasVariableTarget) {\n      if (!this.divert.target) {\n        throw new Error();\n      }\n\n      this.Error(\n        `Since '${this.divert.target.dotSeparatedComponents}' is a variable, it shouldn't be preceded by '->' here.`\n      );\n    }\n\n    // Main resolve\n    this.runtimeDivert.targetPath &&\n      (this.runtimeDivertTargetValue.targetPath =\n        this.runtimeDivert.targetPath);\n\n    // Tell hard coded (yet variable) divert targets that they also need to be counted\n    // TODO: Only detect DivertTargets that are values rather than being used directly for\n    // read or turn counts. Should be able to detect this by looking for other uses of containerForCounting\n    let targetContent = this.divert.targetContent;\n    if (targetContent !== null) {\n      let target = targetContent.containerForCounting;\n      if (target !== null) {\n        // Purpose is known: used directly in TURNS_SINCE(-> divTarg)\n        const parentFunc = asOrNull(this.parent, FunctionCall);\n        if (parentFunc && parentFunc.isTurnsSince) {\n          target.turnIndexShouldBeCounted = true;\n        } else {\n          // Unknown purpose, count everything\n          target.visitsShouldBeCounted = true;\n          target.turnIndexShouldBeCounted = true;\n        }\n      }\n\n      // Unfortunately not possible:\n      // https://github.com/inkle/ink/issues/538\n      //\n      // VAR func = -> double\n      //\n      // === function double(ref x)\n      //    ~ x = x * 2\n      //\n      // Because when generating the parameters for a function\n      // to be called, it needs to know ahead of time when\n      // compiling whether to pass a variable reference or value.\n      //\n      let targetFlow = asOrNull(targetContent, FlowBase);\n      if (targetFlow != null && targetFlow.args !== null) {\n        for (const arg of targetFlow.args) {\n          if (arg.isByReference) {\n            this.Error(\n              `Can't store a divert target to a knot or function that has by-reference arguments ('${targetFlow.identifier}' has 'ref ${arg.identifier}').`\n            );\n          }\n        }\n      }\n    }\n  }\n\n  // Equals override necessary in order to check for CONST multiple definition equality\n  public readonly Equals = (obj: ParsedObject): boolean => {\n    const otherDivTarget = asOrNull(obj, DivertTarget);\n    if (\n      !otherDivTarget ||\n      !this.divert.target ||\n      !otherDivTarget.divert.target\n    ) {\n      return false;\n    }\n\n    const targetStr = this.divert.target.dotSeparatedComponents;\n    const otherTargetStr = otherDivTarget.divert.target.dotSeparatedComponents;\n\n    return targetStr === otherTargetStr;\n  };\n}\n","import { Argument } from \"../Argument\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { DivertTarget } from \"./DivertTarget\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { FunctionCall } from \"../FunctionCall\";\nimport { ParsedObject } from \"../Object\";\nimport { Path } from \"../Path\";\nimport { Path as RuntimePath } from \"../../../../engine/Path\";\nimport { PushPopType } from \"../../../../engine/PushPop\";\nimport { Story } from \"../Story\";\nimport { VariablePointerValue } from \"../../../../engine/Value\";\nimport { VariableReference } from \"../Variable/VariableReference\";\nimport { ClosestFlowBase } from \"../Flow/ClosestFlowBase\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class Divert extends ParsedObject {\n  public readonly args: Expression[] = [];\n\n  public readonly target: Path | null = null;\n  public targetContent: ParsedObject | null = null;\n  private _runtimeDivert: RuntimeDivert | null = null;\n  get runtimeDivert(): RuntimeDivert {\n    if (!this._runtimeDivert) {\n      throw new Error();\n    }\n\n    return this._runtimeDivert;\n  }\n\n  set runtimeDivert(value: RuntimeDivert) {\n    this._runtimeDivert = value;\n  }\n\n  public isFunctionCall: boolean = false;\n  public isEmpty: boolean = false;\n  public isTunnel: boolean = false;\n  public isThread: boolean = false;\n\n  get isEnd(): boolean {\n    return Boolean(this.target && this.target.dotSeparatedComponents === \"END\");\n  }\n\n  get isDone(): boolean {\n    return Boolean(\n      this.target && this.target.dotSeparatedComponents === \"DONE\"\n    );\n  }\n\n  constructor(target?: Path | null | undefined, args?: Expression[]) {\n    super();\n\n    if (target) {\n      this.target = target;\n    }\n\n    if (args) {\n      this.args = args;\n      this.AddContent(args);\n    }\n  }\n\n  get typeName(): string {\n    return \"Divert\";\n  }\n\n  public readonly GenerateRuntimeObject = () => {\n    // End = end flow immediately\n    // Done = return from thread or instruct the flow that it's safe to exit\n    if (this.isEnd) {\n      return RuntimeControlCommand.End();\n    } else if (this.isDone) {\n      return RuntimeControlCommand.Done();\n    }\n\n    this.runtimeDivert = new RuntimeDivert();\n\n    // Normally we resolve the target content during the\n    // Resolve phase, since we expect all runtime objects to\n    // be available in order to find the final runtime path for\n    // the destination. However, we need to resolve the target\n    // (albeit without the runtime target) early so that\n    // we can get information about the arguments - whether\n    // they're by reference - since it affects the code we\n    // generate here.\n    this.ResolveTargetContent();\n\n    this.CheckArgumentValidity();\n\n    // Passing arguments to the knot\n    const requiresArgCodeGen = this.args !== null && this.args.length > 0;\n    if (\n      requiresArgCodeGen ||\n      this.isFunctionCall ||\n      this.isTunnel ||\n      this.isThread\n    ) {\n      const container = new RuntimeContainer();\n\n      // Generate code for argument evaluation\n      // This argument generation is coded defensively - it should\n      // attempt to generate the code for all the parameters, even if\n      // they don't match the expected arguments. This is so that the\n      // parameter objects themselves are generated correctly and don't\n      // get into a state of attempting to resolve references etc\n      // without being generated.\n      if (requiresArgCodeGen) {\n        // Function calls already in an evaluation context\n        if (!this.isFunctionCall) {\n          container.AddContent(RuntimeControlCommand.EvalStart());\n        }\n\n        let targetArguments: Argument[] | null = null;\n        if (this.targetContent) {\n          targetArguments = (this.targetContent as FlowBase).args;\n        }\n\n        for (let ii = 0; ii < this.args.length; ++ii) {\n          const argToPass: Expression = this.args[ii];\n          let argExpected: Argument | null = null;\n          if (targetArguments && ii < targetArguments.length) {\n            argExpected = targetArguments[ii];\n          }\n\n          // Pass by reference: argument needs to be a variable reference\n          if (argExpected && argExpected.isByReference) {\n            const varRef = asOrNull(argToPass, VariableReference);\n            if (!varRef) {\n              this.Error(\n                `Expected variable name to pass by reference to 'ref ${argExpected.identifier}' but saw ${argToPass}`\n              );\n\n              break;\n            }\n\n            // Check that we're not attempting to pass a read count by reference\n            const targetPath = new Path(varRef.pathIdentifiers);\n            const targetForCount: ParsedObject | null =\n              targetPath.ResolveFromContext(this);\n            if (targetForCount) {\n              this.Error(\n                `can't pass a read count by reference. '${\n                  targetPath.dotSeparatedComponents\n                }' is a knot/stitch/label, but '${\n                  this.target!.dotSeparatedComponents\n                }' requires the name of a VAR to be passed.`\n              );\n\n              break;\n            }\n\n            const varPointer = new VariablePointerValue(varRef.name);\n            container.AddContent(varPointer);\n          } else {\n            // Normal value being passed: evaluate it as normal\n            argToPass.GenerateIntoContainer(container);\n          }\n        }\n\n        // Function calls were already in an evaluation context\n        if (!this.isFunctionCall) {\n          container.AddContent(RuntimeControlCommand.EvalEnd());\n        }\n      }\n\n      // Starting a thread? A bit like a push to the call stack below... but not.\n      // It sort of puts the call stack on a thread stack (argh!) - forks the full flow.\n      if (this.isThread) {\n        container.AddContent(RuntimeControlCommand.StartThread());\n      } else if (this.isFunctionCall || this.isTunnel) {\n        // If this divert is a function call, tunnel, we push to the call stack\n        // so we can return again\n        this.runtimeDivert.pushesToStack = true;\n        this.runtimeDivert.stackPushType = this.isFunctionCall\n          ? PushPopType.Function\n          : PushPopType.Tunnel;\n      }\n\n      // Jump into the \"function\" (knot/stitch)\n      container.AddContent(this.runtimeDivert);\n\n      return container;\n    }\n\n    // Simple divert\n    return this.runtimeDivert;\n  };\n\n  // When the divert is to a target that's actually a variable name\n  // rather than an explicit knot/stitch name, try interpretting it\n  // as such by getting the variable name.\n  public readonly PathAsVariableName = () =>\n    this.target ? this.target.firstComponent : null;\n\n  public readonly ResolveTargetContent = (): void => {\n    if (this.isEmpty || this.isEnd) {\n      return;\n    }\n\n    if (this.targetContent === null) {\n      // Is target of this divert a variable name that will be de-referenced\n      // at runtime? If so, there won't be any further reference resolution\n      // we can do at this point.\n      let variableTargetName = this.PathAsVariableName();\n      if (variableTargetName !== null) {\n        const flowBaseScope = asOrNull(ClosestFlowBase(this), FlowBase);\n        if (flowBaseScope) {\n          const resolveResult = flowBaseScope.ResolveVariableWithName(\n            variableTargetName,\n            this\n          );\n\n          if (resolveResult.found) {\n            // Make sure that the flow was typed correctly, given that we know that this\n            // is meant to be a divert target\n            if (\n              resolveResult.isArgument &&\n              resolveResult.ownerFlow &&\n              resolveResult.ownerFlow.args\n            ) {\n              let argument = resolveResult.ownerFlow.args.find(\n                (a) => a.identifier?.name == variableTargetName\n              );\n\n              if (argument && !argument.isDivertTarget) {\n                this.Error(\n                  `Since '${argument.identifier}' is used as a variable divert target (on ${this.debugMetadata}), it should be marked as: -> ${argument.identifier}`,\n                  resolveResult.ownerFlow\n                );\n              }\n            }\n\n            this.runtimeDivert.variableDivertName = variableTargetName;\n            return;\n          }\n        }\n      }\n\n      if (!this.target) {\n        throw new Error();\n      }\n\n      this.targetContent = this.target.ResolveFromContext(this);\n    }\n  };\n\n  public ResolveReferences(context: Story): void {\n    if (this.isEmpty || this.isEnd || this.isDone) {\n      return;\n    } else if (!this.runtimeDivert) {\n      throw new Error();\n    }\n\n    if (this.targetContent) {\n      this.runtimeDivert.targetPath = this.targetContent.runtimePath;\n    }\n\n    // Resolve children (the arguments)\n    super.ResolveReferences(context);\n\n    // May be null if it's a built in function (e.g. TURNS_SINCE)\n    // or if it's a variable target.\n    let targetFlow = asOrNull(this.targetContent, FlowBase);\n    if (targetFlow) {\n      if (!targetFlow.isFunction && this.isFunctionCall) {\n        super.Error(\n          `${targetFlow.identifier} hasn't been marked as a function, but it's being called as one. Do you need to delcare the knot as '== function ${targetFlow.identifier} =='?`\n        );\n      } else if (\n        targetFlow.isFunction &&\n        !this.isFunctionCall &&\n        !(this.parent instanceof DivertTarget)\n      ) {\n        super.Error(\n          targetFlow.identifier +\n            \" can't be diverted to. It can only be called as a function since it's been marked as such: '\" +\n            targetFlow.identifier +\n            \"(...)'\"\n        );\n      }\n    }\n\n    // Check validity of target content\n    const targetWasFound = this.targetContent !== null;\n    let isBuiltIn: boolean = false;\n    let isExternal: boolean = false;\n\n    if (!this.target) {\n      throw new Error();\n    } else if (this.target.numberOfComponents === 1) {\n      if (!this.target.firstComponent) {\n        throw new Error();\n      }\n\n      // BuiltIn means TURNS_SINCE, CHOICE_COUNT, RANDOM or SEED_RANDOM\n      isBuiltIn = FunctionCall.IsBuiltIn(this.target.firstComponent);\n\n      // Client-bound function?\n      isExternal = context.IsExternal(this.target.firstComponent);\n\n      if (isBuiltIn || isExternal) {\n        if (!this.isFunctionCall) {\n          super.Error(\n            `${this.target.firstComponent} must be called as a function: ~ ${this.target.firstComponent}()`\n          );\n        }\n\n        if (isExternal) {\n          this.runtimeDivert.isExternal = true;\n          if (this.args !== null) {\n            this.runtimeDivert.externalArgs = this.args.length;\n          }\n\n          this.runtimeDivert.pushesToStack = false;\n          this.runtimeDivert.targetPath = new RuntimePath(\n            this.target.firstComponent\n          );\n\n          this.CheckExternalArgumentValidity(context);\n        }\n\n        return;\n      }\n    }\n\n    // Variable target?\n    if (this.runtimeDivert.variableDivertName != null) {\n      return;\n    }\n\n    if (!targetWasFound && !isBuiltIn && !isExternal) {\n      this.Error(`target not found: '${this.target}'`);\n    }\n  }\n\n  // Returns false if there's an error\n  public readonly CheckArgumentValidity = (): void => {\n    if (this.isEmpty) {\n      return;\n    }\n\n    // Argument passing: Check for errors in number of arguments\n    let numArgs = 0;\n    if (this.args !== null && this.args.length > 0) {\n      numArgs = this.args.length;\n    }\n\n    // Missing content?\n    // Can't check arguments properly. It'll be due to some\n    // other error though, so although there's a problem and\n    // we report false, we don't need to report a specific error.\n    // It may also be because it's a valid call to an external\n    // function, that we check at the resolve stage.\n    if (this.targetContent === null) {\n      return;\n    }\n\n    const targetFlow = asOrNull(this.targetContent, FlowBase);\n\n    // No error, crikey!\n    if (numArgs === 0 && (targetFlow === null || !targetFlow.hasParameters)) {\n      return;\n    } else if (targetFlow === null && numArgs > 0) {\n      this.Error(\n        \"target needs to be a knot or stitch in order to pass arguments\"\n      );\n      return;\n    } else if (\n      targetFlow !== null &&\n      (targetFlow.args === null || (!targetFlow.args && numArgs > 0))\n    ) {\n      this.Error(`target (${targetFlow.name}) doesn't take parameters`);\n      return;\n    } else if (this.parent instanceof DivertTarget) {\n      if (numArgs > 0) {\n        this.Error(`can't store arguments in a divert target variable`);\n      }\n\n      return;\n    }\n\n    const paramCount = targetFlow!.args!.length;\n    if (paramCount !== numArgs) {\n      let butClause: string;\n      if (numArgs === 0) {\n        butClause = \"but there weren't any passed to it\";\n      } else if (numArgs < paramCount) {\n        butClause = `but only got ${numArgs}`;\n      } else {\n        butClause = `but got ${numArgs}`;\n      }\n\n      this.Error(\n        `to '${\n          targetFlow!.identifier\n        }' requires ${paramCount} arguments, ${butClause}`\n      );\n\n      return;\n    }\n\n    // Light type-checking for divert target arguments\n    for (let ii = 0; ii < paramCount; ++ii) {\n      const flowArg: Argument = targetFlow!.args![ii];\n      const divArgExpr: Expression = this.args[ii];\n\n      // Expecting a divert target as an argument, let's do some basic type checking\n      if (flowArg.isDivertTarget) {\n        // Not passing a divert target or any kind of variable reference?\n        let varRef = asOrNull(divArgExpr, VariableReference);\n        if (!(divArgExpr instanceof DivertTarget) && varRef === null) {\n          this.Error(\n            `Target '${\n              targetFlow!.identifier\n            }' expects a divert target for the parameter named -> ${\n              flowArg.identifier\n            } but saw ${divArgExpr}`,\n            divArgExpr\n          );\n        } else if (varRef) {\n          // Passing 'a' instead of '-> a'?\n          // i.e. read count instead of divert target\n          // Unfortunately have to manually resolve here since we're still in code gen\n          const knotCountPath = new Path(varRef.pathIdentifiers);\n          const targetForCount: ParsedObject | null =\n            knotCountPath.ResolveFromContext(varRef);\n          if (targetForCount) {\n            this.Error(\n              `Passing read count of '${knotCountPath.dotSeparatedComponents}' instead of a divert target. You probably meant '${knotCountPath}'`\n            );\n          }\n        }\n      }\n    }\n\n    if (targetFlow === null) {\n      this.Error(\n        \"Can't call as a function or with arguments unless it's a knot or stitch\"\n      );\n      return;\n    }\n\n    return;\n  };\n\n  public readonly CheckExternalArgumentValidity = (context: Story): void => {\n    const externalName: string | null = this.target\n      ? this.target.firstComponent\n      : null;\n    const external = context.externals.get(externalName as any);\n    if (!external) {\n      throw new Error(\"external not found\");\n    }\n\n    const externalArgCount: number = external.argumentNames.length;\n    let ownArgCount = 0;\n    if (this.args) {\n      ownArgCount = this.args.length;\n    }\n\n    if (ownArgCount !== externalArgCount) {\n      this.Error(\n        `incorrect number of arguments sent to external function '${externalName}'. Expected ${externalArgCount} but got ${ownArgCount}`\n      );\n    }\n  };\n\n  public Error(\n    message: string,\n    source: ParsedObject | null = null,\n    isWarning: boolean = false\n  ): void {\n    // Could be getting an error from a nested Divert\n    if (source !== this && source) {\n      super.Error(message, source);\n      return;\n    }\n\n    if (this.isFunctionCall) {\n      super.Error(`Function call ${message}`, source, isWarning);\n    } else {\n      super.Error(`Divert ${message}`, source, isWarning);\n    }\n  }\n\n  public toString = (): string => {\n    let returnString = \"\";\n    if (this.target !== null) {\n      returnString += this.target.toString();\n    } else {\n      return \"-> <empty divert>\";\n    }\n\n    if (this.isTunnel) {\n      returnString += \" ->\";\n    }\n    if (this.isFunctionCall) {\n      returnString += \" ()\";\n    }\n\n    return returnString;\n  };\n}\n","import { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\n\nexport class GatherPointToResolve {\n  constructor(\n    public divert: RuntimeDivert,\n    public targetRuntimeObj: RuntimeObject\n  ) {}\n}\n","import { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\n\nexport class SequenceDivertToResolve {\n  constructor(\n    public divert: RuntimeDivert,\n    public targetContent: RuntimeObject\n  ) {}\n}\n","import { ContentList } from \"../ContentList\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { IntValue } from \"../../../../engine/Value\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { SequenceDivertToResolve } from \"./SequenceDivertToResolve\";\nimport { SequenceType } from \"./SequenceType\";\nimport { Story } from \"../Story\";\nimport { Weave } from \"../Weave\";\n\nexport class Sequence extends ParsedObject {\n  private _sequenceDivertsToResolve: SequenceDivertToResolve[] = [];\n\n  public sequenceElements: ParsedObject[];\n\n  constructor(\n    elementContentLists: ContentList[],\n    public readonly sequenceType: SequenceType\n  ) {\n    super();\n\n    this.sequenceType = sequenceType;\n    this.sequenceElements = [];\n\n    for (const elementContentList of elementContentLists) {\n      const contentObjs = elementContentList.content;\n      let seqElObject: ParsedObject | null = null;\n\n      // Don't attempt to create a weave for the sequence element\n      // if the content list is empty. Weaves don't like it!\n      if (contentObjs === null || contentObjs.length === 0) {\n        seqElObject = elementContentList;\n      } else {\n        seqElObject = new Weave(contentObjs);\n      }\n\n      this.sequenceElements.push(seqElObject);\n      this.AddContent(seqElObject);\n    }\n  }\n\n  get typeName(): string {\n    return \"Sequence\";\n  }\n\n  // Generate runtime code that looks like:\n  //\n  //   chosenIndex = MIN(sequence counter, num elements) e.g. for \"Stopping\"\n  //   if chosenIndex == 0, divert to s0\n  //   if chosenIndex == 1, divert to s1  [etc]\n  //\n  //   - s0:\n  //      <content for sequence element>\n  //      divert to no-op\n  //   - s1:\n  //      <content for sequence element>\n  //      divert to no-op\n  //   - s2:\n  //      empty branch if using \"once\"\n  //      divert to no-op\n  //\n  //    no-op\n  //\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n    container.visitsShouldBeCounted = true;\n    container.countingAtStartOnly = true;\n\n    this._sequenceDivertsToResolve = [];\n\n    // Get sequence read count\n    container.AddContent(RuntimeControlCommand.EvalStart());\n    container.AddContent(RuntimeControlCommand.VisitIndex());\n\n    const once: boolean = (this.sequenceType & SequenceType.Once) > 0;\n    const cycle: boolean = (this.sequenceType & SequenceType.Cycle) > 0;\n    const stopping: boolean = (this.sequenceType & SequenceType.Stopping) > 0;\n    const shuffle: boolean = (this.sequenceType & SequenceType.Shuffle) > 0;\n\n    let seqBranchCount = this.sequenceElements.length;\n    if (once) {\n      seqBranchCount += 1;\n    }\n\n    // Chosen sequence index:\n    //  - Stopping: take the MIN(read count, num elements - 1)\n    //  - Once: take the MIN(read count, num elements)\n    //    (the last one being empty)\n    if (stopping || once) {\n      //var limit = stopping ? seqBranchCount-1 : seqBranchCount;\n      container.AddContent(new IntValue(seqBranchCount - 1));\n      container.AddContent(NativeFunctionCall.CallWithName(\"MIN\"));\n    } else if (cycle) {\n      // - Cycle: take (read count % num elements)\n      container.AddContent(new IntValue(this.sequenceElements.length));\n      container.AddContent(NativeFunctionCall.CallWithName(\"%\"));\n    }\n\n    // Shuffle\n    if (shuffle) {\n      // Create point to return to when sequence is complete\n      const postShuffleNoOp = RuntimeControlCommand.NoOp();\n\n      // When visitIndex == lastIdx, we skip the shuffle\n      if (once || stopping) {\n        // if( visitIndex == lastIdx ) -> skipShuffle\n        const lastIdx = stopping\n          ? this.sequenceElements.length - 1\n          : this.sequenceElements.length;\n\n        container.AddContent(RuntimeControlCommand.Duplicate());\n        container.AddContent(new IntValue(lastIdx));\n        container.AddContent(NativeFunctionCall.CallWithName(\"==\"));\n\n        const skipShuffleDivert = new RuntimeDivert();\n        skipShuffleDivert.isConditional = true;\n        container.AddContent(skipShuffleDivert);\n\n        this.AddDivertToResolve(skipShuffleDivert, postShuffleNoOp);\n      }\n\n      // This one's a bit more complex! Choose the index at runtime.\n      let elementCountToShuffle = this.sequenceElements.length;\n      if (stopping) {\n        elementCountToShuffle -= 1;\n      }\n\n      container.AddContent(new IntValue(elementCountToShuffle));\n      container.AddContent(RuntimeControlCommand.SequenceShuffleIndex());\n      if (once || stopping) {\n        container.AddContent(postShuffleNoOp);\n      }\n    }\n\n    container.AddContent(RuntimeControlCommand.EvalEnd());\n\n    // Create point to return to when sequence is complete\n    const postSequenceNoOp = RuntimeControlCommand.NoOp();\n\n    // Each of the main sequence branches, and one extra empty branch if\n    // we have a \"once\" sequence.\n    for (let elIndex = 0; elIndex < seqBranchCount; elIndex += 1) {\n      // This sequence element:\n      //  if( chosenIndex == this index ) divert to this sequence element\n      // duplicate chosen sequence index, since it'll be consumed by \"==\"\n      container.AddContent(RuntimeControlCommand.EvalStart());\n      container.AddContent(RuntimeControlCommand.Duplicate());\n      container.AddContent(new IntValue(elIndex));\n      container.AddContent(NativeFunctionCall.CallWithName(\"==\"));\n      container.AddContent(RuntimeControlCommand.EvalEnd());\n\n      // Divert branch for this sequence element\n      const sequenceDivert = new RuntimeDivert();\n      sequenceDivert.isConditional = true;\n      container.AddContent(sequenceDivert);\n\n      let contentContainerForSequenceBranch: RuntimeContainer;\n\n      // Generate content for this sequence element\n      if (elIndex < this.sequenceElements.length) {\n        const el = this.sequenceElements[elIndex];\n        contentContainerForSequenceBranch =\n          el.runtimeObject as RuntimeContainer;\n      } else {\n        // Final empty branch for \"once\" sequences\n        contentContainerForSequenceBranch = new RuntimeContainer();\n      }\n\n      contentContainerForSequenceBranch.name = `s${elIndex}`;\n      contentContainerForSequenceBranch.InsertContent(\n        RuntimeControlCommand.PopEvaluatedValue(),\n        0\n      );\n\n      // When sequence element is complete, divert back to end of sequence\n      const seqBranchCompleteDivert = new RuntimeDivert();\n      contentContainerForSequenceBranch.AddContent(seqBranchCompleteDivert);\n      container.AddToNamedContentOnly(contentContainerForSequenceBranch);\n\n      // Save the diverts for reference resolution later (in ResolveReferences)\n      this.AddDivertToResolve(\n        sequenceDivert,\n        contentContainerForSequenceBranch\n      );\n      this.AddDivertToResolve(seqBranchCompleteDivert, postSequenceNoOp);\n    }\n\n    container.AddContent(postSequenceNoOp);\n\n    return container;\n  };\n\n  public readonly AddDivertToResolve = (\n    divert: RuntimeDivert,\n    targetContent: RuntimeObject\n  ) => {\n    this._sequenceDivertsToResolve.push(\n      new SequenceDivertToResolve(divert, targetContent)\n    );\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    for (const toResolve of this._sequenceDivertsToResolve) {\n      toResolve.divert.targetPath = toResolve.targetContent.path;\n    }\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { Divert } from \"./Divert/Divert\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTargetValue } from \"../../../engine/Value\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Story } from \"./Story\";\nimport { Void } from \"../../../engine/Void\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\nimport { VariableReference } from \"../../../engine/VariableReference\";\n\nexport class TunnelOnwards extends ParsedObject {\n  private _overrideDivertTarget: DivertTargetValue | null = null;\n\n  private _divertAfter: Divert | null = null;\n  get divertAfter() {\n    return this._divertAfter;\n  }\n\n  set divertAfter(value) {\n    this._divertAfter = value;\n    if (this._divertAfter) {\n      this.AddContent(this._divertAfter);\n    }\n  }\n\n  get typeName(): string {\n    return \"TunnelOnwards\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    // Set override path for tunnel onwards (or nothing)\n    container.AddContent(RuntimeControlCommand.EvalStart());\n\n    if (this.divertAfter) {\n      // Generate runtime object's generated code and steal the arguments runtime code\n      const returnRuntimeObj = this.divertAfter.GenerateRuntimeObject();\n      const returnRuntimeContainer = returnRuntimeObj as RuntimeContainer;\n      if (returnRuntimeContainer) {\n        // Steal all code for generating arguments from the divert\n        const args = this.divertAfter.args;\n        if (args !== null && args.length > 0) {\n          // Steal everything betwen eval start and eval end\n          let evalStart = -1;\n          let evalEnd = -1;\n          for (\n            let ii = 0;\n            ii < returnRuntimeContainer.content.length;\n            ii += 1\n          ) {\n            const cmd = returnRuntimeContainer.content[\n              ii\n            ] as RuntimeControlCommand;\n            if (cmd) {\n              if (\n                evalStart == -1 &&\n                cmd.commandType === RuntimeControlCommand.CommandType.EvalStart\n              ) {\n                evalStart = ii;\n              } else if (\n                cmd.commandType === RuntimeControlCommand.CommandType.EvalEnd\n              ) {\n                evalEnd = ii;\n              }\n            }\n          }\n\n          for (let ii = evalStart + 1; ii < evalEnd; ii += 1) {\n            const obj = returnRuntimeContainer.content[ii];\n            obj.parent = null; // prevent error of being moved between owners\n            container.AddContent(returnRuntimeContainer.content[ii]);\n          }\n        }\n      }\n      // Supply the divert target for the tunnel onwards target, either variable or more commonly, the explicit name\n      // var returnDivertObj = returnRuntimeObj as Runtime.Divert;\n      let returnDivertObj = asOrNull(returnRuntimeObj, RuntimeDivert);\n      if (returnDivertObj != null && returnDivertObj.hasVariableTarget) {\n        let runtimeVarRef = new VariableReference(\n          returnDivertObj.variableDivertName\n        );\n        container.AddContent(runtimeVarRef);\n      } else {\n        this._overrideDivertTarget = new DivertTargetValue();\n        container.AddContent(this._overrideDivertTarget);\n      }\n    } else {\n      // No divert after tunnel onwards\n      container.AddContent(new Void());\n    }\n\n    container.AddContent(RuntimeControlCommand.EvalEnd());\n    container.AddContent(RuntimeControlCommand.PopTunnel());\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    if (this.divertAfter && this.divertAfter.targetContent) {\n      this._overrideDivertTarget!.targetPath =\n        this.divertAfter.targetContent.runtimePath;\n    }\n  }\n\n  public toString = (): string => {\n    return ` -> ${this._divertAfter}`;\n  };\n}\n","import { InkListItem, SerializedInkListItem } from \"./InkList\";\nimport { TryGetResult } from \"./TryGetResult\";\n\nexport class ListDefinition {\n  public _name: string;\n  public _items: Map<SerializedInkListItem, number> | null;\n  public _itemNameToValues: Map<string, number>;\n\n  constructor(name: string, items: Map<string, number> | null) {\n    this._name = name || \"\";\n    this._items = null;\n    this._itemNameToValues = items || new Map();\n  }\n  get name() {\n    return this._name;\n  }\n  get items() {\n    if (this._items == null) {\n      this._items = new Map();\n      for (let [key, value] of this._itemNameToValues) {\n        let item = new InkListItem(this.name, key);\n        this._items.set(item.serialized(), value);\n      }\n    }\n\n    return this._items;\n  }\n\n  public ValueForItem(item: InkListItem) {\n    if (!item.itemName) return 0;\n\n    let intVal = this._itemNameToValues.get(item.itemName);\n    if (typeof intVal !== \"undefined\") return intVal;\n    else return 0;\n  }\n  public ContainsItem(item: InkListItem) {\n    if (!item.itemName) return false;\n    if (item.originName != this.name) return false;\n\n    return this._itemNameToValues.has(item.itemName);\n  }\n  public ContainsItemWithName(itemName: string) {\n    return this._itemNameToValues.has(itemName);\n  }\n  public TryGetItemWithValue(\n    val: number,\n    /* out */ item: InkListItem\n  ): TryGetResult<InkListItem> {\n    for (let [key, value] of this._itemNameToValues) {\n      if (value == val) {\n        item = new InkListItem(this.name, key);\n        return { result: item, exists: true };\n      }\n    }\n\n    item = InkListItem.Null;\n    return { result: item, exists: false };\n  }\n  public TryGetValueForItem(\n    item: InkListItem,\n    /* out */ intVal: number\n  ): TryGetResult<number> {\n    if (!item.itemName) return { result: 0, exists: false };\n    let value = this._itemNameToValues.get(item.itemName);\n\n    if (!value) return { result: 0, exists: false };\n    return { result: value, exists: true };\n  }\n}\n","import { InkList as RuntimeInkList } from \"../../../../engine/InkList\";\nimport { InkListItem as RuntimeInkListItem } from \"../../../../engine/InkList\";\nimport { ListDefinition as RuntimeListDefinition } from \"../../../../engine/ListDefinition\";\nimport { ListElementDefinition } from \"./ListElementDefinition\";\nimport { ListValue } from \"../../../../engine/Value\";\nimport { ParsedObject } from \"../Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { VariableAssignment } from \"../Variable/VariableAssignment\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ListDefinition extends ParsedObject {\n  public identifier: Identifier | null = null;\n  public variableAssignment: VariableAssignment | null = null;\n\n  get typeName() {\n    return \"ListDefinition\";\n  }\n\n  private _elementsByName: Map<string, ListElementDefinition> | null = null;\n\n  get runtimeListDefinition(): RuntimeListDefinition {\n    const allItems: Map<string, number> = new Map();\n    for (const e of this.itemDefinitions) {\n      if (!allItems.has(e.name!)) {\n        allItems.set(e.name!, e.seriesValue);\n      } else {\n        this.Error(\n          `List '${this.identifier}' contains duplicate items called '${e.name}'`\n        );\n      }\n    }\n\n    return new RuntimeListDefinition(this.identifier?.name || \"\", allItems);\n  }\n\n  public readonly ItemNamed = (\n    itemName: string\n  ): ListElementDefinition | null => {\n    if (this._elementsByName === null) {\n      this._elementsByName = new Map();\n\n      for (const el of this.itemDefinitions) {\n        this._elementsByName.set(el.name!, el);\n      }\n    }\n\n    const foundElement = this._elementsByName.get(itemName) || null;\n\n    return foundElement;\n  };\n\n  constructor(public itemDefinitions: ListElementDefinition[]) {\n    super();\n\n    let currentValue = 1;\n    for (const e of this.itemDefinitions) {\n      if (e.explicitValue !== null) {\n        currentValue = e.explicitValue;\n      }\n\n      e.seriesValue = currentValue;\n\n      currentValue += 1;\n    }\n\n    this.AddContent(itemDefinitions as any);\n  }\n\n  public readonly GenerateRuntimeObject = (): ListValue => {\n    const initialValues = new RuntimeInkList();\n    for (const itemDef of this.itemDefinitions) {\n      if (itemDef.inInitialList) {\n        const item = new RuntimeInkListItem(\n          this.identifier?.name || null,\n          itemDef.name || null\n        );\n        initialValues.Add(item, itemDef.seriesValue);\n      }\n    }\n\n    // Set origin name, so\n    initialValues.SetInitialOriginName(this.identifier?.name || \"\");\n\n    return new ListValue(initialValues);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n    context.CheckForNamingCollisions(this, this.identifier!, SymbolType.List);\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { ClosestFlowBase } from \"../Flow/ClosestFlowBase\";\nimport { ListDefinition } from \"../List/ListDefinition\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../../engine/VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { Identifier } from \"../Identifier\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class VariableAssignment extends ParsedObject {\n  private _runtimeAssignment: RuntimeVariableAssignment | null = null;\n\n  get variableName(): string {\n    return this.variableIdentifier.name!;\n  }\n  public readonly variableIdentifier: Identifier;\n  public readonly expression: Expression | null = null;\n  public readonly listDefinition: ListDefinition | null = null;\n  public readonly isGlobalDeclaration: boolean;\n  public readonly isNewTemporaryDeclaration: boolean;\n\n  get typeName() {\n    if (this.isNewTemporaryDeclaration) {\n      return \"temp\";\n    } else if (this.isGlobalDeclaration) {\n      if (this.listDefinition !== null) {\n        return \"LIST\";\n      }\n      return \"VAR\";\n    }\n\n    return \"variable assignment\";\n  }\n\n  get isDeclaration(): boolean {\n    return this.isGlobalDeclaration || this.isNewTemporaryDeclaration;\n  }\n\n  constructor({\n    assignedExpression,\n    isGlobalDeclaration,\n    isTemporaryNewDeclaration,\n    listDef,\n    variableIdentifier,\n  }: {\n    readonly assignedExpression?: Expression;\n    readonly isGlobalDeclaration?: boolean;\n    readonly isTemporaryNewDeclaration?: boolean;\n    readonly listDef?: ListDefinition;\n    readonly variableIdentifier: Identifier;\n  }) {\n    super();\n\n    this.variableIdentifier = variableIdentifier;\n    this.isGlobalDeclaration = Boolean(isGlobalDeclaration);\n    this.isNewTemporaryDeclaration = Boolean(isTemporaryNewDeclaration);\n\n    // Defensive programming in case parsing of assignedExpression failed\n    if (listDef instanceof ListDefinition) {\n      this.listDefinition = this.AddContent(listDef) as ListDefinition;\n      this.listDefinition.variableAssignment = this;\n\n      // List definitions are always global\n      this.isGlobalDeclaration = true;\n    } else if (assignedExpression) {\n      this.expression = this.AddContent(assignedExpression) as Expression;\n    }\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    let newDeclScope: FlowBase | null | undefined = null;\n    if (this.isGlobalDeclaration) {\n      newDeclScope = this.story;\n    } else if (this.isNewTemporaryDeclaration) {\n      newDeclScope = ClosestFlowBase(this);\n    }\n\n    if (newDeclScope) {\n      newDeclScope.AddNewVariableDeclaration(this);\n    }\n\n    // Global declarations don't generate actual procedural\n    // runtime objects, but instead add a global variable to the story itself.\n    // The story then initialises them all in one go at the start of the game.\n    if (this.isGlobalDeclaration) {\n      return null;\n    }\n\n    const container = new RuntimeContainer();\n\n    // The expression's runtimeObject is actually another nested container\n    if (this.expression) {\n      container.AddContent(this.expression.runtimeObject);\n    } else if (this.listDefinition) {\n      container.AddContent(this.listDefinition.runtimeObject);\n    }\n\n    this._runtimeAssignment = new RuntimeVariableAssignment(\n      this.variableName,\n      this.isNewTemporaryDeclaration\n    );\n\n    container.AddContent(this._runtimeAssignment);\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // List definitions are checked for conflicts separately\n    if (this.isDeclaration && this.listDefinition === null) {\n      context.CheckForNamingCollisions(\n        this,\n        this.variableIdentifier,\n        this.isGlobalDeclaration ? SymbolType.Var : SymbolType.Temp\n      );\n    }\n\n    // Initial VAR x = [intialValue] declaration, not re-assignment\n    if (this.isGlobalDeclaration) {\n      const variableReference = asOrNull(this.expression, VariableReference);\n      if (\n        variableReference &&\n        !variableReference.isConstantReference &&\n        !variableReference.isListItemReference\n      ) {\n        this.Error(\n          \"global variable assignments cannot refer to other variables, only literal values, constants and list items\"\n        );\n      }\n    }\n\n    if (!this.isNewTemporaryDeclaration) {\n      const resolvedVarAssignment = context.ResolveVariableWithName(\n        this.variableName,\n        this\n      );\n\n      if (!resolvedVarAssignment.found) {\n        if (this.variableName in this.story.constants) {\n          this.Error(\n            `Can't re-assign to a constant (do you need to use VAR when declaring '${this.variableName}'?)`,\n            this\n          );\n        } else {\n          this.Error(\n            `Variable could not be found to assign to: '${this.variableName}'`,\n            this\n          );\n        }\n      }\n\n      // A runtime assignment may not have been generated if it's the initial global declaration,\n      // since these are hoisted out and handled specially in Story.ExportRuntime.\n      if (this._runtimeAssignment) {\n        this._runtimeAssignment.isGlobal = resolvedVarAssignment.isGlobal;\n      }\n    }\n  }\n\n  public readonly toString = (): string =>\n    `${\n      this.isGlobalDeclaration\n        ? \"VAR\"\n        : this.isNewTemporaryDeclaration\n        ? \"~ temp\"\n        : \"\"\n    } ${this.variableName}`;\n}\n","import { AuthorWarning } from \"./AuthorWarning\";\nimport { Choice } from \"./Choice\";\nimport { Conditional } from \"./Conditional/Conditional\";\nimport { ConstantDeclaration } from \"./Declaration/ConstantDeclaration\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { Divert } from \"./Divert/Divert\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTarget } from \"./Divert/DivertTarget\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { Gather } from \"./Gather/Gather\";\nimport { GatherPointToResolve } from \"./Gather/GatherPointToResolve\";\nimport { IWeavePoint } from \"./IWeavePoint\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Sequence } from \"./Sequence/Sequence\";\nimport { Story } from \"./Story\";\nimport { Text } from \"./Text\";\nimport { TunnelOnwards } from \"./TunnelOnwards\";\nimport { VariableAssignment } from \"./Variable/VariableAssignment\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\ntype BadTerminationHandler = (terminatingObj: ParsedObject) => void;\n\n// Used by the FlowBase when constructing the weave flow from\n// a flat list of content objects.\nexport class Weave extends ParsedObject {\n  // Containers can be chained as multiple gather points\n  // get created as the same indentation level.\n  // rootContainer is always the first in the chain, while\n  // currentContainer is the latest.\n  get rootContainer(): RuntimeContainer {\n    if (!this._rootContainer) {\n      this._rootContainer = this.GenerateRuntimeObject();\n    }\n\n    return this._rootContainer;\n  }\n\n  // Keep track of previous weave point (Choice or Gather)\n  // at the current indentation level:\n  //  - to add ordinary content to be nested under it\n  //  - to add nested content under it when it's indented\n  //  - to remove it from the list of loose ends when\n  //     - it has indented content since it's no longer a loose end\n  //     - it's a gather and it has a choice added to it\n  public previousWeavePoint: IWeavePoint | null = null;\n  public addContentToPreviousWeavePoint: boolean = false;\n\n  // Used for determining whether the next Gather should auto-enter\n  public hasSeenChoiceInSection: boolean = false;\n\n  public currentContainer: RuntimeContainer | null = null;\n  public baseIndentIndex: number;\n\n  private _unnamedGatherCount: number = 0;\n  private _choiceCount: number = 0;\n  private _rootContainer: RuntimeContainer | null = null;\n  private _namedWeavePoints: Map<string, IWeavePoint> = new Map();\n  get namedWeavePoints() {\n    return this._namedWeavePoints;\n  }\n\n  // Loose ends are:\n  //  - Choices or Gathers that need to be joined up\n  //  - Explicit Divert to gather points (i.e. \"->\" without a target)\n  public looseEnds: IWeavePoint[] = [];\n\n  public gatherPointsToResolve: GatherPointToResolve[] = [];\n\n  get lastParsedSignificantObject(): ParsedObject | null {\n    if (this.content.length === 0) {\n      return null;\n    }\n\n    // Don't count extraneous newlines or VAR/CONST declarations,\n    // since they're \"empty\" statements outside of the main flow.\n    let lastObject: ParsedObject | null = null;\n    for (let ii = this.content.length - 1; ii >= 0; --ii) {\n      lastObject = this.content[ii];\n\n      let lastText = asOrNull(lastObject, Text);\n      if (lastText && lastText.text === \"\\n\") {\n        continue;\n      }\n\n      if (this.IsGlobalDeclaration(lastObject)) {\n        continue;\n      }\n\n      break;\n    }\n\n    const lastWeave = asOrNull(lastObject, Weave);\n    if (lastWeave) {\n      lastObject = lastWeave.lastParsedSignificantObject;\n    }\n\n    return lastObject;\n  }\n\n  constructor(cont: ParsedObject[], indentIndex: number = -1) {\n    super();\n\n    if (indentIndex == -1) {\n      this.baseIndentIndex = this.DetermineBaseIndentationFromContent(cont);\n    } else {\n      this.baseIndentIndex = indentIndex;\n    }\n\n    this.AddContent(cont);\n\n    this.ConstructWeaveHierarchyFromIndentation();\n  }\n\n  get typeName(): string {\n    return \"Weave\";\n  }\n\n  public readonly ResolveWeavePointNaming = (): void => {\n    const namedWeavePoints = [\n      ...this.FindAll<IWeavePoint>(Gather)(\n        (w) => !(w.name === null || w.name === undefined)\n      ),\n      ...this.FindAll<IWeavePoint>(Choice)(\n        (w) => !(w.name === null || w.name === undefined)\n      ),\n    ];\n    this._namedWeavePoints = new Map();\n\n    for (const weavePoint of namedWeavePoints) {\n      // Check for weave point naming collisions\n      const existingWeavePoint: IWeavePoint | null | undefined =\n        this.namedWeavePoints.get(weavePoint.identifier?.name || \"\");\n\n      if (existingWeavePoint) {\n        const typeName =\n          existingWeavePoint instanceof Gather ? \"gather\" : \"choice\";\n        const existingObj: ParsedObject = existingWeavePoint;\n\n        this.Error(\n          `A ${typeName} with the same label name '${\n            weavePoint.name\n          }' already exists in this context on line ${\n            existingObj.debugMetadata\n              ? existingObj.debugMetadata.startLineNumber\n              : \"NO DEBUG METADATA AVAILABLE\"\n          }`,\n          weavePoint as ParsedObject\n        );\n      }\n      if (weavePoint.identifier?.name) {\n        this.namedWeavePoints.set(weavePoint.identifier?.name, weavePoint);\n      }\n    }\n  };\n\n  public readonly ConstructWeaveHierarchyFromIndentation = (): void => {\n    // Find nested indentation and convert to a proper object hierarchy\n    // (i.e. indented content is replaced with a Weave object that contains\n    // that nested content)\n    let contentIdx = 0;\n    while (contentIdx < this.content.length) {\n      const obj: ParsedObject = this.content[contentIdx];\n\n      // Choice or Gather\n      if (obj instanceof Choice || obj instanceof Gather) {\n        const weavePoint: IWeavePoint = obj;\n        const weaveIndentIdx = weavePoint.indentationDepth - 1;\n\n        // Inner level indentation - recurse\n        if (weaveIndentIdx > this.baseIndentIndex) {\n          // Step through content until indent jumps out again\n          let innerWeaveStartIdx = contentIdx;\n          while (contentIdx < this.content.length) {\n            const innerWeaveObj =\n              asOrNull(this.content[contentIdx], Choice) ||\n              asOrNull(this.content[contentIdx], Gather);\n            if (innerWeaveObj !== null) {\n              const innerIndentIdx = innerWeaveObj.indentationDepth - 1;\n              if (innerIndentIdx <= this.baseIndentIndex) {\n                break;\n              }\n            }\n\n            contentIdx += 1;\n          }\n\n          const weaveContentCount = contentIdx - innerWeaveStartIdx;\n          const weaveContent = this.content.slice(\n            innerWeaveStartIdx,\n            innerWeaveStartIdx + weaveContentCount\n          );\n\n          this.content.splice(innerWeaveStartIdx, weaveContentCount);\n\n          const weave = new Weave(weaveContent, weaveIndentIdx);\n          this.InsertContent(innerWeaveStartIdx, weave);\n\n          // Continue iteration from this point\n          contentIdx = innerWeaveStartIdx;\n        }\n      }\n\n      contentIdx += 1;\n    }\n  };\n\n  // When the indentation wasn't told to us at construction time using\n  // a choice point with a known indentation level, we may be told to\n  // determine the indentation level by incrementing from our closest ancestor.\n  public readonly DetermineBaseIndentationFromContent = (\n    contentList: ParsedObject[]\n  ): number => {\n    for (const obj of contentList) {\n      if (obj instanceof Choice || obj instanceof Gather) {\n        return obj.indentationDepth - 1;\n      }\n    }\n\n    // No weave points, so it doesn't matter\n    return 0;\n  };\n\n  public readonly GenerateRuntimeObject = (): RuntimeContainer => {\n    this._rootContainer = new RuntimeContainer();\n    this.currentContainer = this._rootContainer;\n    this.looseEnds = [];\n    this.gatherPointsToResolve = [];\n\n    // Iterate through content for the block at this level of indentation\n    //  - Normal content is nested under Choices and Gathers\n    //  - Blocks that are further indented cause recursion\n    //  - Keep track of loose ends so that they can be diverted to Gathers\n    for (const obj of this.content) {\n      // Choice or Gather\n      if (obj instanceof Choice || obj instanceof Gather) {\n        this.AddRuntimeForWeavePoint(obj as IWeavePoint);\n      } else {\n        // Non-weave point\n        if (obj instanceof Weave) {\n          // Nested weave\n          const weave = obj;\n          this.AddRuntimeForNestedWeave(weave);\n          this.gatherPointsToResolve.splice(\n            0,\n            0,\n            ...weave.gatherPointsToResolve\n          );\n        } else {\n          // Other object\n          // May be complex object that contains statements - e.g. a multi-line conditional\n          this.AddGeneralRuntimeContent(obj.runtimeObject);\n        }\n      }\n    }\n\n    // Pass any loose ends up the hierarhcy\n    this.PassLooseEndsToAncestors();\n\n    return this._rootContainer;\n  };\n\n  // Found gather point:\n  //  - gather any loose ends\n  //  - set the gather as the main container to dump new content in\n  public readonly AddRuntimeForGather = (gather: Gather): void => {\n    // Determine whether this Gather should be auto-entered:\n    //  - It is auto-entered if there were no choices in the last section\n    //  - A section is \"since the previous gather\" - so reset now\n    const autoEnter = !this.hasSeenChoiceInSection;\n    this.hasSeenChoiceInSection = false;\n\n    const gatherContainer = gather.runtimeContainer;\n\n    if (!gather.name) {\n      // Use disallowed character so it's impossible to have a name collision\n      gatherContainer.name = `g-${this._unnamedGatherCount}`;\n      this._unnamedGatherCount += 1;\n    }\n\n    if (autoEnter) {\n      if (!this.currentContainer) {\n        throw new Error();\n      }\n\n      // Auto-enter: include in main content\n      this.currentContainer.AddContent(gatherContainer);\n    } else {\n      // Don't auto-enter:\n      // Add this gather to the main content, but only accessible\n      // by name so that it isn't stepped into automatically, but only via\n      // a divert from a loose end.\n      this.rootContainer.AddToNamedContentOnly(gatherContainer);\n    }\n\n    // Consume loose ends: divert them to this gather\n    for (const looseEndWeavePoint of this.looseEnds) {\n      const looseEnd = looseEndWeavePoint as ParsedObject;\n\n      // Skip gather loose ends that are at the same level\n      // since they'll be handled by the auto-enter code below\n      // that only jumps into the gather if (current runtime choices == 0)\n      if (looseEnd instanceof Gather) {\n        const prevGather = looseEnd;\n        if (prevGather.indentationDepth == gather.indentationDepth) {\n          continue;\n        }\n      }\n\n      let divert: RuntimeDivert | null = null;\n      if (looseEnd instanceof Divert) {\n        divert = looseEnd.runtimeObject as RuntimeDivert;\n      } else {\n        divert = new RuntimeDivert();\n        const looseWeavePoint = looseEnd as IWeavePoint;\n        if (!looseWeavePoint.runtimeContainer) {\n          throw new Error();\n        }\n\n        looseWeavePoint.runtimeContainer.AddContent(divert);\n      }\n\n      // Pass back knowledge of this loose end being diverted\n      // to the FlowBase so that it can maintain a list of them,\n      // and resolve the divert references later\n      this.gatherPointsToResolve.push(\n        new GatherPointToResolve(divert, gatherContainer)\n      );\n    }\n\n    this.looseEnds = [];\n\n    // Replace the current container itself\n    this.currentContainer = gatherContainer;\n  };\n\n  public readonly AddRuntimeForWeavePoint = (weavePoint: IWeavePoint): void => {\n    // Current level Gather\n    if (weavePoint instanceof Gather) {\n      this.AddRuntimeForGather(weavePoint);\n    }\n\n    // Current level choice\n    else if (weavePoint instanceof Choice) {\n      if (!this.currentContainer) {\n        throw new Error();\n      }\n\n      // Gathers that contain choices are no longer loose ends\n      // (same as when weave points get nested content)\n      if (this.previousWeavePoint instanceof Gather) {\n        this.looseEnds.splice(\n          this.looseEnds.indexOf(this.previousWeavePoint),\n          1\n        );\n      }\n\n      // Add choice point content\n      const choice = weavePoint; //, Choice);\n\n      this.currentContainer.AddContent(choice.runtimeObject);\n      if (!choice.innerContentContainer) {\n        throw new Error();\n      } //guaranteed not to happen\n\n      // Add choice's inner content to self\n      choice.innerContentContainer.name = `c-${this._choiceCount}`;\n      this.currentContainer.AddToNamedContentOnly(choice.innerContentContainer);\n      this._choiceCount += 1;\n\n      this.hasSeenChoiceInSection = true;\n    }\n\n    // Keep track of loose ends\n    this.addContentToPreviousWeavePoint = false; // default\n    if (this.WeavePointHasLooseEnd(weavePoint)) {\n      this.looseEnds.push(weavePoint);\n\n      const looseChoice = asOrNull(weavePoint, Choice);\n      if (looseChoice) {\n        this.addContentToPreviousWeavePoint = true;\n      }\n    }\n\n    this.previousWeavePoint = weavePoint;\n  };\n\n  // Add nested block at a greater indentation level\n  public readonly AddRuntimeForNestedWeave = (nestedResult: Weave): void => {\n    // Add this inner block to current container\n    // (i.e. within the main container, or within the last defined Choice/Gather)\n    this.AddGeneralRuntimeContent(nestedResult.rootContainer);\n\n    // Now there's a deeper indentation level, the previous weave point doesn't\n    // count as a loose end (since it will have content to go to)\n    if (this.previousWeavePoint !== null) {\n      this.looseEnds.splice(this.looseEnds.indexOf(this.previousWeavePoint), 1);\n\n      this.addContentToPreviousWeavePoint = false;\n    }\n  };\n\n  // Normal content gets added into the latest Choice or Gather by default,\n  // unless there hasn't been one yet.\n  public readonly AddGeneralRuntimeContent = (content: RuntimeObject): void => {\n    // Content is allowed to evaluate runtimeObject to null\n    // (e.g. AuthorWarning, which doesn't make it into the runtime)\n    if (content === null) {\n      return;\n    }\n\n    if (this.addContentToPreviousWeavePoint) {\n      if (\n        !this.previousWeavePoint ||\n        !this.previousWeavePoint.runtimeContainer\n      ) {\n        throw new Error();\n      }\n\n      this.previousWeavePoint.runtimeContainer.AddContent(content);\n    } else {\n      if (!this.currentContainer) {\n        throw new Error();\n      }\n\n      this.currentContainer.AddContent(content);\n    }\n  };\n\n  public readonly PassLooseEndsToAncestors = () => {\n    if (this.looseEnds.length === 0) {\n      return;\n    }\n\n    // Search for Weave ancestor to pass loose ends to for gathering.\n    // There are two types depending on whether the current weave\n    // is separated by a conditional or sequence.\n    //  - An \"inner\" weave is one that is directly connected to the current\n    //    weave - i.e. you don't have to pass through a conditional or\n    //    sequence to get to it. We're allowed to pass all loose ends to\n    //    one of these.\n    //  - An \"outer\" weave is one that is outside of a conditional/sequence\n    //    that the current weave is nested within. We're only allowed to\n    //    pass gathers (i.e. 'normal flow') loose ends up there, not normal\n    //    choices. The rule is that choices have to be diverted explicitly\n    //    by the author since it's ambiguous where flow should go otherwise.\n    //\n    // e.g.:\n    //\n    //   - top                       <- e.g. outer weave\n    //   {true:\n    //       * choice                <- e.g. inner weave\n    //         * * choice 2\n    //             more content      <- e.g. current weave\n    //       * choice 2\n    //   }\n    //   - more of outer weave\n    //\n    let closestInnerWeaveAncestor: Weave | null = null;\n    let closestOuterWeaveAncestor: Weave | null = null;\n\n    // Find inner and outer ancestor weaves as defined above.\n    let nested = false;\n    for (\n      let ancestor = this.parent;\n      ancestor !== null;\n      ancestor = ancestor.parent\n    ) {\n      // Found ancestor?\n      const weaveAncestor = asOrNull(ancestor, Weave);\n      if (weaveAncestor) {\n        if (!nested && closestInnerWeaveAncestor === null) {\n          closestInnerWeaveAncestor = weaveAncestor;\n        }\n\n        if (nested && closestOuterWeaveAncestor === null) {\n          closestOuterWeaveAncestor = weaveAncestor;\n        }\n      }\n\n      // Weaves nested within Sequences or Conditionals are\n      // \"sealed\" - any loose ends require explicit diverts.\n      if (ancestor instanceof Sequence || ancestor instanceof Conditional) {\n        nested = true;\n      }\n    }\n\n    // No weave to pass loose ends to at all?\n    if (\n      closestInnerWeaveAncestor === null &&\n      closestOuterWeaveAncestor === null\n    ) {\n      return;\n    }\n\n    // Follow loose end passing logic as defined above\n    for (let ii = this.looseEnds.length - 1; ii >= 0; ii -= 1) {\n      const looseEnd = this.looseEnds[ii];\n      let received = false;\n\n      if (nested) {\n        // This weave is nested within a conditional or sequence:\n        //  - choices can only be passed up to direct ancestor (\"inner\") weaves\n        //  - gathers can be passed up to either, but favour the closer (inner) weave\n        //    if there is one\n        if (looseEnd instanceof Choice && closestInnerWeaveAncestor !== null) {\n          closestInnerWeaveAncestor.ReceiveLooseEnd(looseEnd);\n          received = true;\n        } else if (!(looseEnd instanceof Choice)) {\n          const receivingWeave =\n            closestInnerWeaveAncestor || closestOuterWeaveAncestor;\n          if (receivingWeave !== null) {\n            receivingWeave.ReceiveLooseEnd(looseEnd);\n            received = true;\n          }\n        }\n      } else {\n        // No nesting, all loose ends can be safely passed up\n        if (closestInnerWeaveAncestor?.hasOwnProperty(\"ReceiveLooseEnd\")) {\n          closestInnerWeaveAncestor!.ReceiveLooseEnd(looseEnd);\n        }\n        received = true;\n      }\n\n      if (received) {\n        this.looseEnds.splice(ii, 1);\n      }\n    }\n  };\n\n  public readonly ReceiveLooseEnd = (childWeaveLooseEnd: IWeavePoint): void => {\n    this.looseEnds.push(childWeaveLooseEnd);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // Check that choices nested within conditionals and sequences are terminated\n    if (this.looseEnds !== null && this.looseEnds.length > 0) {\n      let isNestedWeave = false;\n      for (\n        let ancestor = this.parent;\n        ancestor !== null;\n        ancestor = ancestor.parent\n      ) {\n        if (ancestor instanceof Sequence || ancestor instanceof Conditional) {\n          isNestedWeave = true;\n          break;\n        }\n      }\n\n      if (isNestedWeave) {\n        this.ValidateTermination(this.BadNestedTerminationHandler);\n      }\n    }\n\n    for (const gatherPoint of this.gatherPointsToResolve) {\n      gatherPoint.divert.targetPath = gatherPoint.targetRuntimeObj.path;\n    }\n\n    this.CheckForWeavePointNamingCollisions();\n  }\n\n  public readonly WeavePointNamed = (name: string): IWeavePoint | null => {\n    if (!this.namedWeavePoints) {\n      return null;\n    }\n\n    let weavePointResult: IWeavePoint | null | undefined =\n      this.namedWeavePoints.get(name);\n    if (weavePointResult) {\n      return weavePointResult;\n    }\n\n    return null;\n  };\n\n  // Global VARs and CONSTs are treated as \"outside of the flow\"\n  // when iterating over content that follows loose ends\n  public readonly IsGlobalDeclaration = (obj: ParsedObject) => {\n    const varAss = asOrNull(obj, VariableAssignment);\n    if (varAss && varAss.isGlobalDeclaration && varAss.isDeclaration) {\n      return true;\n    }\n\n    const constDecl = asOrNull(obj, ConstantDeclaration);\n    if (constDecl) {\n      return true;\n    }\n\n    return false;\n  };\n\n  // While analysing final loose ends, we look to see whether there\n  // are any diverts etc which choices etc divert from\n  public readonly ContentThatFollowsWeavePoint = (\n    weavePoint: IWeavePoint\n  ): ParsedObject[] => {\n    const returned = [];\n    const obj = weavePoint as ParsedObject;\n\n    // Inner content first (e.g. for a choice)\n    if (obj.content !== null) {\n      for (const contentObj of obj.content) {\n        // Global VARs and CONSTs are treated as \"outside of the flow\"\n        if (this.IsGlobalDeclaration(contentObj)) {\n          continue;\n        }\n\n        returned.push(contentObj);\n      }\n    }\n\n    const parentWeave = asOrNull(obj.parent, Weave);\n    if (parentWeave === null) {\n      throw new Error(\"Expected weave point parent to be weave?\");\n    }\n\n    const weavePointIdx = parentWeave.content.indexOf(obj);\n    for (let ii = weavePointIdx + 1; ii < parentWeave.content.length; ii += 1) {\n      const laterObj = parentWeave.content[ii];\n\n      // Global VARs and CONSTs are treated as \"outside of the flow\"\n      if (this.IsGlobalDeclaration(laterObj)) {\n        continue;\n      }\n\n      // End of the current flow\n      // if (laterObj instanceof IWeavePoint) // cannot test on interface in ts\n      if (laterObj instanceof Choice || laterObj instanceof Gather) {\n        break;\n      }\n\n      // Other weaves will be have their own loose ends\n      if (laterObj instanceof Weave) {\n        break;\n      }\n\n      returned.push(laterObj);\n    }\n\n    return returned;\n  };\n\n  public readonly ValidateTermination = (\n    badTerminationHandler: BadTerminationHandler\n  ): void => {\n    // Don't worry if the last object in the flow is a \"TODO\",\n    // even if there are other loose ends in other places\n    if (this.lastParsedSignificantObject instanceof AuthorWarning) {\n      return;\n    }\n\n    // By now, any sub-weaves will have passed loose ends up to the root weave (this).\n    // So there are 2 possible situations:\n    //  - There are loose ends from somewhere in the flow.\n    //    These aren't necessarily \"real\" loose ends - they're weave points\n    //    that don't connect to any lower weave points, so we just\n    //    have to check that they terminate properly.\n    //  - This weave is just a list of content with no actual weave points,\n    //    so we just need to check that the list of content terminates.\n\n    const hasLooseEnds: boolean =\n      this.looseEnds !== null && this.looseEnds.length > 0;\n\n    if (hasLooseEnds) {\n      for (const looseEnd of this.looseEnds) {\n        const looseEndFlow = this.ContentThatFollowsWeavePoint(looseEnd);\n        this.ValidateFlowOfObjectsTerminates(\n          looseEndFlow,\n          looseEnd as ParsedObject,\n          badTerminationHandler\n        );\n      }\n    } else {\n      // No loose ends... is there any inner weaving at all?\n      // If not, make sure the single content stream is terminated correctly\n      //\n      // If there's any actual weaving, assume that content is\n      // terminated correctly since we would've had a loose end otherwise\n      for (const obj of this.content) {\n        if (obj instanceof Choice || obj instanceof Divert) {\n          return;\n        }\n      }\n\n      // Straight linear flow? Check it terminates\n      this.ValidateFlowOfObjectsTerminates(\n        this.content,\n        this,\n        badTerminationHandler\n      );\n    }\n  };\n\n  readonly BadNestedTerminationHandler: BadTerminationHandler = (\n    terminatingObj\n  ) => {\n    let conditional: Conditional | null = null;\n    for (\n      let ancestor = terminatingObj.parent;\n      ancestor !== null;\n      ancestor = ancestor.parent\n    ) {\n      if (ancestor instanceof Sequence || ancestor instanceof Conditional) {\n        conditional = asOrNull(ancestor, Conditional);\n        break;\n      }\n    }\n\n    let errorMsg =\n      \"Choices nested in conditionals or sequences need to explicitly divert afterwards.\";\n\n    // Tutorialise proper choice syntax if this looks like a single choice within a condition, e.g.\n    // { condition:\n    //      * choice\n    // }\n    if (conditional !== null) {\n      let numChoices = conditional.FindAll<Choice>(Choice)().length;\n      if (numChoices === 1) {\n        errorMsg = `Choices with conditions should be written: '* {condition} choice'. Otherwise, ${errorMsg.toLowerCase()}`;\n      }\n    }\n\n    this.Error(errorMsg, terminatingObj);\n  };\n\n  public readonly ValidateFlowOfObjectsTerminates = (\n    objFlow: ParsedObject[],\n    defaultObj: ParsedObject,\n    badTerminationHandler: BadTerminationHandler\n  ) => {\n    let terminated = false;\n    let terminatingObj: ParsedObject = defaultObj;\n    for (const flowObj of objFlow) {\n      const divert = flowObj.Find(Divert)(\n        (d) =>\n          !d.isThread &&\n          !d.isTunnel &&\n          !d.isFunctionCall &&\n          !(d.parent instanceof DivertTarget)\n      );\n\n      if (divert !== null) {\n        terminated = true;\n      }\n\n      if (flowObj.Find(TunnelOnwards)() != null) {\n        terminated = true;\n        break;\n      }\n\n      terminatingObj = flowObj;\n    }\n\n    if (!terminated) {\n      // Author has left a note to self here - clearly we don't need\n      // to leave them with another warning since they know what they're doing.\n      if (terminatingObj instanceof AuthorWarning) {\n        return;\n      }\n\n      badTerminationHandler(terminatingObj);\n    }\n  };\n\n  public readonly WeavePointHasLooseEnd = (\n    weavePoint: IWeavePoint\n  ): boolean => {\n    // No content, must be a loose end.\n    if (weavePoint.content === null) {\n      return true;\n    }\n\n    // If a weave point is diverted from, it doesn't have a loose end.\n    // Detect a divert object within a weavePoint's main content\n    // Work backwards since we're really interested in the end,\n    // although it doesn't actually make a difference!\n    // (content after a divert will simply be inaccessible)\n    for (let ii = weavePoint.content.length - 1; ii >= 0; --ii) {\n      let innerDivert = asOrNull(weavePoint.content[ii], Divert);\n      if (innerDivert) {\n        const willReturn =\n          innerDivert.isThread ||\n          innerDivert.isTunnel ||\n          innerDivert.isFunctionCall;\n        if (!willReturn) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  // Enforce rule that weave points must not have the same\n  // name as any stitches or knots upwards in the hierarchy\n  public readonly CheckForWeavePointNamingCollisions = (): void => {\n    if (!this.namedWeavePoints) {\n      return;\n    }\n\n    const ancestorFlows = [];\n    for (const obj of this.ancestry) {\n      const flow = asOrNull(obj, FlowBase);\n      if (flow) {\n        ancestorFlows.push(flow);\n      } else {\n        break;\n      }\n    }\n\n    for (const [weavePointName, weavePoint] of this.namedWeavePoints) {\n      for (const flow of ancestorFlows) {\n        // Shallow search\n        const otherContentWithName =\n          flow.ContentWithNameAtLevel(weavePointName);\n        if (otherContentWithName && otherContentWithName !== weavePoint) {\n          const errorMsg = `${weavePoint.GetType()} '${weavePointName}' has the same label name as a ${otherContentWithName.GetType()} (on ${\n            otherContentWithName.debugMetadata\n          })`;\n          this.Error(errorMsg, weavePoint);\n        }\n      }\n    }\n  };\n}\n","﻿import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { Expression } from \"../Expression/Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { StringValue } from \"../../../../engine/Value\";\nimport { Story } from \"../Story\";\nimport { Text } from \"../Text\";\nimport { Weave } from \"../Weave\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class ConditionalSingleBranch extends ParsedObject {\n  public _contentContainer: RuntimeContainer | null = null;\n  public _conditionalDivert: RuntimeDivert | null = null;\n  public _ownExpression: Expression | null = null;\n  public _innerWeave: Weave | null = null;\n  // bool condition, e.g.:\n  // { 5 == 4:\n  //   - the true branch\n  //   - the false branch\n  // }\n  public isTrueBranch: boolean = false;\n\n  // When each branch has its own expression like a switch statement,\n  // this is non-null. e.g.\n  // { x:\n  //    - 4: the value of x is four (ownExpression is the value 4)\n  //    - 3: the value of x is three\n  // }\n  get ownExpression() {\n    return this._ownExpression;\n  }\n\n  set ownExpression(value) {\n    this._ownExpression = value;\n    if (this._ownExpression) {\n      this.AddContent(this._ownExpression);\n    }\n  }\n\n  // In the above example, match equality of x with 4 for the first branch.\n  // This is as opposed to simply evaluating boolean equality for each branch,\n  // example when shouldMatchEquality is FALSE:\n  // {\n  //    3 > 2:  This will happen\n  //    2 > 3:  This won't happen\n  // }\n  public matchingEquality: boolean = false;\n\n  public isElse: boolean = false;\n  public isInline: boolean = false;\n\n  public returnDivert: RuntimeDivert | null = null;\n\n  constructor(content?: ParsedObject[] | null | undefined) {\n    super();\n\n    // Branches are allowed to be empty\n    if (content) {\n      this._innerWeave = new Weave(content);\n      this.AddContent(this._innerWeave);\n    }\n  }\n\n  get typeName(): string {\n    return \"ConditionalSingleBranch\";\n  }\n\n  // Runtime content can be summarised as follows:\n  //  - Evaluate an expression if necessary to branch on\n  //  - Branch to a named container if true\n  //       - Divert back to main flow\n  //         (owner Conditional is in control of this target point)\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    // Check for common mistake, of putting \"else:\" instead of \"- else:\"\n    if (this._innerWeave) {\n      for (const c of this._innerWeave.content) {\n        const text = asOrNull(c, Text);\n        if (text) {\n          // Don't need to trim at the start since the parser handles that already\n          if (text.text.startsWith(\"else:\")) {\n            this.Warning(\n              \"Saw the text 'else:' which is being treated as content. Did you mean '- else:'?\",\n              text\n            );\n          }\n        }\n      }\n    }\n\n    const container = new RuntimeContainer();\n\n    // Are we testing against a condition that's used for more than just this\n    // branch? If so, the first thing we need to do is replicate the value that's\n    // on the evaluation stack so that we don't fully consume it, in case other\n    // branches need to use it.\n    const duplicatesStackValue: boolean = this.matchingEquality && !this.isElse;\n\n    if (duplicatesStackValue) {\n      container.AddContent(RuntimeControlCommand.Duplicate());\n    }\n\n    this._conditionalDivert = new RuntimeDivert();\n\n    // else clause is unconditional catch-all, otherwise the divert is conditional\n    this._conditionalDivert.isConditional = !this.isElse;\n\n    // Need extra evaluation?\n    if (!this.isTrueBranch && !this.isElse) {\n      const needsEval: boolean = this.ownExpression !== null;\n      if (needsEval) {\n        container.AddContent(RuntimeControlCommand.EvalStart());\n      }\n\n      if (this.ownExpression) {\n        this.ownExpression.GenerateIntoContainer(container);\n      }\n\n      // Uses existing duplicated value\n      if (this.matchingEquality) {\n        container.AddContent(NativeFunctionCall.CallWithName(\"==\"));\n      }\n\n      if (needsEval) {\n        container.AddContent(RuntimeControlCommand.EvalEnd());\n      }\n    }\n\n    // Will pop from stack if conditional\n    container.AddContent(this._conditionalDivert);\n\n    this._contentContainer = this.GenerateRuntimeForContent();\n    this._contentContainer.name = \"b\";\n\n    // Multi-line conditionals get a newline at the start of each branch\n    // (as opposed to the start of the multi-line conditional since the condition\n    //  may evaluate to false.)\n    if (!this.isInline) {\n      this._contentContainer.InsertContent(new StringValue(\"\\n\"), 0);\n    }\n\n    if (duplicatesStackValue || (this.isElse && this.matchingEquality)) {\n      this._contentContainer.InsertContent(\n        RuntimeControlCommand.PopEvaluatedValue(),\n        0\n      );\n    }\n\n    container.AddToNamedContentOnly(this._contentContainer);\n\n    this.returnDivert = new RuntimeDivert();\n    this._contentContainer.AddContent(this.returnDivert);\n\n    return container;\n  };\n\n  public readonly GenerateRuntimeForContent = (): RuntimeContainer => {\n    // Empty branch - create empty container\n    if (this._innerWeave === null) {\n      return new RuntimeContainer();\n    }\n\n    return this._innerWeave.rootContainer;\n  };\n\n  public ResolveReferences(context: Story): void {\n    if (!this._conditionalDivert || !this._contentContainer) {\n      throw new Error();\n    }\n\n    this._conditionalDivert.targetPath = this._contentContainer.path;\n    super.ResolveReferences(context);\n  }\n}\n","export class DebugMetadata {\n  public startLineNumber: number = 0;\n  public endLineNumber: number = 0;\n  public startCharacterNumber: number = 0;\n  public endCharacterNumber: number = 0;\n  public fileName: string | null = null;\n  public sourceName: string | null = null;\n\n  public Merge(dm: DebugMetadata) {\n    let newDebugMetadata = new DebugMetadata();\n\n    newDebugMetadata.fileName = this.fileName;\n    newDebugMetadata.sourceName = this.sourceName;\n\n    if (this.startLineNumber < dm.startLineNumber) {\n      newDebugMetadata.startLineNumber = this.startLineNumber;\n      newDebugMetadata.startCharacterNumber = this.startCharacterNumber;\n    } else if (this.startLineNumber > dm.startLineNumber) {\n      newDebugMetadata.startLineNumber = dm.startLineNumber;\n      newDebugMetadata.startCharacterNumber = dm.startCharacterNumber;\n    } else {\n      newDebugMetadata.startLineNumber = this.startLineNumber;\n      newDebugMetadata.startCharacterNumber = Math.min(\n        this.startCharacterNumber,\n        dm.startCharacterNumber\n      );\n    }\n\n    if (this.endLineNumber > dm.endLineNumber) {\n      newDebugMetadata.endLineNumber = this.endLineNumber;\n      newDebugMetadata.endCharacterNumber = this.endCharacterNumber;\n    } else if (this.endLineNumber < dm.endLineNumber) {\n      newDebugMetadata.endLineNumber = dm.endLineNumber;\n      newDebugMetadata.endCharacterNumber = dm.endCharacterNumber;\n    } else {\n      newDebugMetadata.endLineNumber = this.endLineNumber;\n      newDebugMetadata.endCharacterNumber = Math.max(\n        this.endCharacterNumber,\n        dm.endCharacterNumber\n      );\n    }\n\n    return newDebugMetadata;\n  }\n\n  public toString() {\n    if (this.fileName !== null) {\n      return `line ${this.startLineNumber} of ${this.fileName}\"`;\n    } else {\n      return \"line \" + this.startLineNumber;\n    }\n  }\n}\n","import { INamedContent } from \"../../../../engine/INamedContent\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ExternalDeclaration extends ParsedObject implements INamedContent {\n  public get name(): string | null {\n    return this.identifier?.name || null;\n  }\n\n  constructor(\n    public readonly identifier: Identifier,\n    public readonly argumentNames: string[]\n  ) {\n    super();\n  }\n\n  get typeName(): string {\n    return \"EXTERNAL\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    this.story.AddExternal(this);\n\n    // No runtime code exists for an external, only metadata\n    return null;\n  };\n\n  public toString(): string {\n    return `EXTERNAL ${this.identifier?.name}`;\n  }\n}\n","import { Argument } from \"./ParsedHierarchy/Argument\";\nimport { Identifier } from \"./ParsedHierarchy/Identifier\";\n\nexport class FlowDecl {\n  constructor(\n    public readonly name: Identifier,\n    public readonly args: Argument[],\n    public readonly isFunction: boolean\n  ) {}\n}\n","import { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\n\nexport class Wrap<T extends RuntimeObject> extends ParsedObject {\n  constructor(private _objToWrap: T) {\n    super();\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => this._objToWrap;\n}\n","import { Glue as RuntimeGlue } from \"../../../engine/Glue\";\nimport { Wrap } from \"./Wrap\";\n\nexport class Glue extends Wrap<RuntimeGlue> {\n  constructor(glue: RuntimeGlue) {\n    super(glue);\n  }\n\n  get typeName(): string {\n    return \"Glue\";\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Glue extends InkObject {\n  public toString() {\n    return \"Glue\";\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ContentList } from \"../ContentList\";\nimport { Expression } from \"./Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { IntValue } from \"../../../../engine/Value\";\nimport { Story } from \"../Story\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../../engine/VariableAssignment\";\nimport { VariableReference as RuntimeVariableReference } from \"../../../../engine/VariableReference\";\nimport { Weave } from \"../Weave\";\nimport { Identifier } from \"../Identifier\";\n\nexport class IncDecExpression extends Expression {\n  private _runtimeAssignment: RuntimeVariableAssignment | null = null;\n\n  public isInc: boolean;\n  public expression: Expression | null = null;\n\n  constructor(\n    public readonly varIdentifier: Identifier | null,\n    isIncOrExpression: boolean | Expression,\n    isInc?: boolean\n  ) {\n    super();\n\n    if (isIncOrExpression instanceof Expression) {\n      this.expression = isIncOrExpression;\n      this.AddContent(this.expression);\n      this.isInc = Boolean(isInc);\n    } else {\n      this.isInc = isIncOrExpression as boolean;\n    }\n  }\n\n  get typeName(): string {\n    return \"IncDecExpression\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    // x = x + y\n    // ^^^ ^ ^ ^\n    //  4  1 3 2\n    // Reverse polish notation: (x 1 +) (assign to x)\n\n    // 1.\n    container.AddContent(\n      new RuntimeVariableReference(this.varIdentifier?.name || null)\n    );\n\n    // 2.\n    // - Expression used in the form ~ x += y\n    // - Simple version: ~ x++\n    if (this.expression) {\n      this.expression.GenerateIntoContainer(container);\n    } else {\n      container.AddContent(new IntValue(1));\n    }\n\n    // 3.\n    container.AddContent(\n      NativeFunctionCall.CallWithName(this.isInc ? \"+\" : \"-\")\n    );\n\n    // 4.\n    this._runtimeAssignment = new RuntimeVariableAssignment(\n      this.varIdentifier?.name || null,\n      false\n    );\n    container.AddContent(this._runtimeAssignment);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    const varResolveResult = context.ResolveVariableWithName(\n      this.varIdentifier?.name || \"\",\n      this\n    );\n\n    if (!varResolveResult.found) {\n      this.Error(\n        `variable for ${this.incrementDecrementWord} could not be found: '${this.varIdentifier}' after searching: {this.descriptionOfScope}`\n      );\n    }\n\n    if (!this._runtimeAssignment) {\n      throw new Error();\n    }\n\n    this._runtimeAssignment.isGlobal = varResolveResult.isGlobal;\n\n    if (\n      !(this.parent instanceof Weave) &&\n      !(this.parent instanceof FlowBase) &&\n      !(this.parent instanceof ContentList)\n    ) {\n      this.Error(`Can't use ${this.incrementDecrementWord} as sub-expression`);\n    }\n  }\n\n  get incrementDecrementWord(): \"increment\" | \"decrement\" {\n    if (this.isInc) {\n      return \"increment\";\n    }\n\n    return \"decrement\";\n  }\n\n  public readonly toString = (): string => {\n    if (this.expression) {\n      return `${this.varIdentifier?.name}${this.isInc ? \" += \" : \" -= \"}${\n        this.expression\n      }`;\n    }\n\n    return `${this.varIdentifier?.name}` + (this.isInc ? \"++\" : \"--\");\n  };\n}\n","import { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Story } from \"./Story\";\n\nexport class IncludedFile extends ParsedObject {\n  constructor(public readonly includedStory: Story | null) {\n    super();\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    // Left to the main story to process\n    return null;\n  };\n\n  get typeName(): string {\n    return \"IncludedFile\";\n  }\n}\n","export class InfixOperator {\n  constructor(\n    public readonly type: string,\n    public readonly precedence: number,\n    public readonly requireWhitespace: boolean\n  ) {}\n\n  public readonly toString = (): string => this.type;\n}\n","import { Argument } from \"./Argument\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { Identifier } from \"./Identifier\";\nimport { ParsedObject } from \"./Object\";\nimport { Story } from \"./Story\";\n\nexport class Knot extends FlowBase {\n  get flowLevel(): FlowLevel {\n    return FlowLevel.Knot;\n  }\n\n  constructor(\n    name: Identifier,\n    topLevelObjects: ParsedObject[],\n    args: Argument[],\n    isFunction: boolean\n  ) {\n    super(name, topLevelObjects, args, isFunction);\n  }\n\n  get typeName(): string {\n    return this.isFunction ? \"Function\" : \"Knot\";\n  }\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    let parentStory = this.story;\n\n    // Enforce rule that stitches must not have the same\n    // name as any knots that exist in the story\n    for (const stitchName in this.subFlowsByName) {\n      const knotWithStitchName = parentStory.ContentWithNameAtLevel(\n        stitchName,\n        FlowLevel.Knot,\n        false\n      );\n\n      if (knotWithStitchName) {\n        const stitch = this.subFlowsByName.get(stitchName);\n        const errorMsg = `Stitch '${\n          stitch ? stitch.name : \"NO STITCH FOUND\"\n        }' has the same name as a knot (on ${\n          knotWithStitchName.debugMetadata\n        })`;\n        this.Error(errorMsg, stitch);\n      }\n    }\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"../Expression/Expression\";\nimport { InkList as RuntimeInkList } from \"../../../../engine/InkList\";\nimport { InkListItem as RuntimeInkListItem } from \"../../../../engine/InkList\";\nimport { ListElementDefinition } from \"./ListElementDefinition\";\nimport { ListValue } from \"../../../../engine/Value\";\nimport { Identifier } from \"../Identifier\";\n\nexport class List extends Expression {\n  constructor(public readonly itemIdentifierList: Identifier[]) {\n    super();\n  }\n\n  get typeName(): string {\n    return \"List\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    const runtimeRawList = new RuntimeInkList();\n\n    if (this.itemIdentifierList != null) {\n      for (const itemIdentifier of this.itemIdentifierList) {\n        const nameParts = itemIdentifier?.name?.split(\".\") || [];\n\n        let listName: string | null = null;\n        let listItemName: string = \"\";\n        if (nameParts.length > 1) {\n          listName = nameParts[0];\n          listItemName = nameParts[1];\n        } else {\n          listItemName = nameParts[0];\n        }\n\n        const listItem = this.story.ResolveListItem(\n          listName,\n          listItemName,\n          this\n        ) as ListElementDefinition;\n\n        if (listItem === null) {\n          if (listName === null) {\n            this.Error(\n              `Could not find list definition that contains item '${itemIdentifier}'`\n            );\n          } else {\n            this.Error(`Could not find list item ${itemIdentifier}`);\n          }\n        } else {\n          if (listItem.parent == null) {\n            this.Error(\n              `Could not find list definition for item ${itemIdentifier}`\n            );\n            return;\n          }\n          if (!listName) {\n            listName = listItem.parent.identifier?.name || null;\n          }\n\n          const item = new RuntimeInkListItem(listName, listItem.name || null);\n\n          if (runtimeRawList.has(item.serialized())) {\n            this.Warning(`Duplicate of item '${itemIdentifier}' in list.`);\n          } else {\n            runtimeRawList.Add(item, listItem.seriesValue);\n          }\n        }\n      }\n    }\n\n    container.AddContent(new ListValue(runtimeRawList));\n  };\n}\n","import { ListDefinition } from \"./ListDefinition\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ListElementDefinition extends ParsedObject {\n  public seriesValue: number = 0;\n\n  public parent: ListDefinition | null = null;\n\n  get fullName(): string {\n    const parentList = this.parent;\n    if (parentList === null) {\n      throw new Error(\"Can't get full name without a parent list.\");\n    }\n\n    return `${parentList.identifier?.name}.${this.name}`;\n  }\n\n  get typeName(): string {\n    return \"ListElement\";\n  }\n\n  get name(): string | null {\n    return this.indentifier?.name || null;\n  }\n\n  constructor(\n    public readonly indentifier: Identifier,\n    public readonly inInitialList: boolean,\n    public readonly explicitValue: number | null = null\n  ) {\n    super();\n    this.parent = super.parent as ListDefinition;\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    throw new Error(\"Not implemented.\");\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n    context.CheckForNamingCollisions(\n      this,\n      this.indentifier,\n      SymbolType.ListItem\n    );\n  }\n\n  public readonly toString = (): string => this.fullName;\n}\n","import { Argument } from \"./Argument\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { Identifier } from \"./Identifier\";\nimport { ParsedObject } from \"./Object\";\n\nexport class Stitch extends FlowBase {\n  get flowLevel(): FlowLevel {\n    return FlowLevel.Stitch;\n  }\n\n  constructor(\n    name: Identifier,\n    topLevelObjects: ParsedObject[],\n    args: Argument[],\n    isFunction: boolean\n  ) {\n    super(name, topLevelObjects, args, isFunction);\n  }\n\n  get typeName(): string {\n    return \"Stitch\";\n  }\n\n  public toString = (): string => {\n    return `${\n      this.parent !== null ? this.parent + \" > \" : \"\"\n    }${super.toString()}`;\n  };\n}\n","import { InkObject } from \"./Object\";\n\n// New version of tags is dynamic - it constructs the tags\n// at runtime based on BeginTag and EndTag control commands.\n// Plain text that's in the output stream is turned into tags\n// when you do story.currentTags.\n// The only place this is used is when flattening tags down\n// to string in advance, during dynamic string generation if\n// there's a tag embedded in it. See how ControlCommand.EndString\n// is implemented in Story.cs for more details + comment\nexport class Tag extends InkObject {\n  public readonly text: string;\n\n  constructor(tagText: string) {\n    super();\n    this.text = tagText.toString() || \"\";\n  }\n\n  public toString(): string {\n    return \"# \" + this.text;\n  }\n}\n","import { Path } from \"./Path\";\nimport { CallStack } from \"./CallStack\";\nimport { throwNullException } from \"./NullException\";\nimport { InkObject } from \"./Object\";\n\nexport class Choice extends InkObject {\n  public text: string = \"\";\n  public index: number = 0;\n  public threadAtGeneration: CallStack.Thread | null = null;\n  public sourcePath: string = \"\";\n  public targetPath: Path | null = null;\n  public isInvisibleDefault: boolean = false;\n  public tags: string[] | null = null;\n  public originalThreadIndex: number = 0;\n\n  get pathStringOnChoice(): string {\n    if (this.targetPath === null)\n      return throwNullException(\"Choice.targetPath\");\n    return this.targetPath.toString();\n  }\n  set pathStringOnChoice(value: string) {\n    this.targetPath = new Path(value);\n  }\n}\n","import { InkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { TryGetResult } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ListDefinitionsOrigin {\n  protected _lists: Map<string, ListDefinition>;\n  protected _allUnambiguousListValueCache: Map<string, ListValue>;\n\n  constructor(lists: ListDefinition[]) {\n    this._lists = new Map();\n    this._allUnambiguousListValueCache = new Map();\n\n    for (let list of lists) {\n      this._lists.set(list.name, list);\n\n      for (let [key, val] of list.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        let listValue = new ListValue(item, val);\n\n        if (!item.itemName) {\n          throw new Error(\"item.itemName is null or undefined.\");\n        }\n\n        this._allUnambiguousListValueCache.set(item.itemName, listValue);\n        this._allUnambiguousListValueCache.set(item.fullName, listValue);\n      }\n    }\n  }\n  get lists(): ListDefinition[] {\n    let listOfLists: ListDefinition[] = [];\n\n    for (let [, value] of this._lists) {\n      listOfLists.push(value);\n    }\n\n    return listOfLists;\n  }\n  public TryListGetDefinition(\n    name: string | null,\n    /* out */ def: ListDefinition | null\n  ): TryGetResult<ListDefinition | null> {\n    if (name === null) {\n      return { result: def, exists: false };\n    }\n    // initially, this function returns a boolean and the second parameter is an out.\n    let definition = this._lists.get(name);\n    if (!definition) return { result: def, exists: false };\n\n    return { result: definition, exists: true };\n  }\n  public FindSingleItemListWithName(name: string | null) {\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let val = this._allUnambiguousListValueCache.get(name);\n\n    if (typeof val !== \"undefined\") {\n      return val;\n    }\n\n    return null;\n  }\n}\n","import { Container } from \"./Container\";\nimport {\n  Value,\n  IntValue,\n  FloatValue,\n  StringValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n  BoolValue,\n} from \"./Value\";\nimport { Glue } from \"./Glue\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { Divert } from \"./Divert\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { VariableReference } from \"./VariableReference\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { Path } from \"./Path\";\nimport { Choice } from \"./Choice\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { InkListItem, InkList } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class JsonSerialisation {\n  public static JArrayToRuntimeObjList(\n    jArray: any[],\n    skipLast: boolean = false\n  ) {\n    let count = jArray.length;\n    if (skipLast) count--;\n\n    let list: InkObject[] = [];\n\n    for (let i = 0; i < count; i++) {\n      let jTok = jArray[i];\n      let runtimeObj = this.JTokenToRuntimeObject(jTok);\n      if (runtimeObj === null) {\n        return throwNullException(\"runtimeObj\");\n      }\n      list.push(runtimeObj);\n    }\n\n    return list;\n  }\n\n  public static WriteDictionaryRuntimeObjs(\n    writer: SimpleJson.Writer,\n    dictionary: Map<string, InkObject>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dictionary) {\n      writer.WritePropertyStart(key);\n      this.WriteRuntimeObject(writer, value);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteListRuntimeObjs(\n    writer: SimpleJson.Writer,\n    list: InkObject[]\n  ) {\n    writer.WriteArrayStart();\n    for (let value of list) {\n      this.WriteRuntimeObject(writer, value);\n    }\n    writer.WriteArrayEnd();\n  }\n\n  public static WriteIntDictionary(\n    writer: SimpleJson.Writer,\n    dict: Map<string, number>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dict) {\n      writer.WriteIntProperty(key, value);\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteRuntimeObject(\n    writer: SimpleJson.Writer,\n    obj: InkObject\n  ): void {\n    let container = asOrNull(obj, Container);\n    if (container) {\n      this.WriteRuntimeContainer(writer, container);\n      return;\n    }\n\n    let divert = asOrNull(obj, Divert);\n    if (divert) {\n      let divTypeKey = \"->\";\n      if (divert.isExternal) {\n        divTypeKey = \"x()\";\n      } else if (divert.pushesToStack) {\n        if (divert.stackPushType == PushPopType.Function) {\n          divTypeKey = \"f()\";\n        } else if (divert.stackPushType == PushPopType.Tunnel) {\n          divTypeKey = \"->t->\";\n        }\n      }\n\n      let targetStr;\n      if (divert.hasVariableTarget) {\n        targetStr = divert.variableDivertName;\n      } else {\n        targetStr = divert.targetPathString;\n      }\n\n      writer.WriteObjectStart();\n      writer.WriteProperty(divTypeKey, targetStr);\n\n      if (divert.hasVariableTarget) {\n        writer.WriteProperty(\"var\", true);\n      }\n\n      if (divert.isConditional) {\n        writer.WriteProperty(\"c\", true);\n      }\n\n      if (divert.externalArgs > 0) {\n        writer.WriteIntProperty(\"exArgs\", divert.externalArgs);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choicePoint = asOrNull(obj, ChoicePoint);\n    if (choicePoint) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);\n      writer.WriteIntProperty(\"flg\", choicePoint.flags);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let boolVal = asOrNull(obj, BoolValue);\n    if (boolVal) {\n      writer.WriteBool(boolVal.value);\n      return;\n    }\n\n    let intVal = asOrNull(obj, IntValue);\n    if (intVal) {\n      writer.WriteInt(intVal.value);\n      return;\n    }\n\n    let floatVal = asOrNull(obj, FloatValue);\n    if (floatVal) {\n      writer.WriteFloat(floatVal.value);\n      return;\n    }\n\n    let strVal = asOrNull(obj, StringValue);\n    if (strVal) {\n      if (strVal.isNewline) {\n        writer.Write(\"\\n\", false);\n      } else {\n        writer.WriteStringStart();\n        writer.WriteStringInner(\"^\");\n        writer.WriteStringInner(strVal.value);\n        writer.WriteStringEnd();\n      }\n      return;\n    }\n\n    let listVal = asOrNull(obj, ListValue);\n    if (listVal) {\n      this.WriteInkList(writer, listVal);\n      return;\n    }\n\n    let divTargetVal = asOrNull(obj, DivertTargetValue);\n    if (divTargetVal) {\n      writer.WriteObjectStart();\n      if (divTargetVal.value === null) {\n        return throwNullException(\"divTargetVal.value\");\n      }\n      writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let varPtrVal = asOrNull(obj, VariablePointerValue);\n    if (varPtrVal) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"^var\", varPtrVal.value);\n      writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let glue = asOrNull(obj, Glue);\n    if (glue) {\n      writer.Write(\"<>\");\n      return;\n    }\n\n    let controlCmd = asOrNull(obj, ControlCommand);\n    if (controlCmd) {\n      writer.Write(\n        JsonSerialisation._controlCommandNames[controlCmd.commandType]\n      );\n      return;\n    }\n\n    let nativeFunc = asOrNull(obj, NativeFunctionCall);\n    if (nativeFunc) {\n      let name = nativeFunc.name;\n\n      if (name == \"^\") name = \"L^\";\n\n      writer.Write(name);\n      return;\n    }\n\n    let varRef = asOrNull(obj, VariableReference);\n    if (varRef) {\n      writer.WriteObjectStart();\n      let readCountPath = varRef.pathStringForCount;\n      if (readCountPath != null) {\n        writer.WriteProperty(\"CNT?\", readCountPath);\n      } else {\n        writer.WriteProperty(\"VAR?\", varRef.name);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let varAss = asOrNull(obj, VariableAssignment);\n    if (varAss) {\n      writer.WriteObjectStart();\n\n      let key = varAss.isGlobal ? \"VAR=\" : \"temp=\";\n      writer.WriteProperty(key, varAss.variableName);\n\n      // Reassignment?\n      if (!varAss.isNewDeclaration) writer.WriteProperty(\"re\", true);\n\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let voidObj = asOrNull(obj, Void);\n    if (voidObj) {\n      writer.Write(\"void\");\n      return;\n    }\n\n    let tag = asOrNull(obj, Tag);\n    if (tag) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"#\", tag.text);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choice = asOrNull(obj, Choice);\n    if (choice) {\n      this.WriteChoice(writer, choice);\n      return;\n    }\n\n    throw new Error(\"Failed to convert runtime object to Json token: \" + obj);\n  }\n\n  public static JObjectToDictionaryRuntimeObjs(jObject: Record<string, any>) {\n    let dict: Map<string, InkObject> = new Map();\n\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        let inkObject = this.JTokenToRuntimeObject(jObject[key]);\n        if (inkObject === null) {\n          return throwNullException(\"inkObject\");\n        }\n        dict.set(key, inkObject);\n      }\n    }\n\n    return dict;\n  }\n\n  public static JObjectToIntDictionary(jObject: Record<string, any>) {\n    let dict: Map<string, number> = new Map();\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        dict.set(key, parseInt(jObject[key]));\n      }\n    }\n    return dict;\n  }\n\n  public static JTokenToRuntimeObject(token: any): InkObject | null {\n    if (\n      (typeof token === \"number\" && !isNaN(token)) ||\n      typeof token === \"boolean\"\n    ) {\n      return Value.Create(token);\n    }\n\n    if (typeof token === \"string\") {\n      let str = token.toString();\n\n      // String value\n      let firstChar = str[0];\n      if (firstChar == \"^\") return new StringValue(str.substring(1));\n      else if (firstChar == \"\\n\" && str.length == 1)\n        return new StringValue(\"\\n\");\n\n      // Glue\n      if (str == \"<>\") return new Glue();\n\n      // Control commands (would looking up in a hash set be faster?)\n      for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n        let cmdName = JsonSerialisation._controlCommandNames[i];\n        if (str == cmdName) {\n          return new ControlCommand(i);\n        }\n      }\n\n      // Native functions\n      if (str == \"L^\") str = \"^\";\n      if (NativeFunctionCall.CallExistsWithName(str))\n        return NativeFunctionCall.CallWithName(str);\n\n      // Pop\n      if (str == \"->->\") return ControlCommand.PopTunnel();\n      else if (str == \"~ret\") return ControlCommand.PopFunction();\n\n      // Void\n      if (str == \"void\") return new Void();\n    }\n\n    if (typeof token === \"object\" && !Array.isArray(token)) {\n      let obj = token as Record<string, any>;\n      let propValue;\n\n      // Divert target value to path\n      if (obj[\"^->\"]) {\n        propValue = obj[\"^->\"];\n        return new DivertTargetValue(new Path(propValue.toString()));\n      }\n\n      // VariablePointerValue\n      if (obj[\"^var\"]) {\n        propValue = obj[\"^var\"];\n        let varPtr = new VariablePointerValue(propValue.toString());\n        if (\"ci\" in obj) {\n          propValue = obj[\"ci\"];\n          varPtr.contextIndex = parseInt(propValue);\n        }\n        return varPtr;\n      }\n\n      // Divert\n      let isDivert = false;\n      let pushesToStack = false;\n      let divPushType = PushPopType.Function;\n      let external = false;\n      if ((propValue = obj[\"->\"])) {\n        isDivert = true;\n      } else if ((propValue = obj[\"f()\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Function;\n      } else if ((propValue = obj[\"->t->\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Tunnel;\n      } else if ((propValue = obj[\"x()\"])) {\n        isDivert = true;\n        external = true;\n        pushesToStack = false;\n        divPushType = PushPopType.Function;\n      }\n\n      if (isDivert) {\n        let divert = new Divert();\n        divert.pushesToStack = pushesToStack;\n        divert.stackPushType = divPushType;\n        divert.isExternal = external;\n\n        let target = propValue.toString();\n\n        if ((propValue = obj[\"var\"])) divert.variableDivertName = target;\n        else divert.targetPathString = target;\n\n        divert.isConditional = !!obj[\"c\"];\n\n        if (external) {\n          if ((propValue = obj[\"exArgs\"]))\n            divert.externalArgs = parseInt(propValue);\n        }\n\n        return divert;\n      }\n\n      // Choice\n      if ((propValue = obj[\"*\"])) {\n        let choice = new ChoicePoint();\n        choice.pathStringOnChoice = propValue.toString();\n\n        if ((propValue = obj[\"flg\"])) choice.flags = parseInt(propValue);\n\n        return choice;\n      }\n\n      // Variable reference\n      if ((propValue = obj[\"VAR?\"])) {\n        return new VariableReference(propValue.toString());\n      } else if ((propValue = obj[\"CNT?\"])) {\n        let readCountVarRef = new VariableReference();\n        readCountVarRef.pathStringForCount = propValue.toString();\n        return readCountVarRef;\n      }\n\n      // Variable assignment\n      let isVarAss = false;\n      let isGlobalVar = false;\n      if ((propValue = obj[\"VAR=\"])) {\n        isVarAss = true;\n        isGlobalVar = true;\n      } else if ((propValue = obj[\"temp=\"])) {\n        isVarAss = true;\n        isGlobalVar = false;\n      }\n      if (isVarAss) {\n        let varName = propValue.toString();\n        let isNewDecl = !obj[\"re\"];\n        let varAss = new VariableAssignment(varName, isNewDecl);\n        varAss.isGlobal = isGlobalVar;\n        return varAss;\n      }\n      if (obj[\"#\"] !== undefined) {\n        propValue = obj[\"#\"];\n        return new Tag(propValue.toString());\n      }\n\n      // List value\n      if ((propValue = obj[\"list\"])) {\n        // var listContent = (Dictionary<string, object>)propValue;\n        let listContent = propValue as Record<string, any>;\n        let rawList = new InkList();\n        if ((propValue = obj[\"origins\"])) {\n          // var namesAsObjs = (List<object>)propValue;\n          let namesAsObjs = propValue as string[];\n          // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n          rawList.SetInitialOriginNames(namesAsObjs);\n        }\n\n        for (let key in listContent) {\n          if (listContent.hasOwnProperty(key)) {\n            let nameToVal = listContent[key];\n            let item = new InkListItem(key);\n            let val = parseInt(nameToVal);\n            rawList.Add(item, val);\n          }\n        }\n\n        return new ListValue(rawList);\n      }\n\n      if (obj[\"originalChoicePath\"] != null) return this.JObjectToChoice(obj);\n    }\n\n    // Array is always a Runtime.Container\n    if (Array.isArray(token)) {\n      return this.JArrayToContainer(token);\n    }\n\n    if (token === null || token === undefined) return null;\n\n    throw new Error(\n      \"Failed to convert token to runtime object: \" +\n        this.toJson(token, [\"parent\"])\n    );\n  }\n\n  public static toJson<T>(\n    me: T,\n    removes?: (keyof T)[],\n    space?: number\n  ): string {\n    return JSON.stringify(\n      me,\n      (k, v) => (removes?.some((r) => r === k) ? undefined : v),\n      space\n    );\n  }\n\n  public static WriteRuntimeContainer(\n    writer: SimpleJson.Writer,\n    container: Container | null,\n    withoutName: boolean = false\n  ) {\n    writer.WriteArrayStart();\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    for (let c of container.content) this.WriteRuntimeObject(writer, c);\n\n    let namedOnlyContent = container.namedOnlyContent;\n    let countFlags = container.countFlags;\n    let hasNameProperty = container.name != null && !withoutName;\n\n    let hasTerminator =\n      namedOnlyContent != null || countFlags > 0 || hasNameProperty;\n    if (hasTerminator) {\n      writer.WriteObjectStart();\n    }\n\n    if (namedOnlyContent != null) {\n      for (let [key, value] of namedOnlyContent) {\n        let name = key;\n        let namedContainer = asOrNull(value, Container);\n        writer.WritePropertyStart(name);\n        this.WriteRuntimeContainer(writer, namedContainer, true);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (countFlags > 0) writer.WriteIntProperty(\"#f\", countFlags);\n\n    if (hasNameProperty) writer.WriteProperty(\"#n\", container.name);\n\n    if (hasTerminator) writer.WriteObjectEnd();\n    else writer.WriteNull();\n\n    writer.WriteArrayEnd();\n  }\n\n  public static JArrayToContainer(jArray: any[]) {\n    let container = new Container();\n    container.content = this.JArrayToRuntimeObjList(jArray, true);\n\n    let terminatingObj = jArray[jArray.length - 1] as Record<string, any>;\n    if (terminatingObj != null) {\n      let namedOnlyContent = new Map();\n\n      for (let key in terminatingObj) {\n        if (key == \"#f\") {\n          container.countFlags = parseInt(terminatingObj[key]);\n        } else if (key == \"#n\") {\n          container.name = terminatingObj[key].toString();\n        } else {\n          let namedContentItem = this.JTokenToRuntimeObject(\n            terminatingObj[key]\n          );\n          // var namedSubContainer = namedContentItem as Container;\n          let namedSubContainer = asOrNull(namedContentItem, Container);\n          if (namedSubContainer) namedSubContainer.name = key;\n          namedOnlyContent.set(key, namedContentItem);\n        }\n      }\n\n      container.namedOnlyContent = namedOnlyContent;\n    }\n\n    return container;\n  }\n\n  public static JObjectToChoice(jObj: Record<string, any>) {\n    let choice = new Choice();\n    choice.text = jObj[\"text\"].toString();\n    choice.index = parseInt(jObj[\"index\"]);\n    choice.sourcePath = jObj[\"originalChoicePath\"].toString();\n    choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);\n    choice.pathStringOnChoice = jObj[\"targetPath\"].toString();\n    if (jObj[\"tags\"]) {\n      choice.tags = jObj[\"tags\"];\n    }\n    return choice;\n  }\n\n  public static WriteChoice(writer: SimpleJson.Writer, choice: Choice) {\n    writer.WriteObjectStart();\n    writer.WriteProperty(\"text\", choice.text);\n    writer.WriteIntProperty(\"index\", choice.index);\n    writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);\n    writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);\n    writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);\n    if (choice.tags) {\n      writer.WriteProperty(\"tags\", (w) => {\n        w.WriteArrayStart();\n        for (const tag of choice.tags!) {\n          w.WriteStringStart();\n          w.WriteStringInner(tag);\n          w.WriteStringEnd();\n        }\n        w.WriteArrayEnd();\n      });\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteInkList(writer: SimpleJson.Writer, listVal: ListValue) {\n    let rawList = listVal.value;\n    if (rawList === null) {\n      return throwNullException(\"rawList\");\n    }\n\n    writer.WriteObjectStart();\n    writer.WritePropertyStart(\"list\");\n    writer.WriteObjectStart();\n\n    for (let [key, val] of rawList) {\n      let item = InkListItem.fromSerializedKey(key);\n      let itemVal = val;\n\n      if (item.itemName === null) {\n        return throwNullException(\"item.itemName\");\n      }\n\n      writer.WritePropertyNameStart();\n      writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");\n      writer.WritePropertyNameInner(\".\");\n      writer.WritePropertyNameInner(item.itemName);\n      writer.WritePropertyNameEnd();\n\n      writer.Write(itemVal);\n\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    writer.WritePropertyEnd();\n\n    if (\n      rawList.Count == 0 &&\n      rawList.originNames != null &&\n      rawList.originNames.length > 0\n    ) {\n      writer.WritePropertyStart(\"origins\");\n      writer.WriteArrayStart();\n      for (let name of rawList.originNames) writer.Write(name);\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n  }\n\n  public static ListDefinitionsToJToken(origin: ListDefinitionsOrigin) {\n    let result: Record<string, any> = {};\n\n    for (let def of origin.lists) {\n      let listDefJson: Record<string, any> = {};\n\n      for (let [key, val] of def.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.itemName === null) {\n          return throwNullException(\"item.itemName\");\n        }\n        listDefJson[item.itemName] = val;\n      }\n\n      result[def.name] = listDefJson;\n    }\n\n    return result;\n  }\n\n  public static JTokenToListDefinitions(obj: Record<string, any>) {\n    // var defsObj = (Dictionary<string, object>)obj;\n    let defsObj = obj;\n\n    let allDefs: ListDefinition[] = [];\n\n    for (let key in defsObj) {\n      if (defsObj.hasOwnProperty(key)) {\n        let name = key.toString();\n        // var listDefJson = (Dictionary<string, object>)kv.Value;\n        let listDefJson = defsObj[key] as Record<string, any>;\n\n        // Cast (string, object) to (string, int) for items\n        let items: Map<string, number> = new Map();\n\n        for (let nameValueKey in listDefJson) {\n          if (defsObj.hasOwnProperty(key)) {\n            let nameValue = listDefJson[nameValueKey];\n            items.set(nameValueKey, parseInt(nameValue));\n          }\n        }\n\n        let def = new ListDefinition(name, items);\n        allDefs.push(def);\n      }\n    }\n\n    return new ListDefinitionsOrigin(allDefs);\n  }\n\n  private static _controlCommandNames = (() => {\n    let _controlCommandNames: string[] = [];\n\n    _controlCommandNames[ControlCommand.CommandType.EvalStart] = \"ev\";\n    _controlCommandNames[ControlCommand.CommandType.EvalOutput] = \"out\";\n    _controlCommandNames[ControlCommand.CommandType.EvalEnd] = \"/ev\";\n    _controlCommandNames[ControlCommand.CommandType.Duplicate] = \"du\";\n    _controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";\n    _controlCommandNames[ControlCommand.CommandType.PopFunction] = \"~ret\";\n    _controlCommandNames[ControlCommand.CommandType.PopTunnel] = \"->->\";\n    _controlCommandNames[ControlCommand.CommandType.BeginString] = \"str\";\n    _controlCommandNames[ControlCommand.CommandType.EndString] = \"/str\";\n    _controlCommandNames[ControlCommand.CommandType.NoOp] = \"nop\";\n    _controlCommandNames[ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";\n    _controlCommandNames[ControlCommand.CommandType.Turns] = \"turn\";\n    _controlCommandNames[ControlCommand.CommandType.TurnsSince] = \"turns\";\n    _controlCommandNames[ControlCommand.CommandType.ReadCount] = \"readc\";\n    _controlCommandNames[ControlCommand.CommandType.Random] = \"rnd\";\n    _controlCommandNames[ControlCommand.CommandType.SeedRandom] = \"srnd\";\n    _controlCommandNames[ControlCommand.CommandType.VisitIndex] = \"visit\";\n    _controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex] =\n      \"seq\";\n    _controlCommandNames[ControlCommand.CommandType.StartThread] = \"thread\";\n    _controlCommandNames[ControlCommand.CommandType.Done] = \"done\";\n    _controlCommandNames[ControlCommand.CommandType.End] = \"end\";\n    _controlCommandNames[ControlCommand.CommandType.ListFromInt] = \"listInt\";\n    _controlCommandNames[ControlCommand.CommandType.ListRange] = \"range\";\n    _controlCommandNames[ControlCommand.CommandType.ListRandom] = \"lrnd\";\n    _controlCommandNames[ControlCommand.CommandType.BeginTag] = \"#\";\n    _controlCommandNames[ControlCommand.CommandType.EndTag] = \"/#\";\n\n    for (let i = 0; i < ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n      if (_controlCommandNames[i] == null)\n        throw new Error(\"Control command not accounted for in serialisation\");\n    }\n\n    return _controlCommandNames;\n  })();\n}\n","import { PushPopType } from \"./PushPop\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { ListValue } from \"./Value\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { Pointer } from \"./Pointer\";\nimport { InkObject } from \"./Object\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class CallStack {\n  get elements() {\n    return this.callStack;\n  }\n\n  get depth() {\n    return this.elements.length;\n  }\n\n  get currentElement() {\n    let thread = this._threads[this._threads.length - 1];\n    let cs = thread.callstack;\n    return cs[cs.length - 1];\n  }\n\n  get currentElementIndex() {\n    return this.callStack.length - 1;\n  }\n\n  get currentThread(): CallStack.Thread {\n    return this._threads[this._threads.length - 1];\n  }\n  set currentThread(value: CallStack.Thread) {\n    Debug.Assert(\n      this._threads.length == 1,\n      \"Shouldn't be directly setting the current thread when we have a stack of them\"\n    );\n\n    this._threads.length = 0;\n    this._threads.push(value);\n  }\n\n  get canPop() {\n    return this.callStack.length > 1;\n  }\n\n  constructor(storyContext: Story);\n  constructor(toCopy: CallStack);\n  constructor() {\n    if (arguments[0] instanceof Story) {\n      let storyContext = arguments[0] as Story;\n\n      this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n      this.Reset();\n    } else {\n      let toCopy = arguments[0] as CallStack;\n\n      this._threads = [];\n      for (let otherThread of toCopy._threads) {\n        this._threads.push(otherThread.Copy());\n      }\n      this._threadCounter = toCopy._threadCounter;\n      this._startOfRoot = toCopy._startOfRoot.copy();\n    }\n  }\n\n  public Reset() {\n    this._threads = [];\n    this._threads.push(new CallStack.Thread());\n\n    this._threads[0].callstack.push(\n      new CallStack.Element(PushPopType.Tunnel, this._startOfRoot)\n    );\n  }\n\n  public SetJsonToken(jObject: Record<string, any>, storyContext: Story) {\n    this._threads.length = 0;\n\n    // TODO: (List<object>) jObject [\"threads\"];\n    let jThreads: any[] = jObject[\"threads\"];\n\n    for (let jThreadTok of jThreads) {\n      // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n      let jThreadObj = jThreadTok;\n      let thread = new CallStack.Thread(jThreadObj, storyContext);\n      this._threads.push(thread);\n    }\n\n    // TODO: (int)jObject [\"threadCounter\"];\n    this._threadCounter = parseInt(jObject[\"threadCounter\"]);\n    this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n  }\n  public WriteJson(w: SimpleJson.Writer) {\n    w.WriteObject((writer) => {\n      writer.WritePropertyStart(\"threads\");\n      writer.WriteArrayStart();\n\n      for (let thread of this._threads) {\n        thread.WriteJson(writer);\n      }\n\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WritePropertyStart(\"threadCounter\");\n      writer.WriteInt(this._threadCounter);\n      writer.WritePropertyEnd();\n    });\n  }\n\n  public PushThread() {\n    let newThread = this.currentThread.Copy();\n    this._threadCounter++;\n    newThread.threadIndex = this._threadCounter;\n    this._threads.push(newThread);\n  }\n\n  public ForkThread() {\n    let forkedThread = this.currentThread.Copy();\n    this._threadCounter++;\n    forkedThread.threadIndex = this._threadCounter;\n    return forkedThread;\n  }\n\n  public PopThread() {\n    if (this.canPopThread) {\n      this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()\n    } else {\n      throw new Error(\"Can't pop thread\");\n    }\n  }\n\n  get canPopThread() {\n    return this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n  }\n\n  get elementIsEvaluateFromGame() {\n    return this.currentElement.type == PushPopType.FunctionEvaluationFromGame;\n  }\n\n  public Push(\n    type: PushPopType,\n    externalEvaluationStackHeight: number = 0,\n    outputStreamLengthWithPushed: number = 0\n  ) {\n    let element = new CallStack.Element(\n      type,\n      this.currentElement.currentPointer,\n      false\n    );\n\n    element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n    element.functionStartInOutputStream = outputStreamLengthWithPushed;\n\n    this.callStack.push(element);\n  }\n\n  public CanPop(type: PushPopType | null = null) {\n    if (!this.canPop) return false;\n\n    if (type == null) return true;\n\n    return this.currentElement.type == type;\n  }\n\n  public Pop(type: PushPopType | null = null) {\n    if (this.CanPop(type)) {\n      this.callStack.pop();\n      return;\n    } else {\n      throw new Error(\"Mismatched push/pop in Callstack\");\n    }\n  }\n\n  public GetTemporaryVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    let varValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (varValue.exists) {\n      return varValue.result;\n    } else {\n      return null;\n    }\n  }\n\n  public SetTemporaryVariable(\n    name: string,\n    value: any,\n    declareNew: boolean,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    if (!declareNew && !contextElement.temporaryVariables.get(name)) {\n      throw new Error(\"Could not find temporary variable to set: \" + name);\n    }\n\n    let oldValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (oldValue.exists)\n      ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n\n    contextElement.temporaryVariables.set(name, value);\n  }\n\n  public ContextForVariableNamed(name: string) {\n    if (this.currentElement.temporaryVariables.get(name)) {\n      return this.currentElementIndex + 1;\n    } else {\n      return 0;\n    }\n  }\n\n  public ThreadWithIndex(index: number) {\n    let filtered = this._threads.filter((t) => {\n      if (t.threadIndex == index) return t;\n    });\n\n    return filtered.length > 0 ? filtered[0] : null;\n  }\n\n  get callStack() {\n    return this.currentThread.callstack;\n  }\n\n  get callStackTrace() {\n    let sb = new StringBuilder();\n\n    for (let t = 0; t < this._threads.length; t++) {\n      let thread = this._threads[t];\n      let isCurrent = t == this._threads.length - 1;\n      sb.AppendFormat(\n        \"=== THREAD {0}/{1} {2}===\\n\",\n        t + 1,\n        this._threads.length,\n        isCurrent ? \"(current) \" : \"\"\n      );\n\n      for (let i = 0; i < thread.callstack.length; i++) {\n        if (thread.callstack[i].type == PushPopType.Function)\n          sb.Append(\"  [FUNCTION] \");\n        else sb.Append(\"  [TUNNEL] \");\n\n        let pointer = thread.callstack[i].currentPointer;\n        if (!pointer.isNull) {\n          sb.Append(\"<SOMEWHERE IN \");\n          if (pointer.container === null) {\n            return throwNullException(\"pointer.container\");\n          }\n          sb.Append(pointer.container.path.toString());\n          sb.AppendLine(\">\");\n        }\n      }\n    }\n\n    return sb.toString();\n  }\n\n  public _threads!: CallStack.Thread[]; // Banged because it's initialized in Reset().\n  public _threadCounter: number = 0;\n  public _startOfRoot: Pointer = Pointer.Null;\n}\n\nexport namespace CallStack {\n  export class Element {\n    public currentPointer: Pointer;\n    public inExpressionEvaluation: boolean;\n    public temporaryVariables: Map<string, InkObject>;\n    public type: PushPopType;\n\n    public evaluationStackHeightWhenPushed: number = 0;\n    public functionStartInOutputStream: number = 0;\n\n    constructor(\n      type: PushPopType,\n      pointer: Pointer,\n      inExpressionEvaluation: boolean = false\n    ) {\n      this.currentPointer = pointer.copy();\n      this.inExpressionEvaluation = inExpressionEvaluation;\n      this.temporaryVariables = new Map();\n      this.type = type;\n    }\n\n    public Copy() {\n      let copy = new Element(\n        this.type,\n        this.currentPointer,\n        this.inExpressionEvaluation\n      );\n      copy.temporaryVariables = new Map(this.temporaryVariables);\n      copy.evaluationStackHeightWhenPushed =\n        this.evaluationStackHeightWhenPushed;\n      copy.functionStartInOutputStream = this.functionStartInOutputStream;\n      return copy;\n    }\n  }\n\n  export class Thread {\n    public callstack: Element[];\n    public threadIndex: number = 0;\n    public previousPointer: Pointer = Pointer.Null;\n\n    constructor();\n    constructor(jThreadObj: any, storyContext: Story);\n    constructor() {\n      this.callstack = [];\n\n      if (arguments[0] && arguments[1]) {\n        let jThreadObj = arguments[0];\n        let storyContext = arguments[1];\n\n        // TODO: (int) jThreadObj['threadIndex'] can raise;\n        this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);\n\n        let jThreadCallstack = jThreadObj[\"callstack\"];\n\n        for (let jElTok of jThreadCallstack) {\n          let jElementObj = jElTok;\n\n          // TODO: (int) jElementObj['type'] can raise;\n          let pushPopType: PushPopType = parseInt(jElementObj[\"type\"]);\n\n          let pointer = Pointer.Null;\n\n          let currentContainerPathStr: string;\n          // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n          let currentContainerPathStrToken = jElementObj[\"cPath\"];\n          if (typeof currentContainerPathStrToken !== \"undefined\") {\n            currentContainerPathStr = currentContainerPathStrToken.toString();\n\n            let threadPointerResult = storyContext.ContentAtPath(\n              new Path(currentContainerPathStr)\n            );\n            pointer.container = threadPointerResult.container;\n            pointer.index = parseInt(jElementObj[\"idx\"]);\n\n            if (threadPointerResult.obj == null)\n              throw new Error(\n                \"When loading state, internal story location couldn't be found: \" +\n                  currentContainerPathStr +\n                  \". Has the story changed since this save data was created?\"\n              );\n            else if (threadPointerResult.approximate) {\n              if (pointer.container === null) {\n                return throwNullException(\"pointer.container\");\n              }\n              storyContext.Warning(\n                \"When loading state, exact internal story location couldn't be found: '\" +\n                  currentContainerPathStr +\n                  \"', so it was approximated to '\" +\n                  pointer.container.path.toString() +\n                  \"' to recover. Has the story changed since this save data was created?\"\n              );\n            }\n          }\n\n          let inExpressionEvaluation = !!jElementObj[\"exp\"];\n\n          let el = new Element(pushPopType, pointer, inExpressionEvaluation);\n\n          let temps = jElementObj[\"temp\"];\n          if (typeof temps !== \"undefined\") {\n            el.temporaryVariables =\n              JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);\n          } else {\n            el.temporaryVariables.clear();\n          }\n\n          this.callstack.push(el);\n        }\n\n        let prevContentObjPath = jThreadObj[\"previousContentObject\"];\n        if (typeof prevContentObjPath !== \"undefined\") {\n          let prevPath = new Path(prevContentObjPath.toString());\n          this.previousPointer = storyContext.PointerAtPath(prevPath);\n        }\n      }\n    }\n\n    public Copy() {\n      let copy = new Thread();\n      copy.threadIndex = this.threadIndex;\n      for (let e of this.callstack) {\n        copy.callstack.push(e.Copy());\n      }\n      copy.previousPointer = this.previousPointer.copy();\n      return copy;\n    }\n\n    public WriteJson(writer: SimpleJson.Writer) {\n      writer.WriteObjectStart();\n\n      writer.WritePropertyStart(\"callstack\");\n      writer.WriteArrayStart();\n      for (let el of this.callstack) {\n        writer.WriteObjectStart();\n        if (!el.currentPointer.isNull) {\n          if (el.currentPointer.container === null) {\n            return throwNullException(\"el.currentPointer.container\");\n          }\n          writer.WriteProperty(\n            \"cPath\",\n            el.currentPointer.container.path.componentsString\n          );\n          writer.WriteIntProperty(\"idx\", el.currentPointer.index);\n        }\n\n        writer.WriteProperty(\"exp\", el.inExpressionEvaluation);\n        writer.WriteIntProperty(\"type\", el.type);\n\n        if (el.temporaryVariables.size > 0) {\n          writer.WritePropertyStart(\"temp\");\n          JsonSerialisation.WriteDictionaryRuntimeObjs(\n            writer,\n            el.temporaryVariables\n          );\n          writer.WritePropertyEnd();\n        }\n\n        writer.WriteObjectEnd();\n      }\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WriteIntProperty(\"threadIndex\", this.threadIndex);\n\n      if (!this.previousPointer.isNull) {\n        let resolvedPointer = this.previousPointer.Resolve();\n        if (resolvedPointer === null) {\n          return throwNullException(\"this.previousPointer.Resolve()\");\n        }\n        writer.WriteProperty(\n          \"previousContentObject\",\n          resolvedPointer.path.toString()\n        );\n      }\n\n      writer.WriteObjectEnd();\n    }\n  }\n}\n","import {\n  AbstractValue,\n  Value,\n  VariablePointerValue,\n  ListValue,\n  IntValue,\n  FloatValue,\n  BoolValue,\n} from \"./Value\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { InkObject } from \"./Object\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { asOrThrows, asOrNull, isEquatable } from \"./TypeAssertion\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { CallStack } from \"./CallStack\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { InkList } from \"./Story\";\nimport { Path } from \"./Path\";\n\n// Fake class wrapper around VariableState to have correct typing\n// when using the Proxy syntax in typescript\nfunction VariablesStateAccessor<T>(): new () => Pick<T, keyof T> {\n  return class {} as any;\n}\n\ntype VariableStateValue = boolean | string | number | InkList | Path | null;\n\nexport class VariablesState extends VariablesStateAccessor<\n  Record<string, any>\n>() {\n  // The way variableChangedEvent is a bit different than the reference implementation.\n  // Originally it uses the C# += operator to add delegates, but in js we need to maintain\n  // an actual collection of delegates (ie. callbacks) to register a new one, there is a\n  // special ObserveVariableChange method below.\n  public variableChangedEventCallbacks: Array<\n    (variableName: string, newValue: InkObject) => void\n  > = [];\n  public variableChangedEvent(variableName: string, newValue: InkObject): void {\n    for (let callback of this.variableChangedEventCallbacks) {\n      callback(variableName, newValue);\n    }\n  }\n\n  public patch: StatePatch | null = null;\n\n  get batchObservingVariableChanges() {\n    return this._batchObservingVariableChanges;\n  }\n  set batchObservingVariableChanges(value: boolean) {\n    this._batchObservingVariableChanges = value;\n    if (value) {\n      this._changedVariablesForBatchObs = new Set();\n    } else {\n      if (this._changedVariablesForBatchObs != null) {\n        for (let variableName of this._changedVariablesForBatchObs) {\n          let currentValue = this._globalVariables.get(variableName);\n          if (!currentValue) {\n            throwNullException(\"currentValue\");\n          } else {\n            this.variableChangedEvent(variableName, currentValue);\n          }\n        }\n\n        this._changedVariablesForBatchObs = null;\n      }\n    }\n  }\n\n  get callStack() {\n    return this._callStack;\n  }\n  set callStack(callStack) {\n    this._callStack = callStack;\n  }\n\n  private _batchObservingVariableChanges: boolean = false;\n\n  // the original code uses a magic getter and setter for global variables,\n  // allowing things like variableState['varname]. This is not quite possible\n  // in js without a Proxy, so it is replaced with this $ function.\n  public $(variableName: string): VariableStateValue;\n  public $(variableName: string, value: VariableStateValue): void;\n  public $(variableName: string, value?: any) {\n    if (typeof value === \"undefined\") {\n      let varContents = null;\n\n      if (this.patch !== null) {\n        varContents = this.patch.TryGetGlobal(variableName, null);\n        if (varContents.exists)\n          return (varContents.result as AbstractValue).valueObject;\n      }\n\n      varContents = this._globalVariables.get(variableName);\n\n      if (typeof varContents === \"undefined\") {\n        varContents = this._defaultGlobalVariables.get(variableName);\n      }\n\n      if (typeof varContents !== \"undefined\")\n        return (varContents as AbstractValue).valueObject;\n      else return null;\n    } else {\n      if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\")\n        throw new StoryException(\n          \"Cannot assign to a variable (\" +\n            variableName +\n            \") that hasn't been declared in the story\"\n        );\n\n      let val = Value.Create(value);\n      if (val == null) {\n        if (value == null) {\n          throw new Error(\"Cannot pass null to VariableState\");\n        } else {\n          throw new Error(\n            \"Invalid value passed to VariableState: \" + value.toString()\n          );\n        }\n      }\n\n      this.SetGlobal(variableName, val);\n    }\n  }\n\n  constructor(\n    callStack: CallStack,\n    listDefsOrigin: ListDefinitionsOrigin | null\n  ) {\n    super();\n    this._globalVariables = new Map();\n    this._callStack = callStack;\n    this._listDefsOrigin = listDefsOrigin;\n\n    // if es6 proxies are available, use them.\n    try {\n      // the proxy is used to allow direct manipulation of global variables.\n      // It first tries to access the objects own property, and if none is\n      // found it delegates the call to the $ method, defined below\n      let p = new Proxy(this, {\n        get(target: any, name) {\n          return name in target ? target[name] : target.$(name);\n        },\n        set(target: any, name, value) {\n          if (name in target) target[name] = value;\n          else target.$(name, value);\n          return true; // returning a falsy value make the trap fail\n        },\n      });\n\n      return p;\n    } catch (e) {\n      // the proxy object is not available in this context. we should warn the\n      // dev but writing to the console feels a bit intrusive.\n      // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n    }\n  }\n\n  public ApplyPatch() {\n    if (this.patch === null) {\n      return throwNullException(\"this.patch\");\n    }\n\n    for (let [namedVarKey, namedVarValue] of this.patch.globals) {\n      this._globalVariables.set(namedVarKey, namedVarValue);\n    }\n\n    if (this._changedVariablesForBatchObs !== null) {\n      for (let name of this.patch.changedVariables) {\n        this._changedVariablesForBatchObs.add(name);\n      }\n    }\n\n    this.patch = null;\n  }\n\n  public SetJsonToken(jToken: Record<string, any>) {\n    this._globalVariables.clear();\n\n    for (let [varValKey, varValValue] of this._defaultGlobalVariables) {\n      let loadedToken = jToken[varValKey];\n      if (typeof loadedToken !== \"undefined\") {\n        let tokenInkObject =\n          JsonSerialisation.JTokenToRuntimeObject(loadedToken);\n        if (tokenInkObject === null) {\n          return throwNullException(\"tokenInkObject\");\n        }\n        this._globalVariables.set(varValKey, tokenInkObject);\n      } else {\n        this._globalVariables.set(varValKey, varValValue);\n      }\n    }\n  }\n\n  public static dontSaveDefaultValues: boolean = true;\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n    for (let [keyValKey, keyValValue] of this._globalVariables) {\n      let name = keyValKey;\n      let val = keyValValue;\n\n      if (VariablesState.dontSaveDefaultValues) {\n        if (this._defaultGlobalVariables.has(name)) {\n          let defaultVal = this._defaultGlobalVariables.get(name)!;\n          if (this.RuntimeObjectsEqual(val, defaultVal)) continue;\n        }\n      }\n\n      writer.WritePropertyStart(name);\n      JsonSerialisation.WriteRuntimeObject(writer, val);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public RuntimeObjectsEqual(\n    obj1: InkObject | null,\n    obj2: InkObject | null\n  ): boolean {\n    if (obj1 === null) {\n      return throwNullException(\"obj1\");\n    }\n    if (obj2 === null) {\n      return throwNullException(\"obj2\");\n    }\n\n    if (obj1.constructor !== obj2.constructor) return false;\n\n    let boolVal = asOrNull(obj1, BoolValue);\n    if (boolVal !== null) {\n      return boolVal.value === asOrThrows(obj2, BoolValue).value;\n    }\n\n    let intVal = asOrNull(obj1, IntValue);\n    if (intVal !== null) {\n      return intVal.value === asOrThrows(obj2, IntValue).value;\n    }\n\n    let floatVal = asOrNull(obj1, FloatValue);\n    if (floatVal !== null) {\n      return floatVal.value === asOrThrows(obj2, FloatValue).value;\n    }\n\n    let val1 = asOrNull(obj1, Value);\n    let val2 = asOrNull(obj2, Value);\n    if (val1 !== null && val2 !== null) {\n      if (isEquatable(val1.valueObject) && isEquatable(val2.valueObject)) {\n        return val1.valueObject.Equals(val2.valueObject);\n      } else {\n        return val1.valueObject === val2.valueObject;\n      }\n    }\n\n    throw new Error(\n      \"FastRoughDefinitelyEquals: Unsupported runtime object type: \" +\n        obj1.constructor.name\n    );\n  }\n\n  public GetVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ): InkObject | null {\n    let varValue = this.GetRawVariableWithName(name, contextIndex);\n\n    // var varPointer = varValue as VariablePointerValue;\n    let varPointer = asOrNull(varValue, VariablePointerValue);\n    if (varPointer !== null) {\n      varValue = this.ValueAtVariablePointer(varPointer);\n    }\n\n    return varValue;\n  }\n\n  public TryGetDefaultVariableValue(name: string | null): InkObject | null {\n    let val = tryGetValueFromMap(this._defaultGlobalVariables, name, null);\n    return val.exists ? val.result : null;\n  }\n\n  public GlobalVariableExistsWithName(name: string) {\n    return (\n      this._globalVariables.has(name) ||\n      (this._defaultGlobalVariables !== null &&\n        this._defaultGlobalVariables.has(name))\n    );\n  }\n\n  public GetRawVariableWithName(name: string | null, contextIndex: number) {\n    let varValue: InkObject | null = null;\n\n    if (contextIndex == 0 || contextIndex == -1) {\n      let variableValue = null;\n      if (this.patch !== null) {\n        variableValue = this.patch.TryGetGlobal(name, null);\n        if (variableValue.exists) return variableValue.result!;\n      }\n\n      // this is a conditional assignment\n      variableValue = tryGetValueFromMap(this._globalVariables, name, null);\n      if (variableValue.exists) return variableValue.result;\n\n      if (this._defaultGlobalVariables !== null) {\n        variableValue = tryGetValueFromMap(\n          this._defaultGlobalVariables,\n          name,\n          null\n        );\n        if (variableValue.exists) return variableValue.result;\n      }\n\n      if (this._listDefsOrigin === null)\n        return throwNullException(\"VariablesState._listDefsOrigin\");\n      let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n      if (listItemValue) return listItemValue;\n    }\n\n    varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n\n    return varValue;\n  }\n\n  public ValueAtVariablePointer(pointer: VariablePointerValue) {\n    return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n  }\n\n  public Assign(varAss: VariableAssignment, value: InkObject) {\n    let name = varAss.variableName;\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let contextIndex = -1;\n\n    let setGlobal = false;\n    if (varAss.isNewDeclaration) {\n      setGlobal = varAss.isGlobal;\n    } else {\n      setGlobal = this.GlobalVariableExistsWithName(name);\n    }\n\n    if (varAss.isNewDeclaration) {\n      // var varPointer = value as VariablePointerValue;\n      let varPointer = asOrNull(value, VariablePointerValue);\n      if (varPointer !== null) {\n        let fullyResolvedVariablePointer =\n          this.ResolveVariablePointer(varPointer);\n        value = fullyResolvedVariablePointer;\n      }\n    } else {\n      let existingPointer = null;\n      do {\n        // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n        existingPointer = asOrNull(\n          this.GetRawVariableWithName(name, contextIndex),\n          VariablePointerValue\n        );\n        if (existingPointer != null) {\n          name = existingPointer.variableName;\n          contextIndex = existingPointer.contextIndex;\n          setGlobal = contextIndex == 0;\n        }\n      } while (existingPointer != null);\n    }\n\n    if (setGlobal) {\n      this.SetGlobal(name, value);\n    } else {\n      this._callStack.SetTemporaryVariable(\n        name,\n        value,\n        varAss.isNewDeclaration,\n        contextIndex\n      );\n    }\n  }\n\n  public SnapshotDefaultGlobals() {\n    this._defaultGlobalVariables = new Map(this._globalVariables);\n  }\n\n  public RetainListOriginsForAssignment(\n    oldValue: InkObject,\n    newValue: InkObject\n  ) {\n    let oldList = asOrThrows(oldValue, ListValue);\n    let newList = asOrThrows(newValue, ListValue);\n\n    if (oldList.value && newList.value && newList.value.Count == 0) {\n      newList.value.SetInitialOriginNames(oldList.value.originNames);\n    }\n  }\n\n  public SetGlobal(variableName: string | null, value: InkObject) {\n    let oldValue = null;\n\n    if (this.patch === null) {\n      oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);\n    }\n\n    if (this.patch !== null) {\n      oldValue = this.patch.TryGetGlobal(variableName, null);\n      if (!oldValue.exists) {\n        oldValue = tryGetValueFromMap(\n          this._globalVariables,\n          variableName,\n          null\n        );\n      }\n    }\n\n    ListValue.RetainListOriginsForAssignment(oldValue!.result!, value);\n\n    if (variableName === null) {\n      return throwNullException(\"variableName\");\n    }\n\n    if (this.patch !== null) {\n      this.patch.SetGlobal(variableName, value);\n    } else {\n      this._globalVariables.set(variableName, value);\n    }\n\n    // TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n    if (\n      this.variableChangedEvent !== null &&\n      oldValue !== null &&\n      value !== oldValue.result\n    ) {\n      if (this.batchObservingVariableChanges) {\n        if (this._changedVariablesForBatchObs === null) {\n          return throwNullException(\"this._changedVariablesForBatchObs\");\n        }\n\n        if (this.patch !== null) {\n          this.patch.AddChangedVariable(variableName);\n        } else if (this._changedVariablesForBatchObs !== null) {\n          this._changedVariablesForBatchObs.add(variableName);\n        }\n      } else {\n        this.variableChangedEvent(variableName, value);\n      }\n    }\n  }\n\n  public ResolveVariablePointer(varPointer: VariablePointerValue) {\n    let contextIndex = varPointer.contextIndex;\n\n    if (contextIndex == -1)\n      contextIndex = this.GetContextIndexOfVariableNamed(\n        varPointer.variableName\n      );\n\n    let valueOfVariablePointedTo = this.GetRawVariableWithName(\n      varPointer.variableName,\n      contextIndex\n    );\n\n    // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n    let doubleRedirectionPointer = asOrNull(\n      valueOfVariablePointedTo,\n      VariablePointerValue\n    );\n    if (doubleRedirectionPointer != null) {\n      return doubleRedirectionPointer;\n    } else {\n      return new VariablePointerValue(varPointer.variableName, contextIndex);\n    }\n  }\n\n  public GetContextIndexOfVariableNamed(varName: string) {\n    if (this.GlobalVariableExistsWithName(varName)) return 0;\n\n    return this._callStack.currentElementIndex;\n  }\n\n  /**\n   * This function is specific to the js version of ink. It allows to register a\n   * callback that will be called when a variable changes. The original code uses\n   * `state.variableChangedEvent += callback` instead.\n   *\n   * @param {function} callback\n   */\n  public ObserveVariableChange(\n    callback: (variableName: string, newValue: InkObject) => void\n  ) {\n    this.variableChangedEventCallbacks.push(callback);\n  }\n\n  private _globalVariables: Map<string, InkObject>;\n  private _defaultGlobalVariables: Map<string, InkObject> = new Map();\n\n  private _callStack: CallStack;\n  private _changedVariablesForBatchObs: Set<string> | null = new Set();\n  private _listDefsOrigin: ListDefinitionsOrigin | null;\n}\n","// Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n// Ink uses a seedable PRNG of which there is none in native javascript.\nexport class PRNG {\n  private seed: number;\n\n  constructor(seed: number) {\n    this.seed = seed % 2147483647;\n    if (this.seed <= 0) this.seed += 2147483646;\n  }\n  public next(): number {\n    return (this.seed = (this.seed * 48271) % 2147483647);\n  }\n  public nextFloat(): number {\n    return (this.next() - 1) / 2147483646;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class StatePatch {\n  get globals() {\n    return this._globals;\n  }\n  get changedVariables() {\n    return this._changedVariables;\n  }\n  get visitCounts() {\n    return this._visitCounts;\n  }\n  get turnIndices() {\n    return this._turnIndices;\n  }\n\n  constructor();\n  constructor(toCopy: StatePatch | null);\n  constructor() {\n    if (arguments.length === 1 && arguments[0] !== null) {\n      let toCopy = arguments[0] as StatePatch;\n      this._globals = new Map(toCopy._globals);\n      this._changedVariables = new Set(toCopy._changedVariables);\n      this._visitCounts = new Map(toCopy._visitCounts);\n      this._turnIndices = new Map(toCopy._turnIndices);\n    } else {\n      this._globals = new Map();\n      this._changedVariables = new Set();\n      this._visitCounts = new Map();\n      this._turnIndices = new Map();\n    }\n  }\n\n  public TryGetGlobal(name: string | null, /* out */ value: InkObject | null) {\n    if (name !== null && this._globals.has(name)) {\n      return { result: this._globals.get(name), exists: true };\n    }\n\n    return { result: value, exists: false };\n  }\n\n  public SetGlobal(name: string, value: InkObject) {\n    this._globals.set(name, value);\n  }\n\n  public AddChangedVariable(name: string) {\n    return this._changedVariables.add(name);\n  }\n\n  public TryGetVisitCount(container: Container, /* out */ count: number) {\n    if (this._visitCounts.has(container)) {\n      return { result: this._visitCounts.get(container), exists: true };\n    }\n\n    return { result: count, exists: false };\n  }\n\n  public SetVisitCount(container: Container, count: number) {\n    this._visitCounts.set(container, count);\n  }\n\n  public SetTurnIndex(container: Container, index: number) {\n    this._turnIndices.set(container, index);\n  }\n\n  public TryGetTurnIndex(container: Container, /* out */ index: number) {\n    if (this._turnIndices.has(container)) {\n      return { result: this._turnIndices.get(container), exists: true };\n    }\n\n    return { result: index, exists: false };\n  }\n\n  private _globals: Map<string, InkObject>;\n  private _changedVariables: Set<string> = new Set();\n  private _visitCounts: Map<Container, number> = new Map();\n  private _turnIndices: Map<Container, number> = new Map();\n}\n","export class SimpleJson {\n  public static TextToDictionary(text: string) {\n    return new SimpleJson.Reader(text).ToDictionary();\n  }\n\n  public static TextToArray(text: string) {\n    return new SimpleJson.Reader(text).ToArray();\n  }\n}\n\nexport namespace SimpleJson {\n  export class Reader {\n    constructor(text: string) {\n      this._rootObject = JSON.parse(text);\n    }\n\n    public ToDictionary() {\n      return this._rootObject as Record<string, any>;\n    }\n\n    public ToArray() {\n      return this._rootObject as any[];\n    }\n\n    private _rootObject: any[] | Record<string, any>;\n  }\n\n  // In C#, this class writes json tokens directly to a StringWriter or\n  // another stream. Here, a temporary hierarchy is created in the form\n  // of a javascript object, which is serialised in the `toString` method.\n  // See individual methods and properties for more information.\n  export class Writer {\n    public WriteObject(inner: (w: Writer) => void) {\n      this.WriteObjectStart();\n      inner(this);\n      this.WriteObjectEnd();\n    }\n\n    // Add a new object.\n    public WriteObjectStart() {\n      this.StartNewObject(true);\n\n      let newObject: Record<string, any> = {};\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This object is created as the value of a property,\n        // inside an other object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This object is created as the child of an array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This object is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object)\n      );\n    }\n\n    public WriteObjectEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Write a property name / value pair to the current object.\n    public WriteProperty(\n      name: any,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      innerOrContent: ((w: Writer) => void) | string | boolean | null\n    ) {\n      this.WritePropertyStart(name);\n      if (arguments[1] instanceof Function) {\n        let inner = arguments[1];\n        inner(this);\n      } else {\n        let content: string | boolean | null = arguments[1];\n        this.Write(content);\n      }\n      this.WritePropertyEnd();\n    }\n\n    // Int and Float are separate calls, since there both are\n    // numbers in JavaScript, but need to be handled differently.\n\n    public WriteIntProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteInt(content);\n      this.WritePropertyEnd();\n    }\n\n    public WriteFloatProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteFloat(content);\n      this.WritePropertyEnd();\n    }\n\n    // Prepare a new property name, which will be use to add the\n    // new object when calling _addToCurrentObject() from a Write\n    // method.\n    public WritePropertyStart(name: any) {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._propertyNameStack.push(name);\n\n      this.IncrementChildCount();\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n    }\n\n    public WritePropertyEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Property);\n      this.Assert(this.childCount === 1);\n      this._stateStack.pop();\n    }\n\n    // Prepare a new property name, except this time, the property name\n    // will be created by concatenating all the strings passed to\n    // WritePropertyNameInner.\n    public WritePropertyNameStart() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this.IncrementChildCount();\n\n      this._currentPropertyName = \"\";\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName)\n      );\n    }\n\n    public WritePropertyNameEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._propertyNameStack.push(this._currentPropertyName!);\n      this._currentPropertyName = null;\n      this._stateStack.pop();\n    }\n\n    public WritePropertyNameInner(str: string) {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._currentPropertyName += str;\n    }\n\n    // Add a new array.\n    public WriteArrayStart() {\n      this.StartNewObject(true);\n\n      let newObject: any[] = [];\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This array is created as the value of a property,\n        // inside an object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This array is created as the child of another array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This array is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array)\n      );\n    }\n\n    public WriteArrayEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Array);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Add the value to the appropriate collection (array / object), given the current\n    // context.\n    public Write(\n      value: number | string | boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      escape: boolean = true\n    ) {\n      if (value === null) {\n        console.error(\"Warning: trying to write a null value\");\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteBool(value: boolean | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteInt(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n\n      // Math.floor is used as a precaution:\n      //     1. to ensure that the value is written as an integer\n      //        (without a fractional part -> 1 instead of 1.0), even\n      //        though it should be the default behaviour of\n      //        JSON.serialize;\n      //     2. to ensure that if a floating number is passed\n      //        accidentally, it's converted to an integer.\n      //\n      // This guarantees savegame compatibility with the reference\n      // implementation.\n      this._addToCurrentObject(Math.floor(value));\n    }\n\n    // Since JSON doesn't support NaN and Infinity, these values\n    // are converted here.\n    public WriteFloat(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      if (value == Number.POSITIVE_INFINITY) {\n        this._addToCurrentObject(3.4e38);\n      } else if (value == Number.NEGATIVE_INFINITY) {\n        this._addToCurrentObject(-3.4e38);\n      } else if (isNaN(value)) {\n        this._addToCurrentObject(0.0);\n      } else {\n        this._addToCurrentObject(value);\n      }\n    }\n\n    public WriteNull() {\n      this.StartNewObject(false);\n      this._addToCurrentObject(null);\n    }\n\n    // Prepare a string before adding it to the current collection in\n    // WriteStringEnd(). The string will be a concatenation of all the\n    // strings passed to WriteStringInner.\n    public WriteStringStart() {\n      this.StartNewObject(false);\n      this._currentString = \"\";\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String)\n      );\n    }\n\n    public WriteStringEnd() {\n      this.Assert(this.state == SimpleJson.Writer.State.String);\n      this._stateStack.pop();\n      this._addToCurrentObject(this._currentString);\n      this._currentString = null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public WriteStringInner(str: string | null, escape: boolean = true) {\n      this.Assert(this.state === SimpleJson.Writer.State.String);\n\n      if (str === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this._currentString += str;\n    }\n\n    // Serialise the root object into a JSON string.\n    public toString() {\n      if (this._jsonObject === null) {\n        return \"\";\n      }\n\n      return JSON.stringify(this._jsonObject);\n    }\n\n    // Prepare the state stack when adding new objects / values.\n    private StartNewObject(container: boolean) {\n      if (container) {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.None ||\n            this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      } else {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      }\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(this.childCount === 0);\n      }\n\n      if (\n        this.state === SimpleJson.Writer.State.Array ||\n        this.state === SimpleJson.Writer.State.Property\n      ) {\n        this.IncrementChildCount();\n      }\n    }\n\n    // These getters peek all the different stacks.\n\n    private get state() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].type;\n      } else {\n        return SimpleJson.Writer.State.None;\n      }\n    }\n\n    private get childCount() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].childCount;\n      } else {\n        return 0;\n      }\n    }\n\n    private get currentCollection() {\n      if (this._collectionStack.length > 0) {\n        return this._collectionStack[this._collectionStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private get currentPropertyName() {\n      if (this._propertyNameStack.length > 0) {\n        return this._propertyNameStack[this._propertyNameStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private IncrementChildCount() {\n      this.Assert(this._stateStack.length > 0);\n      let currEl = this._stateStack.pop()!;\n      currEl.childCount++;\n      this._stateStack.push(currEl);\n    }\n\n    private Assert(condition: boolean) {\n      if (!condition) throw Error(\"Assert failed while writing JSON\");\n    }\n\n    // This method did not exist in the original C# code. It adds\n    // the given value to the current collection (used by Write methods).\n    private _addToCurrentObject(value: number | string | boolean | null) {\n      this.Assert(this.currentCollection !== null);\n      if (this.state === SimpleJson.Writer.State.Array) {\n        this.Assert(Array.isArray(this.currentCollection));\n        (this.currentCollection as any[]).push(value);\n      } else if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(!Array.isArray(this.currentCollection));\n        this.Assert(this.currentPropertyName !== null);\n        (this.currentCollection as Record<string, any>)[\n          this.currentPropertyName!\n        ] = value;\n        this._propertyNameStack.pop();\n      }\n    }\n\n    // In addition to `_stateStack` present in the original code,\n    // this implementation of SimpleJson use two other stacks and two\n    // temporary variables holding the current context.\n\n    // Used to keep track of the current property name being built\n    // with `WritePropertyNameStart`, `WritePropertyNameInner` and\n    // `WritePropertyNameEnd`.\n    private _currentPropertyName: string | null = null;\n\n    // Used to keep track of the current string value being built\n    // with `WriteStringStart`, `WriteStringInner` and\n    // `WriteStringEnd`.\n    private _currentString: string | null = null;\n\n    private _stateStack: SimpleJson.Writer.StateElement[] = [];\n\n    // Keep track of the current collection being built (either an array\n    // or an object). For instance, at the '?' step during the hiarchy\n    // creation, this hierarchy:\n    // [3, {a: [b, ?]}] will have this corresponding stack:\n    // (bottom) [Array, Object, Array] (top)\n    private _collectionStack: Array<any[] | Record<string, any>> = [];\n\n    // Keep track of the current property being assigned. For instance, at\n    // the '?' step during the hiarchy creation, this hierarchy:\n    // [3, {a: [b, {c: ?}]}] will have this corresponding stack:\n    // (bottom) [a, c] (top)\n    private _propertyNameStack: string[] = [];\n\n    // Object containing the entire hiearchy.\n    private _jsonObject: Record<string, any> | any[] | null = null;\n  }\n\n  export namespace Writer {\n    export enum State {\n      None,\n      Object,\n      Array,\n      Property,\n      PropertyName,\n      String,\n    }\n\n    export class StateElement {\n      public type: SimpleJson.Writer.State = SimpleJson.Writer.State.None;\n      public childCount: number = 0;\n\n      constructor(type: SimpleJson.Writer.State) {\n        this.type = type;\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { Choice } from \"./Choice\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { InkObject } from \"./Object\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Story } from \"./Story\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Flow {\n  public name: string;\n  public callStack: CallStack;\n  public outputStream: InkObject[];\n  public currentChoices: Choice[];\n\n  constructor(name: String, story: Story);\n  constructor(name: String, story: Story, jObject: Record<string, any>);\n  constructor() {\n    let name = arguments[0] as string;\n    let story = arguments[1] as Story;\n\n    this.name = name;\n    this.callStack = new CallStack(story);\n\n    if (arguments[2]) {\n      let jObject = arguments[2] as Record<string, any>;\n\n      this.callStack.SetJsonToken(jObject[\"callstack\"], story);\n      this.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"]\n      );\n      this.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"currentChoices\"]\n      ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      if (typeof jChoiceThreadsObj !== \"undefined\") {\n        this.LoadFlowChoiceThreads(jChoiceThreadsObj, story);\n      }\n    } else {\n      this.outputStream = [];\n      this.currentChoices = [];\n    }\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WriteProperty(\"callstack\", (w) => this.callStack.WriteJson(w));\n    writer.WriteProperty(\"outputStream\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.outputStream)\n    );\n\n    let hasChoiceThreads = false;\n    for (let c of this.currentChoices) {\n      if (c.threadAtGeneration === null)\n        return throwNullException(\"c.threadAtGeneration\");\n\n      c.originalThreadIndex = c.threadAtGeneration.threadIndex;\n\n      if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {\n        if (!hasChoiceThreads) {\n          hasChoiceThreads = true;\n          writer.WritePropertyStart(\"choiceThreads\");\n          writer.WriteObjectStart();\n        }\n\n        writer.WritePropertyStart(c.originalThreadIndex);\n        c.threadAtGeneration.WriteJson(writer);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasChoiceThreads) {\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteProperty(\"currentChoices\", (w) => {\n      w.WriteArrayStart();\n      for (let c of this.currentChoices) {\n        JsonSerialisation.WriteChoice(w, c);\n      }\n      w.WriteArrayEnd();\n    });\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadFlowChoiceThreads(\n    jChoiceThreads: Record<string, any>,\n    story: Story\n  ) {\n    for (let choice of this.currentChoices) {\n      let foundActiveThread = this.callStack.ThreadWithIndex(\n        choice.originalThreadIndex\n      );\n      if (foundActiveThread !== null) {\n        choice.threadAtGeneration = foundActiveThread.Copy();\n      } else {\n        let jSavedChoiceThread =\n          jChoiceThreads[`${choice.originalThreadIndex}`];\n        choice.threadAtGeneration = new CallStack.Thread(\n          jSavedChoiceThread,\n          story\n        );\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { VariablesState } from \"./VariablesState\";\nimport { ValueType, Value, StringValue, ListValue } from \"./Value\";\nimport { PushPopType } from \"./PushPop\";\nimport { Tag } from \"./Tag\";\nimport { Glue } from \"./Glue\";\nimport { Path } from \"./Path\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { PRNG } from \"./PRNG\";\nimport { Void } from \"./Void\";\nimport { Pointer } from \"./Pointer\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { Choice } from \"./Choice\";\nimport { asOrNull, asOrThrows, nullIfUndefined } from \"./TypeAssertion\";\nimport { Debug } from \"./Debug\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { throwNullException } from \"./NullException\";\nimport { Story } from \"./Story\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Flow } from \"./Flow\";\nimport { InkList } from \"./InkList\";\n\nexport class StoryState {\n  // Backward compatible changes since v8:\n  // v10: dynamic tags\n  // v9:  multi-flows\n  public readonly kInkSaveStateVersion = 10;\n  public readonly kMinCompatibleLoadVersion = 8;\n\n  public onDidLoadState: (() => void) | null = null;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public ToJson(indented: boolean = false) {\n    let writer = new SimpleJson.Writer();\n    this.WriteJson(writer);\n    return writer.toString();\n  }\n  public toJson(indented: boolean = false) {\n    return this.ToJson(indented);\n  }\n\n  public LoadJson(json: string) {\n    let jObject = SimpleJson.TextToDictionary(json);\n    this.LoadJsonObj(jObject);\n    if (this.onDidLoadState !== null) this.onDidLoadState();\n  }\n\n  public VisitCountAtPathString(pathString: string) {\n    let visitCountOut;\n\n    if (this._patch !== null) {\n      let container = this.story.ContentAtPath(new Path(pathString)).container;\n      if (container === null)\n        throw new Error(\"Content at path not found: \" + pathString);\n\n      visitCountOut = this._patch.TryGetVisitCount(container, 0);\n      if (visitCountOut.exists) return visitCountOut.result;\n    }\n\n    visitCountOut = tryGetValueFromMap(this._visitCounts, pathString, null);\n    if (visitCountOut.exists) return visitCountOut.result;\n\n    return 0;\n  }\n\n  public VisitCountForContainer(container: Container | null): number {\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    if (!container.visitsShouldBeCounted) {\n      this.story.Error(\n        \"Read count for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n      return 0;\n    }\n\n    if (this._patch !== null) {\n      let count = this._patch.TryGetVisitCount(container, 0);\n      if (count.exists) {\n        return count.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let count2 = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count2.exists) {\n      return count2.result!;\n    }\n\n    return 0;\n  }\n\n  public IncrementVisitCountForContainer(container: Container) {\n    if (this._patch !== null) {\n      let currCount = this.VisitCountForContainer(container);\n      currCount++;\n      this._patch.SetVisitCount(container, currCount);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    let count = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count.exists) {\n      this._visitCounts.set(containerPathStr, count.result! + 1);\n    } else {\n      this._visitCounts.set(containerPathStr, 1);\n    }\n  }\n\n  public RecordTurnIndexVisitToContainer(container: Container) {\n    if (this._patch !== null) {\n      this._patch.SetTurnIndex(container, this.currentTurnIndex);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    this._turnIndices.set(containerPathStr, this.currentTurnIndex);\n  }\n\n  public TurnsSinceForContainer(container: Container) {\n    if (!container.turnIndexShouldBeCounted) {\n      this.story.Error(\n        \"TURNS_SINCE() for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n    }\n\n    if (this._patch !== null) {\n      let index = this._patch.TryGetTurnIndex(container, 0);\n      if (index.exists) {\n        return this.currentTurnIndex - index.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let index2 = tryGetValueFromMap(this._turnIndices, containerPathStr, 0);\n    if (index2.exists) {\n      return this.currentTurnIndex - index2.result!;\n    } else {\n      return -1;\n    }\n  }\n\n  get callstackDepth() {\n    return this.callStack.depth;\n  }\n\n  get outputStream() {\n    return this._currentFlow.outputStream;\n  }\n\n  get currentChoices() {\n    // If we can continue generating text content rather than choices,\n    // then we reflect the choice list as being empty, since choices\n    // should always come at the end.\n    if (this.canContinue) return [];\n    return this._currentFlow.currentChoices;\n  }\n\n  get generatedChoices() {\n    return this._currentFlow.currentChoices;\n  }\n\n  get currentErrors() {\n    return this._currentErrors;\n  }\n  private _currentErrors: string[] | null = null;\n\n  get currentWarnings() {\n    return this._currentWarnings;\n  }\n  private _currentWarnings: string[] | null = null;\n\n  get variablesState() {\n    return this._variablesState;\n  }\n  set variablesState(value) {\n    this._variablesState = value;\n  }\n  private _variablesState: VariablesState;\n\n  get callStack() {\n    return this._currentFlow.callStack;\n  }\n\n  get evaluationStack() {\n    return this._evaluationStack;\n  }\n  private _evaluationStack: InkObject[];\n\n  public divertedPointer: Pointer = Pointer.Null;\n\n  get currentTurnIndex() {\n    return this._currentTurnIndex;\n  }\n  set currentTurnIndex(value) {\n    this._currentTurnIndex = value;\n  }\n  private _currentTurnIndex: number = 0;\n\n  public storySeed: number = 0;\n  public previousRandom: number = 0;\n  public didSafeExit: boolean = false;\n\n  public story: Story;\n\n  get currentPathString() {\n    let pointer = this.currentPointer;\n    if (pointer.isNull) {\n      return null;\n    } else {\n      if (pointer.path === null) {\n        return throwNullException(\"pointer.path\");\n      }\n      return pointer.path.toString();\n    }\n  }\n\n  get currentPointer() {\n    return this.callStack.currentElement.currentPointer.copy();\n  }\n\n  set currentPointer(value) {\n    this.callStack.currentElement.currentPointer = value.copy();\n  }\n\n  get previousPointer() {\n    return this.callStack.currentThread.previousPointer.copy();\n  }\n\n  set previousPointer(value) {\n    this.callStack.currentThread.previousPointer = value.copy();\n  }\n\n  get canContinue() {\n    return !this.currentPointer.isNull && !this.hasError;\n  }\n\n  get hasError() {\n    return this.currentErrors != null && this.currentErrors.length > 0;\n  }\n\n  get hasWarning() {\n    return this.currentWarnings != null && this.currentWarnings.length > 0;\n  }\n\n  get currentText() {\n    if (this._outputStreamTextDirty) {\n      let sb = new StringBuilder();\n\n      let inTag: boolean = false;\n\n      for (let outputObj of this.outputStream) {\n        // var textContent = outputObj as StringValue;\n        let textContent = asOrNull(outputObj, StringValue);\n        if (!inTag && textContent !== null) {\n          sb.Append(textContent.value);\n        } else {\n          let controlCommand = asOrNull(outputObj, ControlCommand);\n          if (controlCommand !== null) {\n            if (\n              controlCommand.commandType == ControlCommand.CommandType.BeginTag\n            ) {\n              inTag = true;\n            } else if (\n              controlCommand.commandType == ControlCommand.CommandType.EndTag\n            ) {\n              inTag = false;\n            }\n          }\n        }\n      }\n\n      this._currentText = this.CleanOutputWhitespace(sb.toString());\n      this._outputStreamTextDirty = false;\n    }\n\n    return this._currentText;\n  }\n  private _currentText: string | null = null;\n\n  public CleanOutputWhitespace(str: string) {\n    let sb = new StringBuilder();\n\n    let currentWhitespaceStart = -1;\n    let startOfLine = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      let c = str.charAt(i);\n\n      let isInlineWhitespace = c == \" \" || c == \"\\t\";\n\n      if (isInlineWhitespace && currentWhitespaceStart == -1)\n        currentWhitespaceStart = i;\n\n      if (!isInlineWhitespace) {\n        if (\n          c != \"\\n\" &&\n          currentWhitespaceStart > 0 &&\n          currentWhitespaceStart != startOfLine\n        ) {\n          sb.Append(\" \");\n        }\n        currentWhitespaceStart = -1;\n      }\n\n      if (c == \"\\n\") startOfLine = i + 1;\n\n      if (!isInlineWhitespace) sb.Append(c);\n    }\n\n    return sb.toString();\n  }\n\n  get currentTags() {\n    if (this._outputStreamTagsDirty) {\n      this._currentTags = [];\n      let inTag: boolean = false;\n      let sb = new StringBuilder();\n\n      for (let outputObj of this.outputStream) {\n        let controlCommand = asOrNull(outputObj, ControlCommand);\n        if (controlCommand != null) {\n          if (\n            controlCommand.commandType == ControlCommand.CommandType.BeginTag\n          ) {\n            if (inTag && sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = true;\n          } else if (\n            controlCommand.commandType == ControlCommand.CommandType.EndTag\n          ) {\n            if (sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = false;\n          }\n        } else if (inTag) {\n          let strVal = asOrNull(outputObj, StringValue);\n          if (strVal !== null) {\n            sb.Append(strVal.value);\n          }\n        } else {\n          let tag = asOrNull(outputObj, Tag);\n          if (tag != null && tag.text != null && tag.text.length > 0) {\n            this._currentTags.push(tag.text); // tag.text has whitespae already cleaned\n          }\n        }\n      }\n\n      if (sb.Length > 0) {\n        let txt = this.CleanOutputWhitespace(sb.toString());\n        this._currentTags.push(txt);\n        sb.Clear();\n      }\n\n      this._outputStreamTagsDirty = false;\n    }\n\n    return this._currentTags;\n  }\n  private _currentTags: string[] | null = null;\n\n  get currentFlowName() {\n    return this._currentFlow.name;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this._currentFlow.name == this.kDefaultFlowName;\n  }\n\n  get aliveFlowNames() {\n    if (this._aliveFlowNamesDirty) {\n      this._aliveFlowNames = [];\n\n      if (this._namedFlows != null) {\n        for (let flowName of this._namedFlows.keys()) {\n          if (flowName != this.kDefaultFlowName) {\n            this._aliveFlowNames.push(flowName);\n          }\n        }\n      }\n\n      this._aliveFlowNamesDirty = false;\n    }\n\n    return this._aliveFlowNames;\n  }\n\n  get inExpressionEvaluation() {\n    return this.callStack.currentElement.inExpressionEvaluation;\n  }\n  set inExpressionEvaluation(value) {\n    this.callStack.currentElement.inExpressionEvaluation = value;\n  }\n\n  constructor(story: Story) {\n    this.story = story;\n\n    this._currentFlow = new Flow(this.kDefaultFlowName, story);\n    this.OutputStreamDirty();\n\n    this._aliveFlowNamesDirty = true;\n    this._evaluationStack = [];\n\n    this._variablesState = new VariablesState(\n      this.callStack,\n      story.listDefinitions\n    );\n\n    this._visitCounts = new Map();\n    this._turnIndices = new Map();\n    this.currentTurnIndex = -1;\n\n    let timeSeed = new Date().getTime();\n    this.storySeed = new PRNG(timeSeed).next() % 100;\n    this.previousRandom = 0;\n\n    this.GoToStart();\n  }\n\n  public GoToStart() {\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      this.story.mainContentContainer\n    );\n  }\n\n  public SwitchFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.SwitchFlow\");\n\n    if (this._namedFlows === null) {\n      this._namedFlows = new Map();\n      this._namedFlows.set(this.kDefaultFlowName, this._currentFlow);\n    }\n\n    if (flowName === this._currentFlow.name) {\n      return;\n    }\n\n    let flow: Flow;\n    let content = tryGetValueFromMap(this._namedFlows, flowName, null);\n    if (content.exists) {\n      flow = content.result!;\n    } else {\n      flow = new Flow(flowName, this.story);\n      this._namedFlows.set(flowName, flow);\n      this._aliveFlowNamesDirty = true;\n    }\n\n    this._currentFlow = flow;\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this.OutputStreamDirty();\n  }\n\n  public SwitchToDefaultFlow_Internal() {\n    if (this._namedFlows === null) return;\n    this.SwitchFlow_Internal(this.kDefaultFlowName);\n  }\n\n  public RemoveFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.DestroyFlow\");\n    if (flowName === this.kDefaultFlowName)\n      throw new Error(\"Cannot destroy default flow\");\n\n    if (this._currentFlow.name === flowName) {\n      this.SwitchToDefaultFlow_Internal();\n    }\n\n    if (this._namedFlows === null)\n      return throwNullException(\"this._namedFlows\");\n    this._namedFlows.delete(flowName);\n    this._aliveFlowNamesDirty = true;\n  }\n\n  public CopyAndStartPatching() {\n    let copy = new StoryState(this.story);\n\n    copy._patch = new StatePatch(this._patch);\n\n    copy._currentFlow.name = this._currentFlow.name;\n    copy._currentFlow.callStack = new CallStack(this._currentFlow.callStack);\n    copy._currentFlow.currentChoices.push(...this._currentFlow.currentChoices);\n    copy._currentFlow.outputStream.push(...this._currentFlow.outputStream);\n    copy.OutputStreamDirty();\n\n    if (this._namedFlows !== null) {\n      copy._namedFlows = new Map();\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        copy._namedFlows.set(namedFlowKey, namedFlowValue);\n        copy._aliveFlowNamesDirty = true;\n      }\n      copy._namedFlows.set(this._currentFlow.name, copy._currentFlow);\n    }\n\n    if (this.hasError) {\n      copy._currentErrors = [];\n      copy._currentErrors.push(...(this.currentErrors || []));\n    }\n\n    if (this.hasWarning) {\n      copy._currentWarnings = [];\n      copy._currentWarnings.push(...(this.currentWarnings || []));\n    }\n\n    copy.variablesState = this.variablesState;\n    copy.variablesState.callStack = copy.callStack;\n    copy.variablesState.patch = copy._patch;\n\n    copy.evaluationStack.push(...this.evaluationStack);\n\n    if (!this.divertedPointer.isNull)\n      copy.divertedPointer = this.divertedPointer.copy();\n\n    copy.previousPointer = this.previousPointer.copy();\n\n    copy._visitCounts = this._visitCounts;\n    copy._turnIndices = this._turnIndices;\n\n    copy.currentTurnIndex = this.currentTurnIndex;\n    copy.storySeed = this.storySeed;\n    copy.previousRandom = this.previousRandom;\n\n    copy.didSafeExit = this.didSafeExit;\n\n    return copy;\n  }\n\n  public RestoreAfterPatch() {\n    this.variablesState.callStack = this.callStack;\n    this.variablesState.patch = this._patch;\n  }\n\n  public ApplyAnyPatch() {\n    if (this._patch === null) return;\n\n    this.variablesState.ApplyPatch();\n\n    for (let [key, value] of this._patch.visitCounts)\n      this.ApplyCountChanges(key, value, true);\n\n    for (let [key, value] of this._patch.turnIndices)\n      this.ApplyCountChanges(key, value, false);\n\n    this._patch = null;\n  }\n\n  public ApplyCountChanges(\n    container: Container,\n    newCount: number,\n    isVisit: boolean\n  ) {\n    let counts = isVisit ? this._visitCounts : this._turnIndices;\n    counts.set(container.path.toString(), newCount);\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WritePropertyStart(\"flows\");\n    writer.WriteObjectStart();\n\n    // NOTE: Never pass `WriteJson` directly as an argument to `WriteProperty`.\n    // Call it inside a function to make sure `this` is correctly bound\n    // and passed down the call hierarchy.\n\n    if (this._namedFlows !== null) {\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        writer.WriteProperty(namedFlowKey, (w) => namedFlowValue.WriteJson(w));\n      }\n    } else {\n      writer.WriteProperty(this._currentFlow.name, (w) =>\n        this._currentFlow.WriteJson(w)\n      );\n    }\n\n    writer.WriteObjectEnd();\n    writer.WritePropertyEnd();\n\n    writer.WriteProperty(\"currentFlowName\", this._currentFlow.name);\n\n    writer.WriteProperty(\"variablesState\", (w) =>\n      this.variablesState.WriteJson(w)\n    );\n\n    writer.WriteProperty(\"evalStack\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack)\n    );\n\n    if (!this.divertedPointer.isNull) {\n      if (this.divertedPointer.path === null) {\n        return throwNullException(\"divertedPointer\");\n      }\n      writer.WriteProperty(\n        \"currentDivertTarget\",\n        this.divertedPointer.path.componentsString\n      );\n    }\n\n    writer.WriteProperty(\"visitCounts\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._visitCounts)\n    );\n    writer.WriteProperty(\"turnIndices\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._turnIndices)\n    );\n\n    writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);\n    writer.WriteIntProperty(\"storySeed\", this.storySeed);\n    writer.WriteIntProperty(\"previousRandom\", this.previousRandom);\n\n    writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);\n\n    writer.WriteIntProperty(\"inkFormatVersion\", Story.inkVersionCurrent);\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadJsonObj(value: Record<string, any>) {\n    let jObject = value;\n\n    let jSaveVersion = jObject[\"inkSaveVersion\"];\n    if (jSaveVersion == null) {\n      throw new Error(\"ink save format incorrect, can't load.\");\n    } else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n      throw new Error(\n        \"Ink save format isn't compatible with the current version (saw '\" +\n          jSaveVersion +\n          \"', but minimum is \" +\n          this.kMinCompatibleLoadVersion +\n          \"), so can't load.\"\n      );\n    }\n\n    let flowsObj = jObject[\"flows\"];\n    if (flowsObj != null) {\n      let flowsObjDict = flowsObj as Record<string, any>;\n\n      // Single default flow\n      if (Object.keys(flowsObjDict).length === 1) {\n        this._namedFlows = null;\n      } else if (this._namedFlows === null) {\n        this._namedFlows = new Map();\n      } else {\n        this._namedFlows.clear();\n      }\n\n      let flowsObjDictEntries = Object.entries(flowsObjDict);\n      for (let [namedFlowObjKey, namedFlowObjValue] of flowsObjDictEntries) {\n        let name = namedFlowObjKey;\n        let flowObj = namedFlowObjValue as Record<string, any>;\n\n        let flow = new Flow(name, this.story, flowObj);\n\n        if (Object.keys(flowsObjDict).length === 1) {\n          this._currentFlow = new Flow(name, this.story, flowObj);\n        } else {\n          if (this._namedFlows === null)\n            return throwNullException(\"this._namedFlows\");\n          this._namedFlows.set(name, flow);\n        }\n      }\n\n      if (this._namedFlows != null && this._namedFlows.size > 1) {\n        let currFlowName = jObject[\"currentFlowName\"] as string;\n        // Adding a bang at the end, because we're trusting the save, as\n        // done in upstream.  If the save is corrupted, the execution\n        // is undefined.\n        this._currentFlow = this._namedFlows.get(currFlowName)!;\n      }\n    } else {\n      this._namedFlows = null;\n      this._currentFlow.name = this.kDefaultFlowName;\n      this._currentFlow.callStack.SetJsonToken(\n        jObject[\"callstackThreads\"] as Record<string, any>,\n        this.story\n      );\n      this._currentFlow.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"] as any[]\n      );\n      this._currentFlow.currentChoices =\n        JsonSerialisation.JArrayToRuntimeObjList(\n          jObject[\"currentChoices\"] as any[]\n        ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      this._currentFlow.LoadFlowChoiceThreads(jChoiceThreadsObj, this.story);\n    }\n\n    this.OutputStreamDirty();\n    this._aliveFlowNamesDirty = true;\n\n    this.variablesState.SetJsonToken(jObject[\"variablesState\"]);\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this._evaluationStack = JsonSerialisation.JArrayToRuntimeObjList(\n      jObject[\"evalStack\"]\n    );\n\n    let currentDivertTargetPath = jObject[\"currentDivertTarget\"];\n    if (currentDivertTargetPath != null) {\n      let divertPath = new Path(currentDivertTargetPath.toString());\n      this.divertedPointer = this.story.PointerAtPath(divertPath);\n    }\n\n    this._visitCounts = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"visitCounts\"]\n    );\n    this._turnIndices = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"turnIndices\"]\n    );\n    this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);\n    this.storySeed = parseInt(jObject[\"storySeed\"]);\n    this.previousRandom = parseInt(jObject[\"previousRandom\"]);\n  }\n\n  public ResetErrors() {\n    this._currentErrors = null;\n    this._currentWarnings = null;\n  }\n  public ResetOutput(objs: InkObject[] | null = null) {\n    this.outputStream.length = 0;\n    if (objs !== null) this.outputStream.push(...objs);\n    this.OutputStreamDirty();\n  }\n\n  public PushToOutputStream(obj: InkObject | null) {\n    // var text = obj as StringValue;\n    let text = asOrNull(obj, StringValue);\n    if (text !== null) {\n      let listText = this.TrySplittingHeadTailWhitespace(text);\n      if (listText !== null) {\n        for (let textObj of listText) {\n          this.PushToOutputStreamIndividual(textObj);\n        }\n        this.OutputStreamDirty();\n        return;\n      }\n    }\n\n    this.PushToOutputStreamIndividual(obj);\n    this.OutputStreamDirty();\n  }\n\n  public PopFromOutputStream(count: number) {\n    this.outputStream.splice(this.outputStream.length - count, count);\n    this.OutputStreamDirty();\n  }\n\n  public TrySplittingHeadTailWhitespace(single: StringValue) {\n    let str = single.value;\n    if (str === null) {\n      return throwNullException(\"single.value\");\n    }\n\n    let headFirstNewlineIdx = -1;\n    let headLastNewlineIdx = -1;\n    for (let i = 0; i < str.length; i++) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (headFirstNewlineIdx == -1) headFirstNewlineIdx = i;\n        headLastNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    let tailLastNewlineIdx = -1;\n    let tailFirstNewlineIdx = -1;\n    for (let i = str.length - 1; i >= 0; i--) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (tailLastNewlineIdx == -1) tailLastNewlineIdx = i;\n        tailFirstNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    // No splitting to be done?\n    if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1) return null;\n\n    let listTexts: StringValue[] = [];\n    let innerStrStart = 0;\n    let innerStrEnd = str.length;\n\n    if (headFirstNewlineIdx != -1) {\n      if (headFirstNewlineIdx > 0) {\n        let leadingSpaces = new StringValue(\n          str.substring(0, headFirstNewlineIdx)\n        );\n        listTexts.push(leadingSpaces);\n      }\n      listTexts.push(new StringValue(\"\\n\"));\n      innerStrStart = headLastNewlineIdx + 1;\n    }\n\n    if (tailLastNewlineIdx != -1) {\n      innerStrEnd = tailFirstNewlineIdx;\n    }\n\n    if (innerStrEnd > innerStrStart) {\n      let innerStrText = str.substring(innerStrStart, innerStrEnd);\n      listTexts.push(new StringValue(innerStrText));\n    }\n\n    if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n      listTexts.push(new StringValue(\"\\n\"));\n      if (tailLastNewlineIdx < str.length - 1) {\n        let numSpaces = str.length - tailLastNewlineIdx - 1;\n        let trailingSpaces = new StringValue(\n          str.substring(\n            tailLastNewlineIdx + 1,\n            tailLastNewlineIdx + 1 + numSpaces\n          )\n        );\n        listTexts.push(trailingSpaces);\n      }\n    }\n\n    return listTexts;\n  }\n\n  public PushToOutputStreamIndividual(obj: InkObject | null) {\n    let glue = asOrNull(obj, Glue);\n    let text = asOrNull(obj, StringValue);\n\n    let includeInOutput = true;\n\n    if (glue) {\n      this.TrimNewlinesFromOutputStream();\n      includeInOutput = true;\n    } else if (text) {\n      let functionTrimIndex = -1;\n      let currEl = this.callStack.currentElement;\n      if (currEl.type == PushPopType.Function) {\n        functionTrimIndex = currEl.functionStartInOutputStream;\n      }\n\n      let glueTrimIndex = -1;\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let o = this.outputStream[i];\n        let c = o instanceof ControlCommand ? o : null;\n        let g = o instanceof Glue ? o : null;\n\n        if (g != null) {\n          glueTrimIndex = i;\n          break;\n        } else if (\n          c != null &&\n          c.commandType == ControlCommand.CommandType.BeginString\n        ) {\n          if (i >= functionTrimIndex) {\n            functionTrimIndex = -1;\n          }\n          break;\n        }\n      }\n\n      let trimIndex = -1;\n      if (glueTrimIndex != -1 && functionTrimIndex != -1)\n        trimIndex = Math.min(functionTrimIndex, glueTrimIndex);\n      else if (glueTrimIndex != -1) trimIndex = glueTrimIndex;\n      else trimIndex = functionTrimIndex;\n\n      if (trimIndex != -1) {\n        if (text.isNewline) {\n          includeInOutput = false;\n        } else if (text.isNonWhitespace) {\n          if (glueTrimIndex > -1) this.RemoveExistingGlue();\n\n          if (functionTrimIndex > -1) {\n            let callStackElements = this.callStack.elements;\n            for (let i = callStackElements.length - 1; i >= 0; i--) {\n              let el = callStackElements[i];\n              if (el.type == PushPopType.Function) {\n                el.functionStartInOutputStream = -1;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else if (text.isNewline) {\n        if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)\n          includeInOutput = false;\n      }\n    }\n\n    if (includeInOutput) {\n      if (obj === null) {\n        return throwNullException(\"obj\");\n      }\n      this.outputStream.push(obj);\n      this.OutputStreamDirty();\n    }\n  }\n\n  public TrimNewlinesFromOutputStream() {\n    let removeWhitespaceFrom = -1;\n\n    let i = this.outputStream.length - 1;\n    while (i >= 0) {\n      let obj = this.outputStream[i];\n      let cmd = asOrNull(obj, ControlCommand);\n      let txt = asOrNull(obj, StringValue);\n\n      if (cmd != null || (txt != null && txt.isNonWhitespace)) {\n        break;\n      } else if (txt != null && txt.isNewline) {\n        removeWhitespaceFrom = i;\n      }\n      i--;\n    }\n\n    // Remove the whitespace\n    if (removeWhitespaceFrom >= 0) {\n      i = removeWhitespaceFrom;\n      while (i < this.outputStream.length) {\n        let text = asOrNull(this.outputStream[i], StringValue);\n        if (text) {\n          this.outputStream.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  public RemoveExistingGlue() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let c = this.outputStream[i];\n      if (c instanceof Glue) {\n        this.outputStream.splice(i, 1);\n      } else if (c instanceof ControlCommand) {\n        break;\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  get outputStreamEndsInNewline() {\n    if (this.outputStream.length > 0) {\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let obj = this.outputStream[i];\n        if (obj instanceof ControlCommand) break;\n        let text = this.outputStream[i];\n        if (text instanceof StringValue) {\n          if (text.isNewline) return true;\n          else if (text.isNonWhitespace) break;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  get outputStreamContainsContent() {\n    for (let content of this.outputStream) {\n      if (content instanceof StringValue) return true;\n    }\n    return false;\n  }\n\n  get inStringEvaluation() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let cmd = asOrNull(this.outputStream[i], ControlCommand);\n      if (\n        cmd instanceof ControlCommand &&\n        cmd.commandType == ControlCommand.CommandType.BeginString\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public PushEvaluationStack(obj: InkObject | null) {\n    // var listValue = obj as ListValue;\n    let listValue = asOrNull(obj, ListValue);\n    if (listValue) {\n      // Update origin when list is has something to indicate the list origin\n      let rawList = listValue.value;\n      if (rawList === null) {\n        return throwNullException(\"rawList\");\n      }\n\n      if (rawList.originNames != null) {\n        if (!rawList.origins) rawList.origins = [];\n        rawList.origins.length = 0;\n\n        for (let n of rawList.originNames) {\n          if (this.story.listDefinitions === null)\n            return throwNullException(\"StoryState.story.listDefinitions\");\n          let def = this.story.listDefinitions.TryListGetDefinition(n, null);\n          if (def.result === null)\n            return throwNullException(\"StoryState def.result\");\n          if (rawList.origins.indexOf(def.result) < 0)\n            rawList.origins.push(def.result);\n        }\n      }\n    }\n\n    if (obj === null) {\n      return throwNullException(\"obj\");\n    }\n    this.evaluationStack.push(obj);\n  }\n\n  public PopEvaluationStack(): InkObject;\n  public PopEvaluationStack(numberOfObjects: number): InkObject[];\n  public PopEvaluationStack(numberOfObjects?: number) {\n    if (typeof numberOfObjects === \"undefined\") {\n      let obj = this.evaluationStack.pop();\n      return nullIfUndefined(obj);\n    } else {\n      if (numberOfObjects > this.evaluationStack.length) {\n        throw new Error(\"trying to pop too many objects\");\n      }\n\n      let popped = this.evaluationStack.splice(\n        this.evaluationStack.length - numberOfObjects,\n        numberOfObjects\n      );\n      return nullIfUndefined(popped);\n    }\n  }\n\n  public PeekEvaluationStack() {\n    return this.evaluationStack[this.evaluationStack.length - 1];\n  }\n\n  public ForceEnd() {\n    this.callStack.Reset();\n\n    this._currentFlow.currentChoices.length = 0;\n\n    this.currentPointer = Pointer.Null;\n    this.previousPointer = Pointer.Null;\n\n    this.didSafeExit = true;\n  }\n\n  public TrimWhitespaceFromFunctionEnd() {\n    Debug.Assert(this.callStack.currentElement.type == PushPopType.Function);\n    let functionStartPoint =\n      this.callStack.currentElement.functionStartInOutputStream;\n\n    if (functionStartPoint == -1) {\n      functionStartPoint = 0;\n    }\n\n    for (let i = this.outputStream.length - 1; i >= functionStartPoint; i--) {\n      let obj = this.outputStream[i];\n      let txt = asOrNull(obj, StringValue);\n      let cmd = asOrNull(obj, ControlCommand);\n\n      if (txt == null) continue;\n      if (cmd) break;\n\n      if (txt.isNewline || txt.isInlineWhitespace) {\n        this.outputStream.splice(i, 1);\n        this.OutputStreamDirty();\n      } else {\n        break;\n      }\n    }\n  }\n\n  public PopCallStack(popType: PushPopType | null = null) {\n    if (this.callStack.currentElement.type == PushPopType.Function)\n      this.TrimWhitespaceFromFunctionEnd();\n\n    this.callStack.Pop(popType);\n  }\n\n  public SetChosenPath(path: Path, incrementingTurnIndex: boolean) {\n    // Changing direction, assume we need to clear current set of choices\n    this._currentFlow.currentChoices.length = 0;\n\n    let newPointer = this.story.PointerAtPath(path);\n    if (!newPointer.isNull && newPointer.index == -1) newPointer.index = 0;\n\n    this.currentPointer = newPointer;\n\n    if (incrementingTurnIndex) {\n      this.currentTurnIndex++;\n    }\n  }\n\n  public StartFunctionEvaluationFromGame(\n    funcContainer: Container,\n    args: any[]\n  ) {\n    this.callStack.Push(\n      PushPopType.FunctionEvaluationFromGame,\n      this.evaluationStack.length\n    );\n    this.callStack.currentElement.currentPointer =\n      Pointer.StartOf(funcContainer);\n\n    this.PassArgumentsToEvaluationStack(args);\n  }\n\n  public PassArgumentsToEvaluationStack(args: any[] | null) {\n    if (args !== null) {\n      for (let i = 0; i < args.length; i++) {\n        if (\n          !(\n            typeof args[i] === \"number\" ||\n            typeof args[i] === \"string\" ||\n            typeof args[i] === \"boolean\" ||\n            args[i] instanceof InkList\n          )\n        ) {\n          throw new Error(\n            \"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters must be\" +\n            \"number, string, bool or InkList. Argument was \" +\n            (nullIfUndefined(arguments[i]) === null)\n              ? \"null\"\n              : arguments[i].constructor.name\n          );\n        }\n\n        this.PushEvaluationStack(Value.Create(args[i]));\n      }\n    }\n  }\n\n  public TryExitFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type ==\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      this.currentPointer = Pointer.Null;\n      this.didSafeExit = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  public CompleteFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type !=\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      throw new Error(\n        \"Expected external function evaluation to be complete. Stack trace: \" +\n          this.callStack.callStackTrace\n      );\n    }\n\n    let originalEvaluationStackHeight =\n      this.callStack.currentElement.evaluationStackHeightWhenPushed;\n\n    let returnedObj: InkObject | null = null;\n    while (this.evaluationStack.length > originalEvaluationStackHeight) {\n      let poppedObj = this.PopEvaluationStack();\n      if (returnedObj === null) returnedObj = poppedObj;\n    }\n\n    this.PopCallStack(PushPopType.FunctionEvaluationFromGame);\n\n    if (returnedObj) {\n      if (returnedObj instanceof Void) return null;\n\n      // Some kind of value, if not void\n      // var returnVal = returnedObj as Runtime.Value;\n      let returnVal = asOrThrows(returnedObj, Value);\n\n      // DivertTargets get returned as the string of components\n      // (rather than a Path, which isn't public)\n      if (returnVal.valueType == ValueType.DivertTarget) {\n        return returnVal.valueObject.toString();\n      }\n\n      // Other types can just have their exact object type:\n      // int, float, string. VariablePointers get returned as strings.\n      return returnVal.valueObject;\n    }\n\n    return null;\n  }\n\n  public AddError(message: string, isWarning: boolean) {\n    if (!isWarning) {\n      if (this._currentErrors == null) this._currentErrors = [];\n      this._currentErrors.push(message);\n    } else {\n      if (this._currentWarnings == null) this._currentWarnings = [];\n      this._currentWarnings.push(message);\n    }\n  }\n\n  public OutputStreamDirty() {\n    this._outputStreamTextDirty = true;\n    this._outputStreamTagsDirty = true;\n  }\n\n  private _visitCounts: Map<string, number>;\n  private _turnIndices: Map<string, number>;\n\n  private _outputStreamTextDirty = true;\n  private _outputStreamTagsDirty = true;\n\n  private _patch: StatePatch | null = null;\n\n  private _currentFlow: Flow;\n  private _aliveFlowNames: string[] | null = null;\n  private _namedFlows: Map<string, Flow> | null = null;\n  private readonly kDefaultFlowName = \"DEFAULT_FLOW\";\n  private _aliveFlowNamesDirty: boolean = true;\n}\n","// This is simple replacement of the Stopwatch class from the .NET Framework.\n// The original class can count time with much more accuracy than the Javascript version.\n// It might be worth considering using `window.performance` in the browser\n// or `process.hrtime()` in node.\nexport class Stopwatch {\n  private startTime: number | undefined;\n\n  constructor() {\n    this.startTime = undefined;\n  }\n\n  get ElapsedMilliseconds(): number {\n    if (typeof this.startTime === \"undefined\") {\n      return 0;\n    }\n    return new Date().getTime() - this.startTime;\n  }\n\n  public Start() {\n    this.startTime = new Date().getTime();\n  }\n  public Stop() {\n    this.startTime = undefined;\n  }\n}\n","import { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { StoryState } from \"./StoryState\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { Choice } from \"./Choice\";\nimport { Divert } from \"./Divert\";\nimport {\n  Value,\n  StringValue,\n  IntValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n} from \"./Value\";\nimport { Path } from \"./Path\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { StoryException } from \"./StoryException\";\nimport { PRNG } from \"./PRNG\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Stopwatch } from \"./StopWatch\";\nimport { Pointer } from \"./Pointer\";\nimport { InkList, InkListItem, KeyValuePair } from \"./InkList\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { DebugMetadata } from \"./DebugMetadata\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { ErrorHandler, ErrorType } from \"./Error\";\n\nexport { InkList } from \"./InkList\";\n\nif (!Number.isInteger) {\n  Number.isInteger = function isInteger(nVal: any) {\n    return (\n      typeof nVal === \"number\" &&\n      isFinite(nVal) &&\n      nVal > -9007199254740992 &&\n      nVal < 9007199254740992 &&\n      Math.floor(nVal) === nVal\n    );\n  };\n}\n\nexport class Story extends InkObject {\n  public static inkVersionCurrent = 21;\n\n  public inkVersionMinimumCompatible = 18;\n\n  get currentChoices() {\n    let choices: Choice[] = [];\n\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    for (let c of this._state.currentChoices) {\n      if (!c.isInvisibleDefault) {\n        c.index = choices.length;\n        choices.push(c);\n      }\n    }\n\n    return choices;\n  }\n\n  get currentText() {\n    this.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n    return this.state.currentText;\n  }\n\n  get currentTags() {\n    this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n    return this.state.currentTags;\n  }\n\n  get currentErrors() {\n    return this.state.currentErrors;\n  }\n\n  get currentWarnings() {\n    return this.state.currentWarnings;\n  }\n\n  get currentFlowName() {\n    return this.state.currentFlowName;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this.state.currentFlowIsDefaultFlow;\n  }\n\n  get aliveFlowNames() {\n    return this.state.aliveFlowNames;\n  }\n\n  get hasError() {\n    return this.state.hasError;\n  }\n\n  get hasWarning() {\n    return this.state.hasWarning;\n  }\n\n  get variablesState() {\n    return this.state.variablesState;\n  }\n\n  get listDefinitions() {\n    return this._listDefinitions;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  public onError: ErrorHandler | null = null;\n\n  public onDidContinue: (() => void) | null = null;\n\n  public onMakeChoice: ((arg1: Choice) => void) | null = null;\n\n  public onEvaluateFunction: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  public onCompleteEvaluateFunction:\n    | ((arg1: string, arg2: any[], arg3: string, arg4: any) => void)\n    | null = null;\n\n  public onChoosePathString: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  // TODO: Implement Profiler\n  public StartProfiling() {\n    /* */\n  }\n  public EndProfiling() {\n    /* */\n  }\n\n  constructor(contentContainer: Container, lists: ListDefinition[] | null);\n  constructor(jsonString: string);\n  constructor(json: Record<string, any>);\n  constructor() {\n    super();\n\n    // Discrimination between constructors\n    let contentContainer: Container;\n    let lists: ListDefinition[] | null = null;\n    let json: Record<string, any> | null = null;\n\n    if (arguments[0] instanceof Container) {\n      contentContainer = arguments[0] as Container;\n\n      if (typeof arguments[1] !== \"undefined\") {\n        lists = arguments[1] as ListDefinition[];\n      }\n\n      // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n      this._mainContentContainer = contentContainer;\n      // ------\n    } else {\n      if (typeof arguments[0] === \"string\") {\n        let jsonString = arguments[0] as string;\n        json = SimpleJson.TextToDictionary(jsonString);\n      } else {\n        json = arguments[0] as Record<string, any>;\n      }\n    }\n\n    // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n    if (lists != null) this._listDefinitions = new ListDefinitionsOrigin(lists);\n\n    this._externals = new Map();\n    // ------\n\n    // ------ Story(string jsonString) : this((Container)null)\n    if (json !== null) {\n      let rootObject: Record<string, any> = json;\n\n      let versionObj = rootObject[\"inkVersion\"];\n      if (versionObj == null)\n        throw new Error(\n          \"ink version number not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let formatFromFile = parseInt(versionObj);\n      if (formatFromFile > Story.inkVersionCurrent) {\n        throw new Error(\n          \"Version of ink used to build story was newer than the current version of the engine\"\n        );\n      } else if (formatFromFile < this.inkVersionMinimumCompatible) {\n        throw new Error(\n          \"Version of ink used to build story is too old to be loaded by this version of the engine\"\n        );\n      } else if (formatFromFile != Story.inkVersionCurrent) {\n        console.warn(\n          \"WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.\"\n        );\n      }\n\n      let rootToken = rootObject[\"root\"];\n      if (rootToken == null)\n        throw new Error(\n          \"Root node for ink not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let listDefsObj;\n      if ((listDefsObj = rootObject[\"listDefs\"])) {\n        this._listDefinitions =\n          JsonSerialisation.JTokenToListDefinitions(listDefsObj);\n      }\n\n      this._mainContentContainer = asOrThrows(\n        JsonSerialisation.JTokenToRuntimeObject(rootToken),\n        Container\n      );\n\n      this.ResetState();\n    }\n    // ------\n  }\n\n  // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.\n  // Will only return a value if writer was not provided.\n  public ToJson(writer?: SimpleJson.Writer): string | void {\n    let shouldReturn = false;\n\n    if (!writer) {\n      shouldReturn = true;\n      writer = new SimpleJson.Writer();\n    }\n\n    writer.WriteObjectStart();\n\n    writer.WriteIntProperty(\"inkVersion\", Story.inkVersionCurrent);\n\n    writer.WriteProperty(\"root\", (w) =>\n      JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer)\n    );\n\n    if (this._listDefinitions != null) {\n      writer.WritePropertyStart(\"listDefs\");\n      writer.WriteObjectStart();\n\n      for (let def of this._listDefinitions.lists) {\n        writer.WritePropertyStart(def.name);\n        writer.WriteObjectStart();\n\n        for (let [key, value] of def.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          let val = value;\n          writer.WriteIntProperty(item.itemName, val);\n        }\n\n        writer.WriteObjectEnd();\n        writer.WritePropertyEnd();\n      }\n\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    if (shouldReturn) return writer.toString();\n  }\n\n  public ResetState() {\n    this.IfAsyncWeCant(\"ResetState\");\n\n    this._state = new StoryState(this);\n    this._state.variablesState.ObserveVariableChange(\n      this.VariableStateDidChangeEvent.bind(this)\n    );\n\n    this.ResetGlobals();\n  }\n\n  public ResetErrors() {\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ResetErrors();\n  }\n\n  public ResetCallstack() {\n    this.IfAsyncWeCant(\"ResetCallstack\");\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ForceEnd();\n  }\n\n  public ResetGlobals() {\n    if (this._mainContentContainer.namedContent.get(\"global decl\")) {\n      let originalPointer = this.state.currentPointer.copy();\n\n      this.ChoosePath(new Path(\"global decl\"), false);\n\n      this.ContinueInternal();\n\n      this.state.currentPointer = originalPointer;\n    }\n\n    this.state.variablesState.SnapshotDefaultGlobals();\n  }\n\n  public SwitchFlow(flowName: string) {\n    this.IfAsyncWeCant(\"switch flow\");\n    if (this._asyncSaving) {\n      throw new Error(\n        \"Story is already in background saving mode, can't switch flow to \" +\n          flowName\n      );\n    }\n\n    this.state.SwitchFlow_Internal(flowName);\n  }\n\n  public RemoveFlow(flowName: string) {\n    this.state.RemoveFlow_Internal(flowName);\n  }\n\n  public SwitchToDefaultFlow() {\n    this.state.SwitchToDefaultFlow_Internal();\n  }\n\n  public Continue() {\n    this.ContinueAsync(0);\n    return this.currentText;\n  }\n\n  get canContinue() {\n    return this.state.canContinue;\n  }\n\n  get asyncContinueComplete() {\n    return !this._asyncContinueActive;\n  }\n\n  public ContinueAsync(millisecsLimitAsync: number) {\n    if (!this._hasValidatedExternals) this.ValidateExternalBindings();\n\n    this.ContinueInternal(millisecsLimitAsync);\n  }\n\n  public ContinueInternal(millisecsLimitAsync = 0) {\n    if (this._profiler != null) this._profiler.PreContinue();\n\n    let isAsyncTimeLimited = millisecsLimitAsync > 0;\n    this._recursiveContinueCount++;\n\n    if (!this._asyncContinueActive) {\n      this._asyncContinueActive = isAsyncTimeLimited;\n\n      if (!this.canContinue) {\n        throw new Error(\n          \"Can't continue - should check canContinue before calling Continue\"\n        );\n      }\n\n      this._state.didSafeExit = false;\n      this._state.ResetOutput();\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = true;\n    }\n\n    let durationStopwatch = new Stopwatch();\n    durationStopwatch.Start();\n\n    let outputStreamEndsInNewline = false;\n    this._sawLookaheadUnsafeFunctionAfterNewline = false;\n    do {\n      try {\n        outputStreamEndsInNewline = this.ContinueSingleStep();\n      } catch (e) {\n        if (!(e instanceof StoryException)) throw e;\n\n        this.AddError(e.message, undefined, e.useEndLineNumber);\n        break;\n      }\n\n      if (outputStreamEndsInNewline) break;\n\n      if (\n        this._asyncContinueActive &&\n        durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync\n      ) {\n        break;\n      }\n    } while (this.canContinue);\n\n    durationStopwatch.Stop();\n\n    if (outputStreamEndsInNewline || !this.canContinue) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        this.RestoreStateSnapshot();\n      }\n\n      if (!this.canContinue) {\n        if (this.state.callStack.canPopThread)\n          this.AddError(\n            \"Thread available to pop, threads should always be flat by the end of evaluation?\"\n          );\n\n        if (\n          this.state.generatedChoices.length == 0 &&\n          !this.state.didSafeExit &&\n          this._temporaryEvaluationContainer == null\n        ) {\n          if (this.state.callStack.CanPop(PushPopType.Tunnel))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\"\n            );\n          else if (this.state.callStack.CanPop(PushPopType.Function))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '~ return'?\"\n            );\n          else if (!this.state.callStack.canPop)\n            this.AddError(\n              \"ran out of content. Do you need a '-> DONE' or '-> END'?\"\n            );\n          else\n            this.AddError(\n              \"unexpectedly reached end of content for unknown reason. Please debug compiler!\"\n            );\n        }\n      }\n\n      this.state.didSafeExit = false;\n      this._sawLookaheadUnsafeFunctionAfterNewline = false;\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = false;\n\n      this._asyncContinueActive = false;\n      if (this.onDidContinue !== null) this.onDidContinue();\n    }\n\n    this._recursiveContinueCount--;\n\n    if (this._profiler != null) this._profiler.PostContinue();\n\n    // In the following code, we're masking a lot of non-null assertion,\n    // because testing for against `hasError` or `hasWarning` makes sure\n    // the arrays are present and contain at least one element.\n    if (this.state.hasError || this.state.hasWarning) {\n      if (this.onError !== null) {\n        if (this.state.hasError) {\n          for (let err of this.state.currentErrors!) {\n            this.onError(err, ErrorType.Error);\n          }\n        }\n        if (this.state.hasWarning) {\n          for (let err of this.state.currentWarnings!) {\n            this.onError(err, ErrorType.Warning);\n          }\n        }\n        this.ResetErrors();\n      } else {\n        let sb = new StringBuilder();\n        sb.Append(\"Ink had \");\n        if (this.state.hasError) {\n          sb.Append(`${this.state.currentErrors!.length}`);\n          sb.Append(\n            this.state.currentErrors!.length == 1 ? \" error\" : \"errors\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        if (this.state.hasWarning) {\n          sb.Append(`${this.state.currentWarnings!.length}`);\n          sb.Append(\n            this.state.currentWarnings!.length == 1 ? \" warning\" : \"warnings\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        sb.Append(\n          \". It is strongly suggested that you assign an error handler to story.onError. The first issue was: \"\n        );\n        sb.Append(\n          this.state.hasError\n            ? this.state.currentErrors![0]\n            : this.state.currentWarnings![0]\n        );\n\n        throw new StoryException(sb.toString());\n      }\n    }\n  }\n\n  public ContinueSingleStep() {\n    if (this._profiler != null) this._profiler.PreStep();\n\n    this.Step();\n\n    if (this._profiler != null) this._profiler.PostStep();\n\n    if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n      this.TryFollowDefaultInvisibleChoice();\n    }\n\n    if (this._profiler != null) this._profiler.PreSnapshot();\n\n    if (!this.state.inStringEvaluation) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        if (this._stateSnapshotAtLastNewline.currentTags === null) {\n          return throwNullException(\"this._stateAtLastNewline.currentTags\");\n        }\n        if (this.state.currentTags === null) {\n          return throwNullException(\"this.state.currentTags\");\n        }\n\n        let change = this.CalculateNewlineOutputStateChange(\n          this._stateSnapshotAtLastNewline.currentText,\n          this.state.currentText,\n          this._stateSnapshotAtLastNewline.currentTags.length,\n          this.state.currentTags.length\n        );\n\n        if (\n          change == Story.OutputStateChange.ExtendedBeyondNewline ||\n          this._sawLookaheadUnsafeFunctionAfterNewline\n        ) {\n          this.RestoreStateSnapshot();\n\n          return true;\n        } else if (change == Story.OutputStateChange.NewlineRemoved) {\n          this.DiscardSnapshot();\n        }\n      }\n\n      if (this.state.outputStreamEndsInNewline) {\n        if (this.canContinue) {\n          if (this._stateSnapshotAtLastNewline == null) this.StateSnapshot();\n        } else {\n          this.DiscardSnapshot();\n        }\n      }\n    }\n\n    if (this._profiler != null) this._profiler.PostSnapshot();\n\n    return false;\n  }\n\n  public CalculateNewlineOutputStateChange(\n    prevText: string | null,\n    currText: string | null,\n    prevTagCount: number,\n    currTagCount: number\n  ) {\n    if (prevText === null) {\n      return throwNullException(\"prevText\");\n    }\n    if (currText === null) {\n      return throwNullException(\"currText\");\n    }\n\n    let newlineStillExists =\n      currText.length >= prevText.length &&\n      prevText.length > 0 &&\n      currText.charAt(prevText.length - 1) == \"\\n\";\n    if (\n      prevTagCount == currTagCount &&\n      prevText.length == currText.length &&\n      newlineStillExists\n    )\n      return Story.OutputStateChange.NoChange;\n\n    if (!newlineStillExists) {\n      return Story.OutputStateChange.NewlineRemoved;\n    }\n\n    if (currTagCount > prevTagCount)\n      return Story.OutputStateChange.ExtendedBeyondNewline;\n\n    for (let i = prevText.length; i < currText.length; i++) {\n      let c = currText.charAt(i);\n      if (c != \" \" && c != \"\\t\") {\n        return Story.OutputStateChange.ExtendedBeyondNewline;\n      }\n    }\n\n    return Story.OutputStateChange.NoChange;\n  }\n\n  public ContinueMaximally() {\n    this.IfAsyncWeCant(\"ContinueMaximally\");\n\n    let sb = new StringBuilder();\n\n    while (this.canContinue) {\n      sb.Append(this.Continue());\n    }\n\n    return sb.toString();\n  }\n\n  public ContentAtPath(path: Path) {\n    return this.mainContentContainer.ContentAtPath(path);\n  }\n\n  public KnotContainerWithName(name: string) {\n    let namedContainer = this.mainContentContainer.namedContent.get(name);\n    if (namedContainer instanceof Container) return namedContainer;\n    else return null;\n  }\n\n  public PointerAtPath(path: Path) {\n    if (path.length == 0) return Pointer.Null;\n\n    let p = new Pointer();\n\n    let pathLengthToUse = path.length;\n\n    let result = null;\n    if (path.lastComponent === null) {\n      return throwNullException(\"path.lastComponent\");\n    }\n\n    if (path.lastComponent.isIndex) {\n      pathLengthToUse = path.length - 1;\n      result = this.mainContentContainer.ContentAtPath(\n        path,\n        undefined,\n        pathLengthToUse\n      );\n      p.container = result.container;\n      p.index = path.lastComponent.index;\n    } else {\n      result = this.mainContentContainer.ContentAtPath(path);\n      p.container = result.container;\n      p.index = -1;\n    }\n\n    if (\n      result.obj == null ||\n      (result.obj == this.mainContentContainer && pathLengthToUse > 0)\n    ) {\n      this.Error(\n        \"Failed to find content at path '\" +\n          path +\n          \"', and no approximation of it was possible.\"\n      );\n    } else if (result.approximate)\n      this.Warning(\n        \"Failed to find content at path '\" +\n          path +\n          \"', so it was approximated to: '\" +\n          result.obj.path +\n          \"'.\"\n      );\n\n    return p;\n  }\n\n  public StateSnapshot() {\n    this._stateSnapshotAtLastNewline = this._state;\n    this._state = this._state.CopyAndStartPatching();\n  }\n\n  public RestoreStateSnapshot() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      throwNullException(\"_stateSnapshotAtLastNewline\");\n    }\n    this._stateSnapshotAtLastNewline.RestoreAfterPatch();\n\n    this._state = this._stateSnapshotAtLastNewline;\n    this._stateSnapshotAtLastNewline = null;\n\n    if (!this._asyncSaving) {\n      this._state.ApplyAnyPatch();\n    }\n  }\n\n  public DiscardSnapshot() {\n    if (!this._asyncSaving) this._state.ApplyAnyPatch();\n\n    this._stateSnapshotAtLastNewline = null;\n  }\n\n  public CopyStateForBackgroundThreadSave() {\n    this.IfAsyncWeCant(\"start saving on a background thread\");\n\n    if (this._asyncSaving)\n      throw new Error(\n        \"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\"\n      );\n\n    let stateToSave = this._state;\n    this._state = this._state.CopyAndStartPatching();\n    this._asyncSaving = true;\n    return stateToSave;\n  }\n\n  public BackgroundSaveComplete() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      this._state.ApplyAnyPatch();\n    }\n\n    this._asyncSaving = false;\n  }\n\n  public Step() {\n    let shouldAddToStream = true;\n\n    let pointer = this.state.currentPointer.copy();\n    if (pointer.isNull) {\n      return;\n    }\n\n    // Container containerToEnter = pointer.Resolve () as Container;\n    let containerToEnter = asOrNull(pointer.Resolve(), Container);\n\n    while (containerToEnter) {\n      this.VisitContainer(containerToEnter, true);\n\n      // No content? the most we can do is step past it\n      if (containerToEnter.content.length == 0) {\n        break;\n      }\n\n      pointer = Pointer.StartOf(containerToEnter);\n      // containerToEnter = pointer.Resolve() as Container;\n      containerToEnter = asOrNull(pointer.Resolve(), Container);\n    }\n\n    this.state.currentPointer = pointer.copy();\n\n    if (this._profiler != null) this._profiler.Step(this.state.callStack);\n\n    // Is the current content object:\n    //  - Normal content\n    //  - Or a logic/flow statement - if so, do it\n    // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n    // that was diverted to rather than called as a function)\n    let currentContentObj = pointer.Resolve();\n    let isLogicOrFlowControl =\n      this.PerformLogicAndFlowControl(currentContentObj);\n\n    // Has flow been forced to end by flow control above?\n    if (this.state.currentPointer.isNull) {\n      return;\n    }\n\n    if (isLogicOrFlowControl) {\n      shouldAddToStream = false;\n    }\n\n    // Choice with condition?\n    // var choicePoint = currentContentObj as ChoicePoint;\n    let choicePoint = asOrNull(currentContentObj, ChoicePoint);\n    if (choicePoint) {\n      let choice = this.ProcessChoice(choicePoint);\n      if (choice) {\n        this.state.generatedChoices.push(choice);\n      }\n\n      currentContentObj = null;\n      shouldAddToStream = false;\n    }\n\n    // If the container has no content, then it will be\n    // the \"content\" itself, but we skip over it.\n    if (currentContentObj instanceof Container) {\n      shouldAddToStream = false;\n    }\n\n    // Content to add to evaluation stack or the output stream\n    if (shouldAddToStream) {\n      // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n      // to our current (possibly temporary) context index. And make a copy of the pointer\n      // so that we're not editing the original runtime object.\n      // var varPointer = currentContentObj as VariablePointerValue;\n      let varPointer = asOrNull(currentContentObj, VariablePointerValue);\n      if (varPointer && varPointer.contextIndex == -1) {\n        // Create new object so we're not overwriting the story's own data\n        let contextIdx = this.state.callStack.ContextForVariableNamed(\n          varPointer.variableName\n        );\n        currentContentObj = new VariablePointerValue(\n          varPointer.variableName,\n          contextIdx\n        );\n      }\n\n      // Expression evaluation content\n      if (this.state.inExpressionEvaluation) {\n        this.state.PushEvaluationStack(currentContentObj);\n      }\n      // Output stream content (i.e. not expression evaluation)\n      else {\n        this.state.PushToOutputStream(currentContentObj);\n      }\n    }\n\n    // Increment the content pointer, following diverts if necessary\n    this.NextContent();\n\n    // Starting a thread should be done after the increment to the content pointer,\n    // so that when returning from the thread, it returns to the content after this instruction.\n    // var controlCmd = currentContentObj as ;\n    let controlCmd = asOrNull(currentContentObj, ControlCommand);\n    if (\n      controlCmd &&\n      controlCmd.commandType == ControlCommand.CommandType.StartThread\n    ) {\n      this.state.callStack.PushThread();\n    }\n  }\n\n  public VisitContainer(container: Container, atStart: boolean) {\n    if (!container.countingAtStartOnly || atStart) {\n      if (container.visitsShouldBeCounted)\n        this.state.IncrementVisitCountForContainer(container);\n\n      if (container.turnIndexShouldBeCounted)\n        this.state.RecordTurnIndexVisitToContainer(container);\n    }\n  }\n\n  private _prevContainers: Container[] = [];\n  public VisitChangedContainersDueToDivert() {\n    let previousPointer = this.state.previousPointer.copy();\n    let pointer = this.state.currentPointer.copy();\n\n    if (pointer.isNull || pointer.index == -1) return;\n\n    this._prevContainers.length = 0;\n    if (!previousPointer.isNull) {\n      // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n      let resolvedPreviousAncestor = previousPointer.Resolve();\n      let prevAncestor =\n        asOrNull(resolvedPreviousAncestor, Container) ||\n        asOrNull(previousPointer.container, Container);\n      while (prevAncestor) {\n        this._prevContainers.push(prevAncestor);\n        // prevAncestor = prevAncestor.parent as Container;\n        prevAncestor = asOrNull(prevAncestor.parent, Container);\n      }\n    }\n\n    let currentChildOfContainer = pointer.Resolve();\n\n    if (currentChildOfContainer == null) return;\n\n    // Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n    let currentContainerAncestor = asOrNull(\n      currentChildOfContainer.parent,\n      Container\n    );\n    let allChildrenEnteredAtStart = true;\n    while (\n      currentContainerAncestor &&\n      (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||\n        currentContainerAncestor.countingAtStartOnly)\n    ) {\n      // Check whether this ancestor container is being entered at the start,\n      // by checking whether the child object is the first.\n      let enteringAtStart =\n        currentContainerAncestor.content.length > 0 &&\n        currentChildOfContainer == currentContainerAncestor.content[0] &&\n        allChildrenEnteredAtStart;\n\n      if (!enteringAtStart) allChildrenEnteredAtStart = false;\n\n      // Mark a visit to this container\n      this.VisitContainer(currentContainerAncestor, enteringAtStart);\n\n      currentChildOfContainer = currentContainerAncestor;\n      // currentContainerAncestor = currentContainerAncestor.parent as Container;\n      currentContainerAncestor = asOrNull(\n        currentContainerAncestor.parent,\n        Container\n      );\n    }\n  }\n\n  public PopChoiceStringAndTags(tags: string[]) {\n    let choiceOnlyStrVal = asOrThrows(\n      this.state.PopEvaluationStack(),\n      StringValue\n    );\n\n    while (\n      this.state.evaluationStack.length > 0 &&\n      asOrNull(this.state.PeekEvaluationStack(), Tag) != null\n    ) {\n      let tag = asOrNull(this.state.PopEvaluationStack(), Tag);\n      if (tag) tags.push(tag.text);\n    }\n    return choiceOnlyStrVal.value;\n  }\n\n  public ProcessChoice(choicePoint: ChoicePoint) {\n    let showChoice = true;\n\n    // Don't create choice if choice point doesn't pass conditional\n    if (choicePoint.hasCondition) {\n      let conditionValue = this.state.PopEvaluationStack();\n      if (!this.IsTruthy(conditionValue)) {\n        showChoice = false;\n      }\n    }\n\n    let startText = \"\";\n    let choiceOnlyText = \"\";\n    let tags: string[] = [];\n\n    if (choicePoint.hasChoiceOnlyContent) {\n      choiceOnlyText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    if (choicePoint.hasStartContent) {\n      startText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    // Don't create choice if player has already read this content\n    if (choicePoint.onceOnly) {\n      let visitCount = this.state.VisitCountForContainer(\n        choicePoint.choiceTarget\n      );\n      if (visitCount > 0) {\n        showChoice = false;\n      }\n    }\n\n    // We go through the full process of creating the choice above so\n    // that we consume the content for it, since otherwise it'll\n    // be shown on the output stream.\n    if (!showChoice) {\n      return null;\n    }\n\n    let choice = new Choice();\n    choice.targetPath = choicePoint.pathOnChoice;\n    choice.sourcePath = choicePoint.path.toString();\n    choice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n    choice.threadAtGeneration = this.state.callStack.ForkThread();\n    choice.tags = tags.reverse(); //C# is a stack\n    choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");\n\n    return choice;\n  }\n\n  public IsTruthy(obj: InkObject) {\n    let truthy = false;\n    if (obj instanceof Value) {\n      let val = obj;\n\n      if (val instanceof DivertTargetValue) {\n        let divTarget = val;\n        this.Error(\n          \"Shouldn't use a divert target (to \" +\n            divTarget.targetPath +\n            \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\"\n        );\n        return false;\n      }\n\n      return val.isTruthy;\n    }\n    return truthy;\n  }\n\n  public PerformLogicAndFlowControl(contentObj: InkObject | null) {\n    if (contentObj == null) {\n      return false;\n    }\n\n    // Divert\n    if (contentObj instanceof Divert) {\n      let currentDivert = contentObj;\n\n      if (currentDivert.isConditional) {\n        let conditionValue = this.state.PopEvaluationStack();\n\n        // False conditional? Cancel divert\n        if (!this.IsTruthy(conditionValue)) return true;\n      }\n\n      if (currentDivert.hasVariableTarget) {\n        let varName = currentDivert.variableDivertName;\n\n        let varContents =\n          this.state.variablesState.GetVariableWithName(varName);\n\n        if (varContents == null) {\n          this.Error(\n            \"Tried to divert using a target from a variable that could not be found (\" +\n              varName +\n              \")\"\n          );\n        } else if (!(varContents instanceof DivertTargetValue)) {\n          // var intContent = varContents as IntValue;\n          let intContent = asOrNull(varContents, IntValue);\n\n          let errorMessage =\n            \"Tried to divert to a target from a variable, but the variable (\" +\n            varName +\n            \") didn't contain a divert target, it \";\n          if (intContent instanceof IntValue && intContent.value == 0) {\n            errorMessage += \"was empty/null (the value 0).\";\n          } else {\n            errorMessage += \"contained '\" + varContents + \"'.\";\n          }\n\n          this.Error(errorMessage);\n        }\n\n        let target = asOrThrows(varContents, DivertTargetValue);\n        this.state.divertedPointer = this.PointerAtPath(target.targetPath);\n      } else if (currentDivert.isExternal) {\n        this.CallExternalFunction(\n          currentDivert.targetPathString,\n          currentDivert.externalArgs\n        );\n        return true;\n      } else {\n        this.state.divertedPointer = currentDivert.targetPointer.copy();\n      }\n\n      if (currentDivert.pushesToStack) {\n        this.state.callStack.Push(\n          currentDivert.stackPushType,\n          undefined,\n          this.state.outputStream.length\n        );\n      }\n\n      if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n        if (\n          currentDivert &&\n          currentDivert.debugMetadata &&\n          currentDivert.debugMetadata.sourceName != null\n        ) {\n          this.Error(\n            \"Divert target doesn't exist: \" +\n              currentDivert.debugMetadata.sourceName\n          );\n        } else {\n          this.Error(\"Divert resolution failed: \" + currentDivert);\n        }\n      }\n\n      return true;\n    }\n\n    // Start/end an expression evaluation? Or print out the result?\n    else if (contentObj instanceof ControlCommand) {\n      let evalCommand = contentObj;\n\n      switch (evalCommand.commandType) {\n        case ControlCommand.CommandType.EvalStart:\n          this.Assert(\n            this.state.inExpressionEvaluation === false,\n            \"Already in expression evaluation?\"\n          );\n          this.state.inExpressionEvaluation = true;\n          break;\n\n        case ControlCommand.CommandType.EvalEnd:\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Not in expression evaluation mode\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EvalOutput:\n          // If the expression turned out to be empty, there may not be anything on the stack\n          if (this.state.evaluationStack.length > 0) {\n            let output = this.state.PopEvaluationStack();\n\n            // Functions may evaluate to Void, in which case we skip output\n            if (!(output instanceof Void)) {\n              // TODO: Should we really always blanket convert to string?\n              // It would be okay to have numbers in the output stream the\n              // only problem is when exporting text for viewing, it skips over numbers etc.\n              let text = new StringValue(output.toString());\n\n              this.state.PushToOutputStream(text);\n            }\n          }\n          break;\n\n        case ControlCommand.CommandType.NoOp:\n          break;\n\n        case ControlCommand.CommandType.Duplicate:\n          this.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n          break;\n\n        case ControlCommand.CommandType.PopEvaluatedValue:\n          this.state.PopEvaluationStack();\n          break;\n\n        case ControlCommand.CommandType.PopFunction:\n        case ControlCommand.CommandType.PopTunnel:\n          let popType =\n            evalCommand.commandType == ControlCommand.CommandType.PopFunction\n              ? PushPopType.Function\n              : PushPopType.Tunnel;\n\n          let overrideTunnelReturnTarget: DivertTargetValue | null = null;\n          if (popType == PushPopType.Tunnel) {\n            let popped = this.state.PopEvaluationStack();\n            // overrideTunnelReturnTarget = popped as DivertTargetValue;\n            overrideTunnelReturnTarget = asOrNull(popped, DivertTargetValue);\n            if (overrideTunnelReturnTarget === null) {\n              this.Assert(\n                popped instanceof Void,\n                \"Expected void if ->-> doesn't override target\"\n              );\n            }\n          }\n\n          if (this.state.TryExitFunctionEvaluationFromGame()) {\n            break;\n          } else if (\n            this.state.callStack.currentElement.type != popType ||\n            !this.state.callStack.canPop\n          ) {\n            let names: Map<PushPopType, string> = new Map();\n            names.set(\n              PushPopType.Function,\n              \"function return statement (~ return)\"\n            );\n            names.set(PushPopType.Tunnel, \"tunnel onwards statement (->->)\");\n\n            let expected = names.get(this.state.callStack.currentElement.type);\n            if (!this.state.callStack.canPop) {\n              expected = \"end of flow (-> END or choice)\";\n            }\n\n            let errorMsg =\n              \"Found \" + names.get(popType) + \", when expected \" + expected;\n\n            this.Error(errorMsg);\n          } else {\n            this.state.PopCallStack();\n\n            if (overrideTunnelReturnTarget)\n              this.state.divertedPointer = this.PointerAtPath(\n                overrideTunnelReturnTarget.targetPath\n              );\n          }\n          break;\n\n        case ControlCommand.CommandType.BeginString:\n          this.state.PushToOutputStream(evalCommand);\n\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Expected to be in an expression when evaluating a string\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        // Leave it to story.currentText and story.currentTags to sort out the text from the tags\n        // This is mostly because we can't always rely on the existence of EndTag, and we don't want\n        // to try and flatten dynamic tags to strings every time \\n is pushed to output\n        case ControlCommand.CommandType.BeginTag:\n          this.state.PushToOutputStream(evalCommand);\n          break;\n\n        // EndTag has 2 modes:\n        //  - When in string evaluation (for choices)\n        //  - Normal\n        //\n        // The only way you could have an EndTag in the middle of\n        // string evaluation is if we're currently generating text for a\n        // choice, such as:\n        //\n        //   + choice # tag\n        //\n        // In the above case, the ink will be run twice:\n        //  - First, to generate the choice text. String evaluation\n        //    will be on, and the final string will be pushed to the\n        //    evaluation stack, ready to be popped to make a Choice\n        //    object.\n        //  - Second, when ink generates text after choosing the choice.\n        //    On this ocassion, it's not in string evaluation mode.\n        //\n        // On the writing side, we disallow manually putting tags within\n        // strings like this:\n        //\n        //   {\"hello # world\"}\n        //\n        // So we know that the tag must be being generated as part of\n        // choice content. Therefore, when the tag has been generated,\n        // we push it onto the evaluation stack in the exact same way\n        // as the string for the choice content.\n        case ControlCommand.CommandType.EndTag: {\n          if (this.state.inStringEvaluation) {\n            let contentStackForTag: InkObject[] = [];\n            let outputCountConsumed = 0;\n            for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n              let obj = this.state.outputStream[i];\n              outputCountConsumed++;\n\n              // var command = obj as ControlCommand;\n              let command = asOrNull(obj, ControlCommand);\n              if (command != null) {\n                if (\n                  command.commandType == ControlCommand.CommandType.BeginTag\n                ) {\n                  break;\n                } else {\n                  this.Error(\n                    \"Unexpected ControlCommand while extracting tag from choice\"\n                  );\n                  break;\n                }\n              }\n              if (obj instanceof StringValue) {\n                contentStackForTag.push(obj);\n              }\n            }\n\n            // Consume the content that was produced for this string\n            this.state.PopFromOutputStream(outputCountConsumed);\n            // Build string out of the content we collected\n            let sb = new StringBuilder();\n            for (let strVal of contentStackForTag) {\n              sb.Append(strVal.toString());\n            }\n            let choiceTag = new Tag(\n              this.state.CleanOutputWhitespace(sb.toString())\n            );\n            // Pushing to the evaluation stack means it gets picked up\n            // when a Choice is generated from the next Choice Point.\n            this.state.PushEvaluationStack(choiceTag);\n          } else {\n            // Otherwise! Simply push EndTag, so that in the output stream we\n            // have a structure of: [BeginTag, \"the tag content\", EndTag]\n            this.state.PushToOutputStream(evalCommand);\n          }\n          break;\n        }\n\n        case ControlCommand.CommandType.EndString: {\n          let contentStackForString: InkObject[] = [];\n          let contentToRetain: InkObject[] = [];\n\n          let outputCountConsumed = 0;\n          for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n            let obj = this.state.outputStream[i];\n\n            outputCountConsumed++;\n\n            // var command = obj as ControlCommand;\n            let command = asOrNull(obj, ControlCommand);\n            if (\n              command &&\n              command.commandType == ControlCommand.CommandType.BeginString\n            ) {\n              break;\n            }\n            if (obj instanceof Tag) {\n              contentToRetain.push(obj);\n            }\n            if (obj instanceof StringValue) {\n              contentStackForString.push(obj);\n            }\n          }\n\n          // Consume the content that was produced for this string\n          this.state.PopFromOutputStream(outputCountConsumed);\n\n          // Rescue the tags that we want actually to keep on the output stack\n          // rather than consume as part of the string we're building.\n          // At the time of writing, this only applies to Tag objects generated\n          // by choices, which are pushed to the stack during string generation.\n          for (let rescuedTag of contentToRetain)\n            this.state.PushToOutputStream(rescuedTag);\n\n          // The C# version uses a Stack for contentStackForString, but we're\n          // using a simple array, so we need to reverse it before using it\n          contentStackForString = contentStackForString.reverse();\n\n          // Build string out of the content we collected\n          let sb = new StringBuilder();\n          for (let c of contentStackForString) {\n            sb.Append(c.toString());\n          }\n\n          // Return to expression evaluation (from content mode)\n          this.state.inExpressionEvaluation = true;\n          this.state.PushEvaluationStack(new StringValue(sb.toString()));\n          break;\n        }\n\n        case ControlCommand.CommandType.ChoiceCount:\n          let choiceCount = this.state.generatedChoices.length;\n          this.state.PushEvaluationStack(new IntValue(choiceCount));\n          break;\n\n        case ControlCommand.CommandType.Turns:\n          this.state.PushEvaluationStack(\n            new IntValue(this.state.currentTurnIndex + 1)\n          );\n          break;\n\n        case ControlCommand.CommandType.TurnsSince:\n        case ControlCommand.CommandType.ReadCount:\n          let target = this.state.PopEvaluationStack();\n          if (!(target instanceof DivertTargetValue)) {\n            let extraNote = \"\";\n            if (target instanceof IntValue)\n              extraNote =\n                \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n            this.Error(\n              \"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" +\n                target +\n                extraNote\n            );\n            break;\n          }\n\n          // var divertTarget = target as DivertTargetValue;\n          let divertTarget = asOrThrows(target, DivertTargetValue);\n          // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n          let container = asOrNull(\n            this.ContentAtPath(divertTarget.targetPath).correctObj,\n            Container\n          );\n\n          let eitherCount;\n          if (container != null) {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = this.state.TurnsSinceForContainer(container);\n            else eitherCount = this.state.VisitCountForContainer(container);\n          } else {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = -1;\n            else eitherCount = 0;\n\n            this.Warning(\n              \"Failed to find container for \" +\n                evalCommand.toString() +\n                \" lookup at \" +\n                divertTarget.targetPath.toString()\n            );\n          }\n\n          this.state.PushEvaluationStack(new IntValue(eitherCount));\n          break;\n\n        case ControlCommand.CommandType.Random: {\n          let maxInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          let minInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\n          if (minInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for minimum parameter of RANDOM(min, max)\"\n            );\n\n          if (maxInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for maximum parameter of RANDOM(min, max)\"\n            );\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (maxInt.value === null) {\n            return throwNullException(\"maxInt.value\");\n          }\n          if (minInt.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          // This code is differs a bit from the reference implementation, since\n          // JavaScript has no true integers. Hence integer arithmetics and\n          // interger overflows don't apply here. A loss of precision can\n          // happen with big numbers however.\n          //\n          // The case where 'randomRange' is lower than zero is handled below,\n          // so there's no need to test against Number.MIN_SAFE_INTEGER.\n          let randomRange = maxInt.value - minInt.value + 1;\n          if (!isFinite(randomRange) || randomRange > Number.MAX_SAFE_INTEGER) {\n            randomRange = Number.MAX_SAFE_INTEGER;\n            this.Error(\n              \"RANDOM was called with a range that exceeds the size that ink numbers can use.\"\n            );\n          }\n          if (randomRange <= 0)\n            this.Error(\n              \"RANDOM was called with minimum as \" +\n                minInt.value +\n                \" and maximum as \" +\n                maxInt.value +\n                \". The maximum must be larger\"\n            );\n\n          let resultSeed = this.state.storySeed + this.state.previousRandom;\n          let random = new PRNG(resultSeed);\n\n          let nextRandom = random.next();\n          let chosenValue = (nextRandom % randomRange) + minInt.value;\n          this.state.PushEvaluationStack(new IntValue(chosenValue));\n\n          // Next random number (rather than keeping the Random object around)\n          this.state.previousRandom = nextRandom;\n          break;\n        }\n\n        case ControlCommand.CommandType.SeedRandom:\n          let seed = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          if (seed == null || seed instanceof IntValue === false)\n            return this.Error(\"Invalid value passed to SEED_RANDOM\");\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (seed.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          this.state.storySeed = seed.value;\n          this.state.previousRandom = 0;\n\n          this.state.PushEvaluationStack(new Void());\n          break;\n\n        case ControlCommand.CommandType.VisitIndex:\n          let count =\n            this.state.VisitCountForContainer(\n              this.state.currentPointer.container\n            ) - 1; // index not count\n          this.state.PushEvaluationStack(new IntValue(count));\n          break;\n\n        case ControlCommand.CommandType.SequenceShuffleIndex:\n          let shuffleIndex = this.NextSequenceShuffleIndex();\n          this.state.PushEvaluationStack(new IntValue(shuffleIndex));\n          break;\n\n        case ControlCommand.CommandType.StartThread:\n          // Handled in main step function\n          break;\n\n        case ControlCommand.CommandType.Done:\n          // We may exist in the context of the initial\n          // act of creating the thread, or in the context of\n          // evaluating the content.\n          if (this.state.callStack.canPopThread) {\n            this.state.callStack.PopThread();\n          }\n\n          // In normal flow - allow safe exit without warning\n          else {\n            this.state.didSafeExit = true;\n\n            // Stop flow in current thread\n            this.state.currentPointer = Pointer.Null;\n          }\n\n          break;\n\n        // Force flow to end completely\n        case ControlCommand.CommandType.End:\n          this.state.ForceEnd();\n          break;\n\n        case ControlCommand.CommandType.ListFromInt:\n          // var intVal = state.PopEvaluationStack () as IntValue;\n          let intVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          // var listNameVal = state.PopEvaluationStack () as StringValue;\n          let listNameVal = asOrThrows(\n            this.state.PopEvaluationStack(),\n            StringValue\n          );\n\n          if (intVal === null) {\n            throw new StoryException(\n              \"Passed non-integer when creating a list element from a numerical value.\"\n            );\n          }\n\n          let generatedListValue = null;\n\n          if (this.listDefinitions === null) {\n            return throwNullException(\"this.listDefinitions\");\n          }\n          let foundListDef = this.listDefinitions.TryListGetDefinition(\n            listNameVal.value,\n            null\n          );\n          if (foundListDef.exists) {\n            // Originally a primitive type, but here, can be null.\n            // TODO: Replace by default value?\n            if (intVal.value === null) {\n              return throwNullException(\"minInt.value\");\n            }\n\n            let foundItem = foundListDef.result!.TryGetItemWithValue(\n              intVal.value,\n              InkListItem.Null\n            );\n            if (foundItem.exists) {\n              generatedListValue = new ListValue(\n                foundItem.result!,\n                intVal.value\n              );\n            }\n          } else {\n            throw new StoryException(\n              \"Failed to find LIST called \" + listNameVal.value\n            );\n          }\n\n          if (generatedListValue == null) generatedListValue = new ListValue();\n\n          this.state.PushEvaluationStack(generatedListValue);\n          break;\n\n        case ControlCommand.CommandType.ListRange:\n          let max = asOrNull(this.state.PopEvaluationStack(), Value);\n          let min = asOrNull(this.state.PopEvaluationStack(), Value);\n\n          // var targetList = state.PopEvaluationStack () as ListValue;\n          let targetList = asOrNull(this.state.PopEvaluationStack(), ListValue);\n\n          if (targetList === null || min === null || max === null)\n            throw new StoryException(\n              \"Expected list, minimum and maximum for LIST_RANGE\"\n            );\n\n          if (targetList.value === null) {\n            return throwNullException(\"targetList.value\");\n          }\n          let result = targetList.value.ListWithSubRange(\n            min.valueObject,\n            max.valueObject\n          );\n\n          this.state.PushEvaluationStack(new ListValue(result));\n          break;\n\n        case ControlCommand.CommandType.ListRandom: {\n          let listVal = this.state.PopEvaluationStack() as ListValue;\n          if (listVal === null)\n            throw new StoryException(\"Expected list for LIST_RANDOM\");\n\n          let list = listVal.value;\n\n          let newList: InkList | null = null;\n\n          if (list === null) {\n            throw throwNullException(\"list\");\n          }\n          if (list.Count == 0) {\n            newList = new InkList();\n          } else {\n            // Generate a random index for the element to take\n            let resultSeed = this.state.storySeed + this.state.previousRandom;\n            let random = new PRNG(resultSeed);\n\n            let nextRandom = random.next();\n            let listItemIndex = nextRandom % list.Count;\n\n            // This bit is a little different from the original\n            // C# code, since iterators do not work in the same way.\n            // First, we iterate listItemIndex - 1 times, calling next().\n            // The listItemIndex-th time is made outside of the loop,\n            // in order to retrieve the value.\n            let listEnumerator = list.entries();\n            for (let i = 0; i <= listItemIndex - 1; i++) {\n              listEnumerator.next();\n            }\n            let value = listEnumerator.next().value;\n            let randomItem: KeyValuePair<InkListItem, number> = {\n              Key: InkListItem.fromSerializedKey(value[0]),\n              Value: value[1],\n            };\n\n            // Origin list is simply the origin of the one element\n            if (randomItem.Key.originName === null) {\n              return throwNullException(\"randomItem.Key.originName\");\n            }\n            newList = new InkList(randomItem.Key.originName, this);\n            newList.Add(randomItem.Key, randomItem.Value);\n\n            this.state.previousRandom = nextRandom;\n          }\n\n          this.state.PushEvaluationStack(new ListValue(newList));\n          break;\n        }\n\n        default:\n          this.Error(\"unhandled ControlCommand: \" + evalCommand);\n          break;\n      }\n\n      return true;\n    }\n\n    // Variable assignment\n    else if (contentObj instanceof VariableAssignment) {\n      let varAss = contentObj;\n      let assignedVal = this.state.PopEvaluationStack();\n\n      this.state.variablesState.Assign(varAss, assignedVal);\n\n      return true;\n    }\n\n    // Variable reference\n    else if (contentObj instanceof VariableReference) {\n      let varRef = contentObj;\n      let foundValue = null;\n\n      // Explicit read count value\n      if (varRef.pathForCount != null) {\n        let container = varRef.containerForCount;\n        let count = this.state.VisitCountForContainer(container);\n        foundValue = new IntValue(count);\n      }\n\n      // Normal variable reference\n      else {\n        foundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n\n        if (foundValue == null) {\n          this.Warning(\n            \"Variable not found: '\" +\n              varRef.name +\n              \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\"\n          );\n          foundValue = new IntValue(0);\n        }\n      }\n\n      this.state.PushEvaluationStack(foundValue);\n\n      return true;\n    }\n\n    // Native function call\n    else if (contentObj instanceof NativeFunctionCall) {\n      let func = contentObj;\n      let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n      let result = func.Call(funcParams);\n      this.state.PushEvaluationStack(result);\n      return true;\n    }\n\n    // No control content, must be ordinary content\n    return false;\n  }\n\n  public ChoosePathString(\n    path: string,\n    resetCallstack = true,\n    args: any[] = []\n  ) {\n    this.IfAsyncWeCant(\"call ChoosePathString right now\");\n    if (this.onChoosePathString !== null) this.onChoosePathString(path, args);\n\n    if (resetCallstack) {\n      this.ResetCallstack();\n    } else {\n      if (this.state.callStack.currentElement.type == PushPopType.Function) {\n        let funcDetail = \"\";\n        let container =\n          this.state.callStack.currentElement.currentPointer.container;\n        if (container != null) {\n          funcDetail = \"(\" + container.path.toString() + \") \";\n        }\n        throw new Error(\n          \"Story was running a function \" +\n            funcDetail +\n            \"when you called ChoosePathString(\" +\n            path +\n            \") - this is almost certainly not not what you want! Full stack trace: \\n\" +\n            this.state.callStack.callStackTrace\n        );\n      }\n    }\n\n    this.state.PassArgumentsToEvaluationStack(args);\n    this.ChoosePath(new Path(path));\n  }\n\n  public IfAsyncWeCant(activityStr: string) {\n    if (this._asyncContinueActive)\n      throw new Error(\n        \"Can't \" +\n          activityStr +\n          \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\"\n      );\n  }\n\n  public ChoosePath(p: Path, incrementingTurnIndex: boolean = true) {\n    this.state.SetChosenPath(p, incrementingTurnIndex);\n\n    // Take a note of newly visited containers for read counts etc\n    this.VisitChangedContainersDueToDivert();\n  }\n\n  public ChooseChoiceIndex(choiceIdx: number) {\n    choiceIdx = choiceIdx;\n    let choices = this.currentChoices;\n    this.Assert(\n      choiceIdx >= 0 && choiceIdx < choices.length,\n      \"choice out of range\"\n    );\n\n    let choiceToChoose = choices[choiceIdx];\n    if (this.onMakeChoice !== null) this.onMakeChoice(choiceToChoose);\n\n    if (choiceToChoose.threadAtGeneration === null) {\n      return throwNullException(\"choiceToChoose.threadAtGeneration\");\n    }\n    if (choiceToChoose.targetPath === null) {\n      return throwNullException(\"choiceToChoose.targetPath\");\n    }\n\n    this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n\n    this.ChoosePath(choiceToChoose.targetPath);\n  }\n\n  public HasFunction(functionName: string) {\n    try {\n      return this.KnotContainerWithName(functionName) != null;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public EvaluateFunction(\n    functionName: string,\n    args: any[] = [],\n    returnTextOutput: boolean = false\n  ): Story.EvaluateFunctionTextOutput | any {\n    // EvaluateFunction behaves slightly differently than the C# version.\n    // In C#, you can pass a (second) parameter `out textOutput` to get the\n    // text outputted by the function. This is not possible in js. Instead,\n    // we maintain the regular signature (functionName, args), plus an\n    // optional third parameter returnTextOutput. If set to true, we will\n    // return both the textOutput and the returned value, as an object.\n\n    if (this.onEvaluateFunction !== null)\n      this.onEvaluateFunction(functionName, args);\n\n    this.IfAsyncWeCant(\"evaluate a function\");\n\n    if (functionName == null) {\n      throw new Error(\"Function is null\");\n    } else if (functionName == \"\" || functionName.trim() == \"\") {\n      throw new Error(\"Function is empty or white space.\");\n    }\n\n    let funcContainer = this.KnotContainerWithName(functionName);\n    if (funcContainer == null) {\n      throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n    }\n\n    let outputStreamBefore: InkObject[] = [];\n    outputStreamBefore.push(...this.state.outputStream);\n    this._state.ResetOutput();\n\n    this.state.StartFunctionEvaluationFromGame(funcContainer, args);\n\n    // Evaluate the function, and collect the string output\n    let stringOutput = new StringBuilder();\n    while (this.canContinue) {\n      stringOutput.Append(this.Continue());\n    }\n    let textOutput = stringOutput.toString();\n\n    this._state.ResetOutput(outputStreamBefore);\n\n    let result = this.state.CompleteFunctionEvaluationFromGame();\n    if (this.onCompleteEvaluateFunction != null)\n      this.onCompleteEvaluateFunction(functionName, args, textOutput, result);\n\n    return returnTextOutput ? { returned: result, output: textOutput } : result;\n  }\n\n  public EvaluateExpression(exprContainer: Container) {\n    let startCallStackHeight = this.state.callStack.elements.length;\n\n    this.state.callStack.Push(PushPopType.Tunnel);\n\n    this._temporaryEvaluationContainer = exprContainer;\n\n    this.state.GoToStart();\n\n    let evalStackHeight = this.state.evaluationStack.length;\n\n    this.Continue();\n\n    this._temporaryEvaluationContainer = null;\n\n    // Should have fallen off the end of the Container, which should\n    // have auto-popped, but just in case we didn't for some reason,\n    // manually pop to restore the state (including currentPath).\n    if (this.state.callStack.elements.length > startCallStackHeight) {\n      this.state.PopCallStack();\n    }\n\n    let endStackHeight = this.state.evaluationStack.length;\n    if (endStackHeight > evalStackHeight) {\n      return this.state.PopEvaluationStack();\n    } else {\n      return null;\n    }\n  }\n\n  public allowExternalFunctionFallbacks: boolean = false;\n\n  public CallExternalFunction(\n    funcName: string | null,\n    numberOfArguments: number\n  ) {\n    if (funcName === null) {\n      return throwNullException(\"funcName\");\n    }\n    let funcDef = this._externals.get(funcName);\n    let fallbackFunctionContainer = null;\n\n    let foundExternal = typeof funcDef !== \"undefined\";\n\n    if (\n      foundExternal &&\n      !funcDef!.lookAheadSafe &&\n      this._stateSnapshotAtLastNewline !== null\n    ) {\n      this._sawLookaheadUnsafeFunctionAfterNewline = true;\n      return;\n    }\n\n    if (!foundExternal) {\n      if (this.allowExternalFunctionFallbacks) {\n        fallbackFunctionContainer = this.KnotContainerWithName(funcName);\n        this.Assert(\n          fallbackFunctionContainer !== null,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound, and fallback ink function could not be found.\"\n        );\n\n        // Divert direct into fallback function and we're done\n        this.state.callStack.Push(\n          PushPopType.Function,\n          undefined,\n          this.state.outputStream.length\n        );\n        this.state.divertedPointer = Pointer.StartOf(fallbackFunctionContainer);\n        return;\n      } else {\n        this.Assert(\n          false,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound (and ink fallbacks disabled).\"\n        );\n      }\n    }\n\n    // Pop arguments\n    let args: any[] = [];\n    for (let i = 0; i < numberOfArguments; ++i) {\n      // var poppedObj = state.PopEvaluationStack () as Value;\n      let poppedObj = asOrThrows(this.state.PopEvaluationStack(), Value);\n      let valueObj = poppedObj.valueObject;\n      args.push(valueObj);\n    }\n\n    // Reverse arguments from the order they were popped,\n    // so they're the right way round again.\n    args.reverse();\n\n    // Run the function!\n    let funcResult = funcDef!.function(args);\n\n    // Convert return value (if any) to the a type that the ink engine can use\n    let returnObj = null;\n    if (funcResult != null) {\n      returnObj = Value.Create(funcResult);\n      this.Assert(\n        returnObj !== null,\n        \"Could not create ink value from returned object of type \" +\n          typeof funcResult\n      );\n    } else {\n      returnObj = new Void();\n    }\n\n    this.state.PushEvaluationStack(returnObj);\n  }\n\n  public BindExternalFunctionGeneral(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = true\n  ) {\n    this.IfAsyncWeCant(\"bind an external function\");\n    this.Assert(\n      !this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has already been bound.\"\n    );\n    this._externals.set(funcName, {\n      function: func,\n      lookAheadSafe: lookaheadSafe,\n    });\n  }\n\n  public TryCoerce(value: any) {\n    // We're skipping type coercition in this implementation. First of, js\n    // is loosely typed, so it's not that important. Secondly, there is no\n    // clean way (AFAIK) for the user to describe what type of parameters\n    // they expect.\n    return value;\n  }\n\n  public BindExternalFunction(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = false\n  ) {\n    this.Assert(func != null, \"Can't bind a null function\");\n\n    this.BindExternalFunctionGeneral(\n      funcName,\n      (args: any) => {\n        this.Assert(\n          args.length >= func.length,\n          \"External function expected \" + func.length + \" arguments\"\n        );\n\n        let coercedArgs = [];\n        for (let i = 0, l = args.length; i < l; i++) {\n          coercedArgs[i] = this.TryCoerce(args[i]);\n        }\n        return func.apply(null, coercedArgs);\n      },\n      lookaheadSafe\n    );\n  }\n\n  public UnbindExternalFunction(funcName: string) {\n    this.IfAsyncWeCant(\"unbind an external a function\");\n    this.Assert(\n      this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has not been bound.\"\n    );\n    this._externals.delete(funcName);\n  }\n\n  public ValidateExternalBindings(): void;\n  public ValidateExternalBindings(\n    c: Container | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings(\n    o: InkObject | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings() {\n    let c: Container | null = null;\n    let o: InkObject | null = null;\n    let missingExternals: Set<string> = arguments[1] || new Set();\n\n    if (arguments[0] instanceof Container) {\n      c = arguments[0];\n    }\n\n    if (arguments[0] instanceof InkObject) {\n      o = arguments[0];\n    }\n\n    if (c === null && o === null) {\n      this.ValidateExternalBindings(\n        this._mainContentContainer,\n        missingExternals\n      );\n      this._hasValidatedExternals = true;\n\n      // No problem! Validation complete\n      if (missingExternals.size == 0) {\n        this._hasValidatedExternals = true;\n      } else {\n        let message = \"Error: Missing function binding for external\";\n        message += missingExternals.size > 1 ? \"s\" : \"\";\n        message += \": '\";\n        message += Array.from(missingExternals).join(\"', '\");\n        message += \"' \";\n        message += this.allowExternalFunctionFallbacks\n          ? \", and no fallback ink function found.\"\n          : \" (ink fallbacks disabled)\";\n\n        this.Error(message);\n      }\n    } else if (c != null) {\n      for (let innerContent of c.content) {\n        let container = innerContent as Container;\n        if (container == null || !container.hasValidName)\n          this.ValidateExternalBindings(innerContent, missingExternals);\n      }\n      for (let [, value] of c.namedContent) {\n        this.ValidateExternalBindings(\n          asOrNull(value, InkObject),\n          missingExternals\n        );\n      }\n    } else if (o != null) {\n      let divert = asOrNull(o, Divert);\n      if (divert && divert.isExternal) {\n        let name = divert.targetPathString;\n        if (name === null) {\n          return throwNullException(\"name\");\n        }\n        if (!this._externals.has(name)) {\n          if (this.allowExternalFunctionFallbacks) {\n            let fallbackFound =\n              this.mainContentContainer.namedContent.has(name);\n            if (!fallbackFound) {\n              missingExternals.add(name);\n            }\n          } else {\n            missingExternals.add(name);\n          }\n        }\n      }\n    }\n  }\n\n  public ObserveVariable(\n    variableName: string,\n    observer: Story.VariableObserver\n  ) {\n    this.IfAsyncWeCant(\"observe a new variable\");\n\n    if (this._variableObservers === null) this._variableObservers = new Map();\n\n    if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))\n      throw new Error(\n        \"Cannot observe variable '\" +\n          variableName +\n          \"' because it wasn't declared in the ink story.\"\n      );\n\n    if (this._variableObservers.has(variableName)) {\n      this._variableObservers.get(variableName)!.push(observer);\n    } else {\n      this._variableObservers.set(variableName, [observer]);\n    }\n  }\n\n  public ObserveVariables(\n    variableNames: string[],\n    observers: Story.VariableObserver[]\n  ) {\n    for (let i = 0, l = variableNames.length; i < l; i++) {\n      this.ObserveVariable(variableNames[i], observers[i]);\n    }\n  }\n\n  public RemoveVariableObserver(\n    observer?: Story.VariableObserver,\n    specificVariableName?: string\n  ) {\n    // A couple of things to know about this method:\n    //\n    // 1. Since `RemoveVariableObserver` is exposed to the JavaScript world,\n    //    optionality is marked as `undefined` rather than `null`.\n    //    To keep things simple, null-checks are performed using regular\n    //    equality operators, where undefined == null.\n    //\n    // 2. Since C# delegates are translated to arrays of functions,\n    //    -= becomes a call to splice and null-checks are replaced by\n    //    emptiness-checks.\n    //\n    this.IfAsyncWeCant(\"remove a variable observer\");\n\n    if (this._variableObservers === null) return;\n\n    if (specificVariableName != null) {\n      if (this._variableObservers.has(specificVariableName)) {\n        if (observer != null) {\n          let variableObservers =\n            this._variableObservers.get(specificVariableName);\n          if (variableObservers != null) {\n            variableObservers.splice(variableObservers.indexOf(observer), 1);\n            if (variableObservers.length === 0) {\n              this._variableObservers.delete(specificVariableName);\n            }\n          }\n        } else {\n          this._variableObservers.delete(specificVariableName);\n        }\n      }\n    } else if (observer != null) {\n      let keys = this._variableObservers.keys();\n      for (let varName of keys) {\n        let variableObservers = this._variableObservers.get(varName);\n        if (variableObservers != null) {\n          variableObservers.splice(variableObservers.indexOf(observer), 1);\n          if (variableObservers.length === 0) {\n            this._variableObservers.delete(varName);\n          }\n        }\n      }\n    }\n  }\n\n  public VariableStateDidChangeEvent(\n    variableName: string,\n    newValueObj: InkObject\n  ) {\n    if (this._variableObservers === null) return;\n\n    let observers = this._variableObservers.get(variableName);\n    if (typeof observers !== \"undefined\") {\n      if (!(newValueObj instanceof Value)) {\n        throw new Error(\n          \"Tried to get the value of a variable that isn't a standard type\"\n        );\n      }\n      // var val = newValueObj as Value;\n      let val = asOrThrows(newValueObj, Value);\n\n      for (let observer of observers) {\n        observer(variableName, val.valueObject);\n      }\n    }\n  }\n\n  get globalTags() {\n    return this.TagsAtStartOfFlowContainerWithPathString(\"\");\n  }\n\n  public TagsForContentAtPath(path: string) {\n    return this.TagsAtStartOfFlowContainerWithPathString(path);\n  }\n\n  public TagsAtStartOfFlowContainerWithPathString(pathString: string) {\n    let path = new Path(pathString);\n\n    let flowContainer = this.ContentAtPath(path).container;\n    if (flowContainer === null) {\n      return throwNullException(\"flowContainer\");\n    }\n    while (true) {\n      let firstContent: InkObject = flowContainer.content[0];\n      if (firstContent instanceof Container) flowContainer = firstContent;\n      else break;\n    }\n\n    let inTag = false;\n    let tags: string[] | null = null;\n\n    for (let c of flowContainer.content) {\n      // var tag = c as Runtime.Tag;\n      let command = asOrNull(c, ControlCommand);\n\n      if (command != null) {\n        if (command.commandType == ControlCommand.CommandType.BeginTag) {\n          inTag = true;\n        } else if (command.commandType == ControlCommand.CommandType.EndTag) {\n          inTag = false;\n        }\n      } else if (inTag) {\n        let str = asOrNull(c, StringValue);\n        if (str !== null) {\n          if (tags === null) tags = [];\n          if (str.value !== null) tags.push(str.value);\n        } else {\n          this.Error(\n            \"Tag contained non-text content. Only plain text is allowed when using globalTags or TagsAtContentPath. If you want to evaluate dynamic content, you need to use story.Continue().\"\n          );\n        }\n      } else {\n        break;\n      }\n    }\n\n    return tags;\n  }\n\n  public BuildStringOfHierarchy() {\n    let sb = new StringBuilder();\n\n    this.mainContentContainer.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n\n    return sb.toString();\n  }\n\n  public BuildStringOfContainer(container: Container) {\n    let sb = new StringBuilder();\n    container.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n    return sb.toString();\n  }\n\n  public NextContent() {\n    this.state.previousPointer = this.state.currentPointer.copy();\n\n    if (!this.state.divertedPointer.isNull) {\n      this.state.currentPointer = this.state.divertedPointer.copy();\n      this.state.divertedPointer = Pointer.Null;\n\n      this.VisitChangedContainersDueToDivert();\n\n      if (!this.state.currentPointer.isNull) {\n        return;\n      }\n    }\n\n    let successfulPointerIncrement = this.IncrementContentPointer();\n\n    if (!successfulPointerIncrement) {\n      let didPop = false;\n\n      if (this.state.callStack.CanPop(PushPopType.Function)) {\n        this.state.PopCallStack(PushPopType.Function);\n\n        if (this.state.inExpressionEvaluation) {\n          this.state.PushEvaluationStack(new Void());\n        }\n\n        didPop = true;\n      } else if (this.state.callStack.canPopThread) {\n        this.state.callStack.PopThread();\n\n        didPop = true;\n      } else {\n        this.state.TryExitFunctionEvaluationFromGame();\n      }\n\n      if (didPop && !this.state.currentPointer.isNull) {\n        this.NextContent();\n      }\n    }\n  }\n\n  public IncrementContentPointer() {\n    let successfulIncrement = true;\n\n    let pointer = this.state.callStack.currentElement.currentPointer.copy();\n    pointer.index++;\n\n    if (pointer.container === null) {\n      return throwNullException(\"pointer.container\");\n    }\n    while (pointer.index >= pointer.container.content.length) {\n      successfulIncrement = false;\n\n      // Container nextAncestor = pointer.container.parent as Container;\n      let nextAncestor = asOrNull(pointer.container.parent, Container);\n      if (nextAncestor instanceof Container === false) {\n        break;\n      }\n\n      let indexInAncestor = nextAncestor!.content.indexOf(pointer.container);\n      if (indexInAncestor == -1) {\n        break;\n      }\n\n      pointer = new Pointer(nextAncestor, indexInAncestor);\n\n      pointer.index++;\n\n      successfulIncrement = true;\n      if (pointer.container === null) {\n        return throwNullException(\"pointer.container\");\n      }\n    }\n\n    if (!successfulIncrement) pointer = Pointer.Null;\n\n    this.state.callStack.currentElement.currentPointer = pointer.copy();\n\n    return successfulIncrement;\n  }\n\n  public TryFollowDefaultInvisibleChoice() {\n    let allChoices = this._state.currentChoices;\n\n    let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);\n\n    if (\n      invisibleChoices.length == 0 ||\n      allChoices.length > invisibleChoices.length\n    )\n      return false;\n\n    let choice = invisibleChoices[0];\n\n    if (choice.targetPath === null) {\n      return throwNullException(\"choice.targetPath\");\n    }\n\n    if (choice.threadAtGeneration === null) {\n      return throwNullException(\"choice.threadAtGeneration\");\n    }\n\n    this.state.callStack.currentThread = choice.threadAtGeneration;\n\n    if (this._stateSnapshotAtLastNewline !== null) {\n      this.state.callStack.currentThread = this.state.callStack.ForkThread();\n    }\n\n    this.ChoosePath(choice.targetPath, false);\n\n    return true;\n  }\n\n  public NextSequenceShuffleIndex() {\n    // var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n    let numElementsIntVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n    if (!(numElementsIntVal instanceof IntValue)) {\n      this.Error(\"expected number of elements in sequence for shuffle index\");\n      return 0;\n    }\n\n    let seqContainer = this.state.currentPointer.container;\n    if (seqContainer === null) {\n      return throwNullException(\"seqContainer\");\n    }\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (numElementsIntVal.value === null) {\n      return throwNullException(\"numElementsIntVal.value\");\n    }\n    let numElements = numElementsIntVal.value;\n\n    // var seqCountVal = state.PopEvaluationStack () as IntValue;\n    let seqCountVal = asOrThrows(this.state.PopEvaluationStack(), IntValue);\n    let seqCount = seqCountVal.value;\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (seqCount === null) {\n      return throwNullException(\"seqCount\");\n    }\n\n    let loopIndex = seqCount / numElements;\n    let iterationIndex = seqCount % numElements;\n\n    let seqPathStr = seqContainer.path.toString();\n    let sequenceHash = 0;\n    for (let i = 0, l = seqPathStr.length; i < l; i++) {\n      sequenceHash += seqPathStr.charCodeAt(i) || 0;\n    }\n    let randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n    let random = new PRNG(Math.floor(randomSeed));\n\n    let unpickedIndices = [];\n    for (let i = 0; i < numElements; ++i) {\n      unpickedIndices.push(i);\n    }\n\n    for (let i = 0; i <= iterationIndex; ++i) {\n      let chosen = random.next() % unpickedIndices.length;\n      let chosenIndex = unpickedIndices[chosen];\n      unpickedIndices.splice(chosen, 1);\n\n      if (i == iterationIndex) {\n        return chosenIndex;\n      }\n    }\n\n    throw new Error(\"Should never reach here\");\n  }\n\n  public Error(message: string, useEndLineNumber = false): never {\n    let e = new StoryException(message);\n    e.useEndLineNumber = useEndLineNumber;\n    throw e;\n  }\n\n  public Warning(message: string) {\n    this.AddError(message, true);\n  }\n\n  public AddError(\n    message: string,\n    isWarning = false,\n    useEndLineNumber = false\n  ) {\n    let dm = this.currentDebugMetadata;\n\n    let errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";\n\n    if (dm != null) {\n      let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": '\" +\n        dm.fileName +\n        \"' line \" +\n        lineNum +\n        \": \" +\n        message;\n    } else if (!this.state.currentPointer.isNull) {\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": (\" +\n        this.state.currentPointer +\n        \"): \" +\n        message;\n    } else {\n      message = \"RUNTIME \" + errorTypeStr + \": \" + message;\n    }\n\n    this.state.AddError(message, isWarning);\n\n    // In a broken state don't need to know about any other errors.\n    if (!isWarning) this.state.ForceEnd();\n  }\n\n  public Assert(condition: boolean, message: string | null = null) {\n    if (condition == false) {\n      if (message == null) {\n        message = \"Story assert\";\n      }\n\n      throw new Error(message + \" \" + this.currentDebugMetadata);\n    }\n  }\n\n  get currentDebugMetadata(): DebugMetadata | null {\n    let dm: DebugMetadata | null;\n\n    let pointer = this.state.currentPointer;\n    if (!pointer.isNull && pointer.Resolve() !== null) {\n      dm = pointer.Resolve()!.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n      pointer = this.state.callStack.elements[i].currentPointer;\n      if (!pointer.isNull && pointer.Resolve() !== null) {\n        dm = pointer.Resolve()!.debugMetadata;\n        if (dm !== null) {\n          return dm;\n        }\n      }\n    }\n\n    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n      let outputObj = this.state.outputStream[i];\n      dm = outputObj.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    return null;\n  }\n\n  get mainContentContainer() {\n    if (this._temporaryEvaluationContainer) {\n      return this._temporaryEvaluationContainer;\n    } else {\n      return this._mainContentContainer;\n    }\n  }\n\n  /**\n   * `_mainContentContainer` is almost guaranteed to be set in the\n   * constructor, unless the json is malformed.\n   */\n  private _mainContentContainer!: Container;\n  private _listDefinitions: ListDefinitionsOrigin | null = null;\n\n  private _externals: Map<string, Story.ExternalFunctionDef>;\n  private _variableObservers: Map<string, Story.VariableObserver[]> | null =\n    null;\n  private _hasValidatedExternals: boolean = false;\n\n  private _temporaryEvaluationContainer: Container | null = null;\n\n  /**\n   * `state` is almost guaranteed to be set in the constructor, unless\n   * using the compiler-specific constructor which will likely not be used in\n   * the real world.\n   */\n  private _state!: StoryState;\n\n  private _asyncContinueActive: boolean = false;\n  private _stateSnapshotAtLastNewline: StoryState | null = null;\n  private _sawLookaheadUnsafeFunctionAfterNewline: boolean = false;\n\n  private _recursiveContinueCount: number = 0;\n\n  private _asyncSaving: boolean = false;\n\n  private _profiler: any | null = null; // TODO: Profiler\n}\n\nexport namespace Story {\n  export enum OutputStateChange {\n    NoChange = 0,\n    ExtendedBeyondNewline = 1,\n    NewlineRemoved = 2,\n  }\n\n  export interface EvaluateFunctionTextOutput {\n    returned: any;\n    output: string;\n  }\n\n  export interface ExternalFunctionDef {\n    function: ExternalFunction;\n    lookAheadSafe: boolean;\n  }\n\n  export type VariableObserver = (variableName: string, newValue: any) => void;\n  export type ExternalFunction = (...args: any) => any;\n}\n","import { AuthorWarning } from \"./AuthorWarning\";\nimport { ConstantDeclaration } from \"./Declaration/ConstantDeclaration\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { ErrorHandler } from \"../../../engine/Error\";\nimport { ErrorType } from \"../ErrorType\";\nimport { Expression } from \"./Expression/Expression\";\nimport { ExternalDeclaration } from \"./Declaration/ExternalDeclaration\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { IncludedFile } from \"./IncludedFile\";\nimport { ListDefinition } from \"./List/ListDefinition\";\nimport { ListElementDefinition } from \"./List/ListElementDefinition\";\nimport { ParsedObject } from \"./Object\";\nimport { Story as RuntimeStory } from \"../../../engine/Story\";\nimport { SymbolType } from \"./SymbolType\";\nimport { Text } from \"./Text\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../engine/VariableAssignment\";\nimport { Identifier } from \"./Identifier\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\nimport { ClosestFlowBase } from \"./Flow/ClosestFlowBase\";\nimport { FunctionCall } from \"./FunctionCall\";\nimport { Path } from \"./Path\";\nimport { VariableAssignment } from \"./Variable/VariableAssignment\";\n\nexport class Story extends FlowBase {\n  public static readonly IsReservedKeyword = (name?: string): boolean => {\n    switch (name) {\n      case \"true\":\n      case \"false\":\n      case \"not\":\n      case \"return\":\n      case \"else\":\n      case \"VAR\":\n      case \"CONST\":\n      case \"temp\":\n      case \"LIST\":\n      case \"function\":\n        return true;\n    }\n\n    return false;\n  };\n\n  private _errorHandler: ErrorHandler | null = null;\n  private _hadError: boolean = false;\n  private _hadWarning: boolean = false;\n  private _dontFlattenContainers: Set<RuntimeContainer> = new Set();\n  private _listDefs: Map<string, ListDefinition> = new Map();\n\n  get flowLevel(): FlowLevel {\n    return FlowLevel.Story;\n  }\n\n  get hadError(): boolean {\n    return this._hadError;\n  }\n\n  get hadWarning(): boolean {\n    return this._hadWarning;\n  }\n\n  public constants: Map<string, Expression> = new Map();\n  public externals: Map<string, ExternalDeclaration> = new Map();\n\n  // Build setting for exporting:\n  // When true, the visit count for *all* knots, stitches, choices,\n  // and gathers is counted. When false, only those that are direclty\n  // referenced by the ink are recorded. Use this flag to allow game-side\n  // querying of  arbitrary knots/stitches etc.\n  // Storing all counts is more robust and future proof (updates to the story file\n  // that reference previously uncounted visits are possible, but generates a much\n  // larger safe file, with a lot of potentially redundant counts.\n  public countAllVisits: boolean = false;\n\n  constructor(toplevelObjects: ParsedObject[], isInclude: boolean = false) {\n    // Don't do anything much on construction, leave it lightweight until\n    // the ExportRuntime method is called.\n    super(null, toplevelObjects, null, false, isInclude);\n  }\n\n  get typeName(): string {\n    return \"Story\";\n  }\n\n  // Before this function is called, we have IncludedFile objects interspersed\n  // in our content wherever an include statement was.\n  // So that the include statement can be added in a sensible place (e.g. the\n  // top of the file) without side-effects of jumping into a knot that was\n  // defined in that include, we separate knots and stitches from anything\n  // else defined at the top scope of the included file.\n  //\n  // Algorithm: For each IncludedFile we find, split its contents into\n  // knots/stiches and any other content. Insert the normal content wherever\n  // the include statement was, and append the knots/stitches to the very\n  // end of the main story.\n  public PreProcessTopLevelObjects(topLevelContent: ParsedObject[]): void {\n    super.PreProcessTopLevelObjects(topLevelContent);\n\n    const flowsFromOtherFiles = [];\n\n    // Inject included files\n    for (let obj of topLevelContent) {\n      if (obj instanceof IncludedFile) {\n        const file: IncludedFile = obj;\n\n        // Remove the IncludedFile itself\n        const posOfObj = topLevelContent.indexOf(obj);\n        topLevelContent.splice(posOfObj, 1);\n\n        // When an included story fails to load, the include\n        // line itself is still valid, so we have to handle it here\n        if (file.includedStory) {\n          const nonFlowContent: ParsedObject[] = [];\n          const subStory = file.includedStory;\n          // Allow empty file\n          if (subStory.content != null) {\n            for (const subStoryObj of subStory.content) {\n              if (subStoryObj instanceof FlowBase) {\n                flowsFromOtherFiles.push(subStoryObj);\n              } else {\n                nonFlowContent.push(subStoryObj);\n              }\n            }\n\n            // Add newline on the end of the include\n            nonFlowContent.push(new Text(\"\\n\"));\n\n            // Add contents of the file in its place\n            topLevelContent.splice(posOfObj, 0, ...nonFlowContent);\n\n            // Skip past the content of this sub story\n            // (since it will already have recursively included\n            //  any lines from other files)\n          }\n        }\n\n        // Include object has been removed, with possible content inserted,\n        // and position of 'i' will have been determined already.\n        continue;\n      }\n    }\n\n    // Add the flows we collected from the included files to the\n    // end of our list of our content\n    topLevelContent.splice(0, 0, ...flowsFromOtherFiles);\n  }\n\n  public readonly ExportRuntime = (\n    errorHandler: ErrorHandler | null = null\n  ): RuntimeStory | null => {\n    this._errorHandler = errorHandler;\n\n    // Find all constants before main export begins, so that VariableReferences know\n    // whether to generate a runtime variable reference or the literal value\n    this.constants = new Map();\n    for (const constDecl of this.FindAll(ConstantDeclaration)()) {\n      // Check for duplicate definitions\n      const existingDefinition: Expression = this.constants.get(\n        constDecl.constantName!\n      ) as any;\n\n      if (existingDefinition) {\n        if (!existingDefinition.Equals(constDecl.expression)) {\n          const errorMsg = `CONST '${constDecl.constantName}' has been redefined with a different value. Multiple definitions of the same CONST are valid so long as they contain the same value. Initial definition was on ${existingDefinition.debugMetadata}.`;\n          this.Error(errorMsg, constDecl, false);\n        }\n      }\n\n      this.constants.set(constDecl.constantName!, constDecl.expression);\n    }\n\n    // List definitions are treated like constants too - they should be usable\n    // from other variable declarations.\n    this._listDefs = new Map();\n    for (const listDef of this.FindAll<ListDefinition>(ListDefinition)()) {\n      if (listDef.identifier?.name) {\n        this._listDefs.set(listDef.identifier?.name, listDef);\n      }\n    }\n\n    this.externals = new Map();\n\n    // Resolution of weave point names has to come first, before any runtime code generation\n    // since names have to be ready before diverts start getting created.\n    // (It used to be done in the constructor for a weave, but didn't allow us to generate\n    // errors when name resolution failed.)\n    this.ResolveWeavePointNaming();\n\n    // Get default implementation of runtimeObject, which calls ContainerBase's generation method\n    const rootContainer = this.runtimeObject as RuntimeContainer;\n\n    // Export initialisation of global variables\n    // TODO: We *could* add this as a declarative block to the story itself...\n    const variableInitialisation = new RuntimeContainer();\n    variableInitialisation.AddContent(RuntimeControlCommand.EvalStart());\n\n    // Global variables are those that are local to the story and marked as global\n    const runtimeLists = [];\n    for (const [key, value] of this.variableDeclarations) {\n      if (value.isGlobalDeclaration) {\n        if (value.listDefinition) {\n          this._listDefs.set(key, value.listDefinition);\n          variableInitialisation.AddContent(\n            value.listDefinition.runtimeObject!\n          );\n\n          runtimeLists.push(value.listDefinition.runtimeListDefinition);\n        } else {\n          if (!value.expression) {\n            throw new Error();\n          }\n          value.expression.GenerateIntoContainer(variableInitialisation);\n        }\n\n        const runtimeVarAss = new RuntimeVariableAssignment(key, true);\n        runtimeVarAss.isGlobal = true;\n        variableInitialisation.AddContent(runtimeVarAss);\n      }\n    }\n\n    variableInitialisation.AddContent(RuntimeControlCommand.EvalEnd());\n    variableInitialisation.AddContent(RuntimeControlCommand.End());\n\n    if (this.variableDeclarations.size > 0) {\n      variableInitialisation.name = \"global decl\";\n      rootContainer.AddToNamedContentOnly(variableInitialisation);\n    }\n\n    // Signal that it's safe to exit without error, even if there are no choices generated\n    // (this only happens at the end of top level content that isn't in any particular knot)\n    rootContainer.AddContent(RuntimeControlCommand.Done());\n\n    // Replace runtimeObject with Story object instead of the Runtime.Container generated by Parsed.ContainerBase\n    const runtimeStory = new RuntimeStory(rootContainer, runtimeLists);\n\n    this.runtimeObject = runtimeStory;\n\n    if (this.hadError) {\n      return null;\n    }\n\n    // Optimisation step - inline containers that can be\n    this.FlattenContainersIn(rootContainer);\n\n    // Now that the story has been fulled parsed into a hierarchy,\n    // and the derived runtime hierarchy has been built, we can\n    // resolve referenced symbols such as variables and paths.\n    // e.g. for paths \" -> knotName --> stitchName\" into an INKPath (knotName.stitchName)\n    // We don't make any assumptions that the INKPath follows the same\n    // conventions as the script format, so we resolve to actual objects before\n    // translating into an INKPath. (This also allows us to choose whether\n    // we want the paths to be absolute)\n    this.ResolveReferences(this);\n\n    if (this.hadError) {\n      return null;\n    }\n\n    runtimeStory.ResetState();\n\n    return runtimeStory;\n  };\n\n  public readonly ResolveList = (listName: string): ListDefinition | null => {\n    let list: ListDefinition | null | undefined = this._listDefs.get(listName);\n    if (!list) {\n      return null;\n    }\n\n    return list;\n  };\n\n  public readonly ResolveListItem = (\n    listName: string | null,\n    itemName: string,\n    source: ParsedObject | null = null\n  ): ListElementDefinition | null => {\n    let listDef: ListDefinition | null | undefined = null;\n\n    // Search a specific list if we know its name (i.e. the form listName.itemName)\n    if (listName) {\n      if (!(listDef = this._listDefs.get(listName))) {\n        return null;\n      }\n\n      return listDef.ItemNamed(itemName);\n    } else {\n      // Otherwise, try to search all lists\n\n      let foundItem: ListElementDefinition | null = null;\n      let originalFoundList: ListDefinition | null = null;\n\n      for (const [, value] of this._listDefs.entries()) {\n        const itemInThisList = value.ItemNamed(itemName);\n        if (itemInThisList) {\n          if (foundItem) {\n            this.Error(\n              `Ambiguous item name '${itemName}' found in multiple sets, including ${\n                originalFoundList!.identifier\n              } and ${value!.identifier}`,\n              source,\n              false\n            );\n          } else {\n            foundItem = itemInThisList;\n            originalFoundList = value!;\n          }\n        }\n      }\n\n      return foundItem;\n    }\n  };\n\n  public readonly FlattenContainersIn = (container: RuntimeContainer): void => {\n    // Need to create a collection to hold the inner containers\n    // because otherwise we'd end up modifying during iteration\n    const innerContainers = new Set<RuntimeContainer>();\n    if (container.content) {\n      for (const c of container.content) {\n        const innerContainer = asOrNull(c, RuntimeContainer);\n        if (innerContainer) {\n          innerContainers.add(innerContainer);\n        }\n      }\n    }\n\n    // Can't flatten the named inner containers, but we can at least\n    // iterate through their children\n    if (container.namedContent) {\n      for (const [, value] of container.namedContent) {\n        const namedInnerContainer = asOrNull(value, RuntimeContainer);\n        if (namedInnerContainer) {\n          innerContainers.add(namedInnerContainer);\n        }\n      }\n    }\n\n    for (const innerContainer of innerContainers) {\n      this.TryFlattenContainer(innerContainer);\n      this.FlattenContainersIn(innerContainer);\n    }\n  };\n\n  public readonly TryFlattenContainer = (container: RuntimeContainer): void => {\n    if (\n      (container.namedContent && container.namedContent.size > 0) ||\n      container.hasValidName ||\n      this._dontFlattenContainers.has(container)\n    ) {\n      return;\n    }\n\n    // Inline all the content in container into the parent\n    const parentContainer = asOrNull(container.parent, RuntimeContainer);\n    if (parentContainer) {\n      let contentIdx = parentContainer.content.indexOf(container);\n      parentContainer.content.splice(contentIdx, 1);\n\n      const dm = container.ownDebugMetadata;\n\n      if (container.content) {\n        for (const innerContent of container.content) {\n          innerContent.parent = null;\n          if (dm !== null && innerContent.ownDebugMetadata === null) {\n            innerContent.debugMetadata = dm;\n          }\n\n          parentContainer.InsertContent(innerContent, contentIdx);\n          contentIdx += 1;\n        }\n      }\n    }\n  };\n\n  public readonly Error = (\n    message: string,\n    source: ParsedObject | null | undefined,\n    isWarning: boolean | null | undefined\n  ) => {\n    let errorType: ErrorType = isWarning ? ErrorType.Warning : ErrorType.Error;\n\n    let sb = \"\";\n    if (source instanceof AuthorWarning) {\n      sb += \"TODO: \";\n      errorType = ErrorType.Author;\n    } else if (isWarning) {\n      sb += \"WARNING: \";\n    } else {\n      sb += \"ERROR: \";\n    }\n\n    if (\n      source &&\n      source.debugMetadata !== null &&\n      source.debugMetadata.startLineNumber >= 1\n    ) {\n      if (source.debugMetadata.fileName != null) {\n        sb += `'${source.debugMetadata.fileName}' `;\n      }\n\n      sb += `line ${source.debugMetadata.startLineNumber}: `;\n    }\n\n    sb += message;\n\n    message = sb;\n\n    if (this._errorHandler !== null) {\n      this._errorHandler(message, errorType);\n    } else {\n      throw new Error(message);\n    }\n\n    this._hadError = errorType === ErrorType.Error;\n    this._hadWarning = errorType === ErrorType.Warning;\n  };\n\n  public readonly ResetError = (): void => {\n    this._hadError = false;\n    this._hadWarning = false;\n  };\n\n  public readonly IsExternal = (namedFuncTarget: string): boolean =>\n    this.externals.has(namedFuncTarget);\n\n  public readonly AddExternal = (decl: ExternalDeclaration): void => {\n    if (this.externals.has(decl.name!)) {\n      this.Error(\n        `Duplicate EXTERNAL definition of '${decl.name}'`,\n        decl,\n        false\n      );\n    } else if (decl.name) {\n      this.externals.set(decl.name, decl);\n    }\n  };\n\n  public readonly DontFlattenContainer = (\n    container: RuntimeContainer\n  ): void => {\n    this._dontFlattenContainers.add(container);\n  };\n\n  public readonly NameConflictError = (\n    obj: ParsedObject,\n    name: string,\n    existingObj: ParsedObject,\n    typeNameToPrint: string\n  ): void => {\n    obj.Error(\n      `${typeNameToPrint} '${name}': name has already been used for a ${existingObj.typeName.toLowerCase()} on ${\n        existingObj.debugMetadata\n      }`\n    );\n  };\n\n  // Check given symbol type against everything that's of a higher priority in the ordered SymbolType enum (above).\n  // When the given symbol type level is reached, we early-out / return.\n  public readonly CheckForNamingCollisions = (\n    obj: ParsedObject,\n    identifier: Identifier,\n    symbolType: SymbolType,\n    typeNameOverride: string = \"\"\n  ): void => {\n    const typeNameToPrint: string = typeNameOverride || obj.typeName;\n    if (Story.IsReservedKeyword(identifier?.name)) {\n      obj.Error(\n        `'${identifier}' cannot be used for the name of a ${typeNameToPrint.toLowerCase()} because it's a reserved keyword`\n      );\n      return;\n    } else if (FunctionCall.IsBuiltIn(identifier?.name || \"\")) {\n      obj.Error(\n        `'${identifier}' cannot be used for the name of a ${typeNameToPrint.toLowerCase()} because it's a built in function`\n      );\n\n      return;\n    }\n\n    // Top level knots\n    const maybeKnotOrFunction = this.ContentWithNameAtLevel(\n      identifier?.name || \"\",\n      FlowLevel.Knot\n    );\n\n    const knotOrFunction = asOrNull(maybeKnotOrFunction, FlowBase);\n\n    if (\n      knotOrFunction &&\n      (knotOrFunction !== obj || symbolType === SymbolType.Arg)\n    ) {\n      this.NameConflictError(\n        obj,\n        identifier?.name || \"\",\n        knotOrFunction,\n        typeNameToPrint\n      );\n      return;\n    }\n\n    if (symbolType < SymbolType.List) {\n      return;\n    }\n\n    // Lists\n    for (const [key, value] of this._listDefs) {\n      if (\n        identifier?.name === key &&\n        obj !== value &&\n        value.variableAssignment !== obj\n      ) {\n        this.NameConflictError(obj, identifier?.name, value, typeNameToPrint);\n      }\n\n      // We don't check for conflicts between individual elements in\n      // different lists because they are namespaced.\n      if (!(obj instanceof ListElementDefinition)) {\n        for (const item of value.itemDefinitions) {\n          if (identifier?.name === item.name) {\n            this.NameConflictError(\n              obj,\n              identifier?.name || \"\",\n              item,\n              typeNameToPrint\n            );\n          }\n        }\n      }\n    }\n\n    // Don't check for VAR->VAR conflicts because that's handled separately\n    // (necessary since checking looks up in a dictionary)\n    if (symbolType <= SymbolType.Var) {\n      return;\n    }\n\n    // Global variable collision\n    const varDecl: VariableAssignment | null =\n      (identifier?.name && this.variableDeclarations.get(identifier?.name)) ||\n      null;\n    if (\n      varDecl &&\n      varDecl !== obj &&\n      varDecl.isGlobalDeclaration &&\n      varDecl.listDefinition == null\n    ) {\n      this.NameConflictError(\n        obj,\n        identifier?.name || \"\",\n        varDecl,\n        typeNameToPrint\n      );\n    }\n\n    if (symbolType < SymbolType.SubFlowAndWeave) {\n      return;\n    }\n\n    // Stitches, Choices and Gathers\n    const path = new Path(identifier);\n    const targetContent = path.ResolveFromContext(obj);\n    if (targetContent && targetContent !== obj) {\n      this.NameConflictError(\n        obj,\n        identifier?.name || \"\",\n        targetContent,\n        typeNameToPrint\n      );\n      return;\n    }\n\n    if (symbolType < SymbolType.Arg) {\n      return;\n    }\n\n    // Arguments to the current flow\n    if (symbolType !== SymbolType.Arg) {\n      let flow: FlowBase | null = asOrNull(obj, FlowBase);\n      if (!flow) {\n        flow = ClosestFlowBase(obj);\n      }\n\n      if (flow && flow.hasParameters && flow.args) {\n        for (const arg of flow.args) {\n          if (arg.identifier?.name === identifier?.name) {\n            obj.Error(\n              `${typeNameToPrint} '${identifier}': name has already been used for a argument to ${flow.identifier} on ${flow.debugMetadata}`\n            );\n\n            return;\n          }\n        }\n      }\n    }\n  };\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Expression } from \"./Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { Text } from \"../Text\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class StringExpression extends Expression {\n  get isSingleString() {\n    if (this.content.length !== 1) {\n      return false;\n    }\n\n    const c = this.content[0];\n    if (!(c instanceof Text)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  constructor(content: ParsedObject[]) {\n    super();\n\n    this.AddContent(content);\n  }\n\n  get typeName(): string {\n    return \"String\";\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    container.AddContent(RuntimeControlCommand.BeginString());\n\n    for (const c of this.content) {\n      container.AddContent(c.runtimeObject);\n    }\n\n    container.AddContent(RuntimeControlCommand.EndString());\n  };\n\n  public readonly toString = (): string => {\n    let sb = \"\";\n    for (const c of this.content) {\n      sb += c;\n    }\n\n    return sb;\n  };\n\n  // Equals override necessary in order to check for CONST multiple definition equality\n  public Equals(obj: ParsedObject): boolean {\n    const otherStr = asOrNull(obj, StringExpression);\n    if (otherStr === null) {\n      return false;\n    }\n\n    // Can only compare direct equality on single strings rather than\n    // complex string expressions that contain dynamic logic\n    if (!this.isSingleString || !otherStr.isSingleString) {\n      return false;\n    }\n\n    const thisTxt = this.toString();\n    const otherTxt = otherStr.toString();\n    return thisTxt === otherTxt;\n  }\n}\n","import { ParsedObject } from \"./Object\";\nimport { ControlCommand } from \"../../../engine/ControlCommand\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\n\nexport class Tag extends ParsedObject {\n  public isStart: boolean;\n  public inChoice: boolean;\n\n  constructor(isStart: boolean, inChoice: boolean = false) {\n    super();\n    this.isStart = isStart;\n    this.inChoice = inChoice;\n  }\n  get typeName(): string {\n    return \"Tag\";\n  }\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    if (this.isStart) {\n      return ControlCommand.BeginTag();\n    } else {\n      return ControlCommand.EndTag();\n    }\n  };\n\n  public readonly toString = () => {\n    if (this.isStart) {\n      return \"#StartTag\";\n    } else {\n      return \"#EndTag\";\n    }\n  };\n}\n\nimport { Tag as RuntimeTag } from \"../../../engine/Tag\";\nimport { Wrap } from \"./Wrap\";\nexport class LegacyTag extends Wrap<RuntimeTag> {\n  constructor(tag: RuntimeTag) {\n    super(tag);\n  }\n  get typeName(): string {\n    return \"Tag\";\n  }\n}\n","import { IFileHandler } from \"../IFileHandler\";\n\n// This class replaces upstream's DefaultFileHandler. It doesn't perform any\n// resolution and warns the user about providing a proper file handler when\n// INCLUDE statements are parsed. Since the JavaScript parser can be executed in\n// different environments, we let the user decide which FileHandler is best for\n// their use-case. See PosixFileHandler and JsonFileHandler.\nexport class DefaultFileHandler implements IFileHandler {\n  constructor(public readonly rootPath?: string) {}\n\n  readonly ResolveInkFilename = (): string => {\n    throw Error(\n      \"Can't resolve filename because no FileHandler was provided when instantiating the parser / compiler.\"\n    );\n  };\n\n  readonly LoadInkFileContents = (): string => {\n    throw Error(\n      \"Can't load ink content because no FileHandler was provided when instantiating the parser / compiler.\"\n    );\n  };\n}\n","import { Argument } from \"./ParsedHierarchy/Argument\";\nimport { AuthorWarning } from \"./ParsedHierarchy/AuthorWarning\";\nimport { BinaryExpression } from \"./ParsedHierarchy/Expression/BinaryExpression\";\nimport { CharacterRange } from \"./CharacterRange\";\nimport { CharacterSet } from \"./CharacterSet\";\nimport { Choice } from \"./ParsedHierarchy/Choice\";\nimport { CommentEliminator } from \"./CommentEliminator\";\nimport { Conditional } from \"./ParsedHierarchy/Conditional/Conditional\";\nimport { ConditionalSingleBranch } from \"./ParsedHierarchy/Conditional/ConditionalSingleBranch\";\nimport { ContentList } from \"./ParsedHierarchy/ContentList\";\nimport { ConstantDeclaration } from \"./ParsedHierarchy/Declaration/ConstantDeclaration\";\nimport { CustomFlags } from \"./CustomFlags\";\nimport { DebugMetadata } from \"../../engine/DebugMetadata\";\nimport { Divert } from \"./ParsedHierarchy/Divert/Divert\";\nimport { DivertTarget } from \"./ParsedHierarchy/Divert/DivertTarget\";\nimport { Expression } from \"./ParsedHierarchy/Expression/Expression\";\nimport { ErrorHandler } from \"../../engine/Error\";\nimport { ExternalDeclaration } from \"./ParsedHierarchy/Declaration/ExternalDeclaration\";\nimport { FlowDecl } from \"./FlowDecl\";\nimport { FunctionCall } from \"./ParsedHierarchy/FunctionCall\";\nimport { Gather } from \"./ParsedHierarchy/Gather/Gather\";\nimport { Glue } from \"./ParsedHierarchy/Glue\";\nimport { Glue as RuntimeGlue } from \"../../engine/Glue\";\nimport { IFileHandler } from \"../IFileHandler\";\nimport { IncDecExpression } from \"./ParsedHierarchy/Expression/IncDecExpression\";\nimport { IncludedFile } from \"./ParsedHierarchy/IncludedFile\";\nimport { InfixOperator } from \"./InfixOperator\";\nimport { Knot } from \"./ParsedHierarchy/Knot\";\nimport { List } from \"./ParsedHierarchy/List/List\";\nimport { ListDefinition } from \"./ParsedHierarchy/List/ListDefinition\";\nimport { ListElementDefinition } from \"./ParsedHierarchy/List/ListElementDefinition\";\nimport { MultipleConditionExpression } from \"./ParsedHierarchy/Expression/MultipleConditionExpression\";\nimport { ParsedObject } from \"./ParsedHierarchy/Object\";\nimport { Path } from \"./ParsedHierarchy/Path\";\nimport { ReturnType } from \"./ParsedHierarchy/ReturnType\";\nimport { Sequence } from \"./ParsedHierarchy/Sequence/Sequence\";\nimport { SequenceType } from \"./ParsedHierarchy/Sequence/SequenceType\";\nimport { StatementLevel } from \"./StatementLevel\";\nimport { Stitch } from \"./ParsedHierarchy/Stitch\";\nimport { Story } from \"./ParsedHierarchy/Story\";\nimport { StringExpression } from \"./ParsedHierarchy/Expression/StringExpression\";\nimport {\n  StringParser,\n  SpecificParseRule,\n  ParseRule,\n  ParseRuleReturn,\n  ParseSuccess,\n} from \"./StringParser/StringParser\";\nimport { StringParserElement } from \"./StringParser/StringParserElement\";\nimport { Tag } from \"./ParsedHierarchy/Tag\";\nimport { Text } from \"./ParsedHierarchy/Text\";\nimport { TunnelOnwards } from \"./ParsedHierarchy/TunnelOnwards\";\nimport { VariableAssignment } from \"./ParsedHierarchy/Variable/VariableAssignment\";\nimport { VariableReference } from \"./ParsedHierarchy/Variable/VariableReference\";\nimport { UnaryExpression } from \"./ParsedHierarchy/Expression/UnaryExpression\";\nimport { asOrNull, filterUndef } from \"../../engine/TypeAssertion\";\nimport { Identifier } from \"./ParsedHierarchy/Identifier\";\nimport { NumberExpression } from \"./ParsedHierarchy/Expression/NumberExpression\";\nimport { ErrorType } from \"./ErrorType\";\nimport { DefaultFileHandler } from \"../FileHandler/DefaultFileHandler\";\n\nexport class InkParser extends StringParser {\n  /**\n   * Begin base InkParser section.\n   */\n\n  get fileHandler(): IFileHandler {\n    if (!this._fileHandler) {\n      throw new Error(\"No FileHandler defined\");\n    }\n    return this._fileHandler;\n  }\n\n  set fileHandler(value: IFileHandler) {\n    this._fileHandler = value;\n  }\n\n  constructor(\n    str: string,\n    filename: string | null = null,\n    externalErrorHandler: ErrorHandler | null = null,\n    rootParser: InkParser | null = null,\n    fileHandler: IFileHandler | null = null\n  ) {\n    super(str);\n\n    this._filename = filename;\n    this.RegisterExpressionOperators();\n    this.GenerateStatementLevelRules();\n\n    this.errorHandler = this.OnStringParserError;\n\n    this._externalErrorHandler = externalErrorHandler;\n\n    if (fileHandler === null) {\n      this._fileHandler = new DefaultFileHandler();\n    } else {\n      this._fileHandler = fileHandler;\n    }\n\n    if (rootParser === null) {\n      this._rootParser = this;\n      this._openFilenames = [];\n\n      if (this._filename !== null) {\n        const fullRootInkPath = this.fileHandler.ResolveInkFilename(\n          this._filename\n        );\n        this._openFilenames.push(fullRootInkPath);\n      }\n    } else {\n      this._rootParser = rootParser;\n    }\n  }\n\n  // Main entry point\n  // NOTE: This method is named Parse() in upstream.\n  public readonly ParseStory = (): Story => {\n    const topLevelContent: ParsedObject[] = this.StatementsAtLevel(\n      StatementLevel.Top\n    );\n\n    // Note we used to return null if there were any errors, but this would mean\n    // that include files would return completely empty rather than attempting to\n    // continue with errors. Returning an empty include files meant that anything\n    // that *did* compile successfully would otherwise be ignored, generating way\n    // more errors than necessary.\n    return new Story(topLevelContent, this._rootParser !== this);\n  };\n\n  public readonly SeparatedList = <T extends ParseRule>(\n    mainRule: SpecificParseRule<T>,\n    separatorRule: ParseRule\n  ): ParseRuleReturn[] | null => {\n    const firstElement: ParseRuleReturn = this.Parse(mainRule);\n    if (firstElement === null) {\n      return null;\n    }\n\n    const allElements = [];\n    allElements.push(firstElement);\n\n    do {\n      const nextElementRuleId: number = this.BeginRule();\n      let sep = separatorRule();\n      if (sep === null) {\n        this.FailRule(nextElementRuleId);\n        break;\n      }\n\n      const nextElement = this.Parse(mainRule);\n      if (nextElement === null) {\n        this.FailRule(nextElementRuleId);\n        break;\n      }\n\n      this.SucceedRule(nextElementRuleId);\n      allElements.push(nextElement);\n    } while (true);\n\n    return allElements;\n  };\n\n  public PreProcessInputString(str: string): string {\n    const commentEliminator = new CommentEliminator(str);\n    return commentEliminator.Process();\n  }\n\n  public readonly CreateDebugMetadata = (\n    stateAtStart: StringParserElement | null,\n    stateAtEnd: StringParserElement\n  ): DebugMetadata => {\n    const md = new DebugMetadata();\n    md.startLineNumber = (stateAtStart?.lineIndex || 0) + 1;\n    md.endLineNumber = stateAtEnd.lineIndex + 1;\n    md.startCharacterNumber = (stateAtStart?.characterInLineIndex || 0) + 1;\n    md.endCharacterNumber = stateAtEnd.characterInLineIndex + 1;\n    md.fileName = this._filename;\n\n    return md;\n  };\n\n  public readonly RuleDidSucceed = (\n    result: ParseRuleReturn,\n    stateAtStart: StringParserElement | null,\n    stateAtEnd: StringParserElement\n  ): void => {\n    // Apply DebugMetadata based on the state at the start of the rule\n    // (i.e. use line number as it was at the start of the rule)\n    const parsedObj = asOrNull(result, ParsedObject);\n    if (parsedObj) {\n      parsedObj.debugMetadata = this.CreateDebugMetadata(\n        stateAtStart,\n        stateAtEnd\n      );\n    }\n\n    // A list of objects that doesn't already have metadata?\n    const parsedListObjs: ParsedObject[] | null = Array.isArray(result)\n      ? (result as ParsedObject[])\n      : null;\n    if (parsedListObjs !== null) {\n      for (const parsedListObj of parsedListObjs) {\n        const singleObj = asOrNull(parsedListObj, ParsedObject);\n        if (!singleObj) continue;\n        if (!parsedListObj.hasOwnDebugMetadata) {\n          parsedListObj.debugMetadata = this.CreateDebugMetadata(\n            stateAtStart,\n            stateAtEnd\n          );\n        }\n      }\n    }\n\n    const id = asOrNull(result, Identifier);\n    if (id != null) {\n      id.debugMetadata = this.CreateDebugMetadata(stateAtStart, stateAtEnd);\n    }\n  };\n\n  get parsingStringExpression(): boolean {\n    return this.GetFlag(Number(CustomFlags.ParsingString));\n  }\n\n  set parsingStringExpression(value: boolean) {\n    this.SetFlag(Number(CustomFlags.ParsingString), value);\n  }\n\n  get tagActive(): boolean {\n    return this.GetFlag(Number(CustomFlags.TagActive));\n  }\n\n  set tagActive(value: boolean) {\n    this.SetFlag(Number(CustomFlags.TagActive), value);\n  }\n\n  public readonly OnStringParserError = (\n    message: string,\n    index: number,\n    lineIndex: number = 0,\n    isWarning: boolean = false\n  ): void => {\n    const warningType: string = isWarning ? \"WARNING:\" : \"ERROR:\";\n    let fullMessage: string = warningType;\n\n    if (this._filename !== null) {\n      fullMessage += ` '${this._filename}'`;\n    }\n\n    fullMessage += ` line ${lineIndex + 1}: ${message}`;\n\n    if (this._externalErrorHandler !== null) {\n      this._externalErrorHandler(\n        fullMessage,\n        isWarning ? ErrorType.Warning : ErrorType.Error\n      );\n    } else {\n      throw new Error(fullMessage);\n    }\n  };\n\n  public readonly AuthorWarning = (): AuthorWarning | null => {\n    this.Whitespace();\n\n    const identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as unknown as Identifier | null;\n    if (identifier === null || identifier.name !== \"TODO\") {\n      return null;\n    }\n\n    this.Whitespace();\n    this.ParseString(\":\");\n    this.Whitespace();\n\n    const message = this.ParseUntilCharactersFromString(\"\\n\\r\");\n\n    if (message) {\n      return new AuthorWarning(message);\n    }\n\n    return null;\n  };\n\n  /**\n   * End base InkParser section.\n   */\n\n  /**\n   * Begin CharacterRanges section.\n   */\n\n  public static readonly LatinBasic: CharacterRange = CharacterRange.Define(\n    \"\\u0041\",\n    \"\\u007A\",\n    new CharacterSet().AddRange(\"\\u005B\", \"\\u0060\")\n  );\n\n  public static readonly LatinExtendedA: CharacterRange = CharacterRange.Define(\n    \"\\u0100\",\n    \"\\u017F\"\n    // no excludes here\n  );\n\n  public static readonly LatinExtendedB: CharacterRange = CharacterRange.Define(\n    \"\\u0180\",\n    \"\\u024F\"\n    // no excludes here\n  );\n\n  public static readonly Greek: CharacterRange = CharacterRange.Define(\n    \"\\u0370\",\n    \"\\u03FF\",\n    new CharacterSet()\n      .AddRange(\"\\u0378\", \"\\u0385\")\n      .AddCharacters(\"\\u0374\\u0375\\u0378\\u0387\\u038B\\u038D\\u03A2\")\n  );\n\n  public static readonly Cyrillic: CharacterRange = CharacterRange.Define(\n    \"\\u0400\",\n    \"\\u04FF\",\n    new CharacterSet().AddRange(\"\\u0482\", \"\\u0489\")\n  );\n\n  public static readonly Armenian: CharacterRange = CharacterRange.Define(\n    \"\\u0530\",\n    \"\\u058F\",\n    new CharacterSet()\n      .AddCharacters(\"\\u0530\")\n      .AddRange(\"\\u0557\", \"\\u0560\")\n      .AddRange(\"\\u0588\", \"\\u058E\")\n  );\n\n  public static readonly Hebrew: CharacterRange = CharacterRange.Define(\n    \"\\u0590\",\n    \"\\u05FF\",\n    new CharacterSet()\n  );\n\n  public static readonly Arabic: CharacterRange = CharacterRange.Define(\n    \"\\u0600\",\n    \"\\u06FF\",\n    new CharacterSet()\n  );\n\n  public static readonly Korean: CharacterRange = CharacterRange.Define(\n    \"\\uAC00\",\n    \"\\uD7AF\",\n    new CharacterSet()\n  );\n\n  private readonly ExtendIdentifierCharacterRanges = (\n    identifierCharSet: CharacterSet\n  ): void => {\n    const characterRanges = InkParser.ListAllCharacterRanges();\n    for (const charRange of characterRanges) {\n      identifierCharSet.AddCharacters(charRange.ToCharacterSet());\n    }\n  };\n\n  /// <summary>\n  /// Gets an array of <see cref=\"CharacterRange\" /> representing all of the currently supported\n  /// non-ASCII character ranges that can be used in identifier names.\n  /// </summary>\n  /// <returns>\n  /// An array of <see cref=\"CharacterRange\" /> representing all of the currently supported\n  /// non-ASCII character ranges that can be used in identifier names.\n  /// </returns>\n  public static readonly ListAllCharacterRanges = (): CharacterRange[] => [\n    InkParser.LatinBasic,\n    InkParser.LatinExtendedA,\n    InkParser.LatinExtendedB,\n    InkParser.Arabic,\n    InkParser.Armenian,\n    InkParser.Cyrillic,\n    InkParser.Greek,\n    InkParser.Hebrew,\n    InkParser.Korean,\n  ];\n\n  /**\n   * End CharacterRanges section.\n   */\n\n  /**\n   * Begin Choices section.\n   */\n\n  public _parsingChoice: boolean = false;\n\n  public readonly Choice = (): Choice | null => {\n    let onceOnlyChoice: boolean = true;\n    let bullets = this.Interleave<string>(\n      this.OptionalExclude(this.Whitespace),\n      this.String(\"*\")\n    );\n\n    if (!bullets) {\n      bullets = this.Interleave<string>(\n        this.OptionalExclude(this.Whitespace),\n        this.String(\"+\")\n      );\n\n      if (bullets === null) {\n        return null;\n      }\n\n      onceOnlyChoice = false;\n    }\n\n    // Optional name for the choice\n    const optionalName: Identifier = this.Parse(\n      this.BracketedName\n    ) as Identifier;\n\n    this.Whitespace();\n\n    // Optional condition for whether the choice should be shown to the player\n    const conditionExpr: Expression = this.Parse(\n      this.ChoiceCondition\n    ) as Expression;\n\n    this.Whitespace();\n\n    // Ordinarily we avoid parser state variables like these, since\n    // nesting would require us to store them in a stack. But since you should\n    // never be able to nest choices within choice content, it's fine here.\n    if (this._parsingChoice) {\n      throw new Error(\n        \"Already parsing a choice - shouldn't have nested choices\"\n      );\n    }\n\n    this._parsingChoice = true;\n\n    let startContent: ContentList | null = null;\n    const startTextAndLogic = this.Parse(\n      this.MixedTextAndLogic\n    ) as ParsedObject[];\n    if (startTextAndLogic) {\n      startContent = new ContentList(startTextAndLogic);\n    }\n\n    let optionOnlyContent: ContentList | null = null;\n    let innerContent: ContentList | null = null;\n\n    // Check for a the weave style format:\n    //   * \"Hello[.\"],\" he said.\n    const hasWeaveStyleInlineBrackets: boolean = this.ParseString(\"[\") !== null;\n    if (hasWeaveStyleInlineBrackets) {\n      this.EndTagIfNecessary(startContent);\n\n      const optionOnlyTextAndLogic = this.Parse(\n        this.MixedTextAndLogic\n      ) as ParsedObject[];\n\n      if (optionOnlyTextAndLogic !== null) {\n        optionOnlyContent = new ContentList(optionOnlyTextAndLogic);\n      }\n\n      this.Expect(this.String(\"]\"), \"closing ']' for weave-style option\");\n\n      this.EndTagIfNecessary(optionOnlyContent);\n\n      let innerTextAndLogic = this.Parse(\n        this.MixedTextAndLogic\n      ) as ParsedObject[];\n      if (innerTextAndLogic !== null) {\n        innerContent = new ContentList(innerTextAndLogic);\n      }\n    }\n\n    this.Whitespace();\n\n    this.EndTagIfNecessary(innerContent ?? startContent);\n\n    // Finally, now we know we're at the end of the main choice body, parse\n    // any diverts separately.\n    const diverts: ParsedObject[] = this.Parse(\n      this.MultiDivert\n    ) as ParsedObject[];\n\n    this._parsingChoice = false;\n\n    this.Whitespace();\n\n    // Completely empty choice without even an empty divert?\n    const emptyContent: boolean =\n      !startContent && !innerContent && !optionOnlyContent;\n\n    if (emptyContent && diverts === null) {\n      this.Warning(\n        \"Choice is completely empty. Interpretting as a default fallback choice. Add a divert arrow to remove this warning: * ->\"\n      );\n    }\n\n    if (!startContent && hasWeaveStyleInlineBrackets && !optionOnlyContent) {\n      // * [] some text\n      this.Warning(\n        \"Blank choice - if you intended a default fallback choice, use the `* ->` syntax\"\n      );\n    }\n\n    if (!innerContent) {\n      innerContent = new ContentList();\n    }\n\n    this.EndTagIfNecessary(innerContent);\n\n    // Normal diverts on the end of a choice - simply add to the normal content\n    if (diverts !== null) {\n      for (const divObj of diverts) {\n        // may be TunnelOnwards\n        const div = asOrNull(divObj, Divert);\n\n        // Empty divert serves no purpose other than to say\n        // \"this choice is intentionally left blank\"\n        // (as an invisible default choice)\n        if (div && div.isEmpty) {\n          continue;\n        }\n\n        innerContent.AddContent(divObj);\n      }\n    }\n\n    // Terminate main content with a newline since this is the end of the line\n    // Note that this will be redundant if the diverts above definitely take\n    // the flow away permanently.\n    innerContent.AddContent(new Text(\"\\n\"));\n\n    const choice = new Choice(startContent!, optionOnlyContent!, innerContent);\n    if (optionalName) choice.identifier = optionalName;\n    choice.indentationDepth = bullets.length;\n    choice.hasWeaveStyleInlineBrackets = hasWeaveStyleInlineBrackets;\n    choice.condition = conditionExpr;\n    choice.onceOnly = onceOnlyChoice;\n    choice.isInvisibleDefault = emptyContent;\n    return choice;\n  };\n\n  public readonly ChoiceCondition = (): Expression | null => {\n    const conditions = this.Interleave<Expression>(\n      this.ChoiceSingleCondition,\n      this.ChoiceConditionsSpace\n    );\n\n    if (conditions === null) {\n      return null;\n    } else if (conditions.length === 1) {\n      return conditions[0];\n    }\n\n    return new MultipleConditionExpression(conditions);\n  };\n\n  public readonly ChoiceConditionsSpace = (): typeof ParseSuccess => {\n    // Both optional\n    // Newline includes initial end of line whitespace\n    this.Newline();\n    this.Whitespace();\n\n    return ParseSuccess;\n  };\n\n  public readonly ChoiceSingleCondition = (): Expression | null => {\n    if (this.ParseString(\"{\") === null) {\n      return null;\n    }\n\n    const condExpr = this.Expect(\n      this.Expression,\n      \"choice condition inside { }\"\n    ) as Expression;\n\n    this.DisallowIncrement(condExpr);\n    this.Expect(this.String(\"}\"), \"closing '}' for choice condition\");\n\n    return condExpr;\n  };\n\n  public readonly Gather = (): Gather | null => {\n    const gatherDashCountObj: number = this.Parse(this.GatherDashes) as number;\n    if (gatherDashCountObj === null) {\n      return null;\n    }\n\n    const gatherDashCount: number = Number(gatherDashCountObj);\n\n    // Optional name for the gather\n    const optionalName: Identifier = this.Parse(\n      this.BracketedName\n    ) as Identifier;\n\n    const gather = new Gather(optionalName, gatherDashCount);\n\n    // Optional newline before gather's content begins\n    this.Newline();\n\n    return gather;\n  };\n\n  public readonly GatherDashes = (): number | null => {\n    this.Whitespace();\n\n    let gatherDashCount: number = 0;\n    while (this.ParseDashNotArrow() !== null) {\n      gatherDashCount += 1;\n      this.Whitespace();\n    }\n\n    if (gatherDashCount === 0) {\n      return null;\n    }\n\n    return gatherDashCount as number;\n  };\n\n  public readonly ParseDashNotArrow = () => {\n    const ruleId = this.BeginRule();\n\n    if (\n      this.ParseString(\"->\") === null &&\n      this.ParseSingleCharacter() === \"-\"\n    ) {\n      return this.SucceedRule(ruleId);\n    }\n\n    return this.FailRule(ruleId);\n  };\n\n  public readonly BracketedName = (): Identifier | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const name = this.Parse(this.IdentifierWithMetadata) as Identifier | null;\n    if (name === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\")\"), \"closing ')' for bracketed name\");\n\n    return name;\n  };\n\n  /**\n   * End Choices section.\n   */\n\n  /**\n   * Begin Conditional section.\n   */\n\n  public readonly InnerConditionalContent = (\n    initialQueryExpression: Expression\n  ): Conditional | null => {\n    if (initialQueryExpression === undefined) {\n      const initialQueryExpression = this.Parse(this.ConditionExpression);\n      const conditional = this.Parse(() =>\n        this.InnerConditionalContent(initialQueryExpression as Expression)\n      ) as Conditional;\n\n      if (conditional === null) {\n        return null;\n      }\n\n      return conditional;\n    }\n\n    let alternatives: ConditionalSingleBranch[] | null;\n    const canBeInline: boolean = initialQueryExpression !== null;\n    const isInline: boolean = this.Parse(this.Newline) === null;\n\n    if (isInline && !canBeInline) {\n      return null;\n    }\n\n    if (isInline) {\n      // Inline innards\n      alternatives = this.InlineConditionalBranches();\n    } else {\n      // Multiline innards\n      alternatives = this.MultilineConditionalBranches();\n\n      if (alternatives === null) {\n        // Allow single piece of content within multi-line expression, e.g.:\n        // { true:\n        //    Some content that isn't preceded by '-'\n        // }\n        if (initialQueryExpression) {\n          let soleContent: ParsedObject[] = this.StatementsAtLevel(\n            StatementLevel.InnerBlock\n          );\n          if (soleContent !== null) {\n            const soleBranch = new ConditionalSingleBranch(soleContent);\n            alternatives = [soleBranch];\n\n            // Also allow a final \"- else:\" clause\n            const elseBranch = this.Parse(\n              this.SingleMultilineCondition\n            ) as ConditionalSingleBranch;\n            if (elseBranch) {\n              if (!elseBranch.isElse) {\n                this.ErrorWithParsedObject(\n                  \"Expected an '- else:' clause here rather than an extra condition\",\n                  elseBranch\n                );\n\n                elseBranch.isElse = true;\n              }\n\n              alternatives.push(elseBranch);\n            }\n          }\n        }\n\n        // Still null?\n        if (alternatives === null) {\n          return null;\n        }\n      } else if (\n        alternatives.length === 1 &&\n        alternatives[0].isElse &&\n        initialQueryExpression\n      ) {\n        // Empty true branch - didn't get parsed, but should insert one for semantic correctness,\n        // and to make sure that any evaluation stack values get tidied up correctly.\n        const emptyTrueBranch = new ConditionalSingleBranch(null);\n        emptyTrueBranch.isTrueBranch = true;\n        alternatives.unshift(emptyTrueBranch);\n      }\n\n      // Like a switch statement\n      // { initialQueryExpression:\n      //    ... match the expression\n      // }\n      if (initialQueryExpression) {\n        let earlierBranchesHaveOwnExpression: boolean = false;\n        for (let ii = 0; ii < alternatives.length; ++ii) {\n          const branch = alternatives[ii];\n          const isLast: boolean = ii === alternatives.length - 1;\n\n          // Matching equality with initial query expression\n          // We set this flag even for the \"else\" clause so that\n          // it knows to tidy up the evaluation stack at the end\n\n          // Match query\n          if (branch.ownExpression) {\n            branch.matchingEquality = true;\n            earlierBranchesHaveOwnExpression = true;\n          } else if (earlierBranchesHaveOwnExpression && isLast) {\n            // Else (final branch)\n            branch.matchingEquality = true;\n            branch.isElse = true;\n          } else {\n            // Binary condition:\n            // { trueOrFalse:\n            //    - when true\n            //    - when false\n            // }\n            if (!isLast && alternatives.length > 2) {\n              this.ErrorWithParsedObject(\n                \"Only final branch can be an 'else'. Did you miss a ':'?\",\n                branch\n              );\n            } else {\n              if (ii === 0) {\n                branch.isTrueBranch = true;\n              } else {\n                branch.isElse = true;\n              }\n            }\n          }\n        }\n      } else {\n        // No initial query, so just a multi-line conditional. e.g.:\n        // {\n        //   - x > 3:  greater than three\n        //   - x == 3: equal to three\n        //   - x < 3:  less than three\n        // }\n\n        for (let ii = 0; ii < alternatives.length; ++ii) {\n          const alt = alternatives[ii];\n          const isLast: boolean = ii === alternatives.length - 1;\n\n          if (alt.ownExpression === null) {\n            if (isLast) {\n              alt.isElse = true;\n            } else {\n              if (alt.isElse) {\n                // Do we ALSO have a valid \"else\" at the end? Let's report the error there.\n                const finalClause = alternatives[alternatives.length - 1];\n                if (finalClause.isElse) {\n                  this.ErrorWithParsedObject(\n                    \"Multiple 'else' cases. Can have a maximum of one, at the end.\",\n                    finalClause\n                  );\n                } else {\n                  this.ErrorWithParsedObject(\n                    \"'else' case in conditional should always be the final one\",\n                    alt\n                  );\n                }\n              } else {\n                this.ErrorWithParsedObject(\n                  \"Branch doesn't have condition. Are you missing a ':'? \",\n                  alt\n                );\n              }\n            }\n          }\n        }\n\n        if (\n          alternatives.length === 1 &&\n          alternatives[0].ownExpression === null\n        ) {\n          this.ErrorWithParsedObject(\n            \"Condition block with no conditions\",\n            alternatives[0]\n          );\n        }\n      }\n    }\n\n    // TODO: Come up with water-tight error conditions... it's quite a flexible system!\n    // e.g.\n    //   - inline conditionals must have exactly 1 or 2 alternatives\n    //   - multiline expression shouldn't have mixed existence of branch-conditions?\n    if (alternatives === null) {\n      return null;\n    }\n\n    for (const branch of alternatives) {\n      branch.isInline = isInline;\n    }\n\n    const cond = new Conditional(initialQueryExpression, alternatives);\n\n    return cond;\n  };\n\n  public readonly InlineConditionalBranches = ():\n    | ConditionalSingleBranch[]\n    | null => {\n    const listOfLists = this.Interleave<ParsedObject[]>(\n      this.MixedTextAndLogic,\n      this.Exclude(this.String(\"|\")),\n      null,\n      false\n    );\n\n    if (listOfLists === null || listOfLists.length === 0) {\n      return null;\n    }\n\n    const result: ConditionalSingleBranch[] = [];\n\n    if (listOfLists.length > 2) {\n      this.Error(\n        \"Expected one or two alternatives separated by '|' in inline conditional\"\n      );\n    } else {\n      const trueBranch = new ConditionalSingleBranch(listOfLists[0]);\n      trueBranch.isTrueBranch = true;\n      result.push(trueBranch);\n\n      if (listOfLists.length > 1) {\n        const elseBranch = new ConditionalSingleBranch(listOfLists[1]);\n        elseBranch.isElse = true;\n        result.push(elseBranch);\n      }\n    }\n\n    return result;\n  };\n\n  public readonly MultilineConditionalBranches = ():\n    | ConditionalSingleBranch[]\n    | null => {\n    this.MultilineWhitespace();\n\n    const multipleConditions = this.OneOrMore(this.SingleMultilineCondition);\n    if (multipleConditions === null) {\n      return null;\n    }\n\n    this.MultilineWhitespace();\n\n    return multipleConditions as ConditionalSingleBranch[];\n  };\n\n  public readonly SingleMultilineCondition =\n    (): ConditionalSingleBranch | null => {\n      this.Whitespace();\n\n      if (\n        // Make sure we're not accidentally parsing a divert\n        this.ParseString(\"->\") !== null ||\n        this.ParseString(\"-\") === null\n      ) {\n        return null;\n      }\n\n      this.Whitespace();\n\n      let expr: Expression | null = null;\n      const isElse: boolean = this.Parse(this.ElseExpression) !== null;\n\n      if (!isElse) {\n        expr = this.Parse(this.ConditionExpression) as Expression;\n      }\n\n      let content: ParsedObject[] = this.StatementsAtLevel(\n        StatementLevel.InnerBlock\n      );\n      if (expr === null && content === null) {\n        this.Error(\"expected content for the conditional branch following '-'\");\n\n        // Recover\n        content = [new Text(\"\")];\n      }\n\n      // Allow additional multiline whitespace, if the statements were empty (valid)\n      // then their surrounding multiline whitespacce needs to be handled manually.\n      // e.g.\n      // { x:\n      //   - 1:    // intentionally left blank, but newline needs to be parsed\n      //   - 2: etc\n      // }\n      this.MultilineWhitespace();\n\n      const branch = new ConditionalSingleBranch(content);\n      branch.ownExpression = expr;\n      branch.isElse = isElse;\n\n      return branch;\n    };\n\n  public readonly ConditionExpression = (): ParsedObject | null => {\n    const expr = this.Parse(this.Expression) as ParsedObject;\n    if (expr === null) {\n      return null;\n    }\n\n    this.DisallowIncrement(expr);\n\n    this.Whitespace();\n\n    if (this.ParseString(\":\") === null) {\n      return null;\n    }\n\n    return expr;\n  };\n\n  public readonly ElseExpression = (): typeof ParseSuccess | null => {\n    if (this.ParseString(\"else\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    if (this.ParseString(\":\") === null) {\n      return null;\n    }\n\n    return ParseSuccess;\n  };\n\n  /**\n   * End Conditional section.\n   */\n\n  /**\n   * Begin Content section.\n   */\n\n  public _nonTextPauseCharacters: CharacterSet | null = null;\n  public _nonTextEndCharacters: CharacterSet | null = null;\n  public _notTextEndCharactersChoice: CharacterSet | null = null;\n  public _notTextEndCharactersString: CharacterSet | null = null;\n\n  public readonly TrimEndWhitespace = (\n    mixedTextAndLogicResults: ParsedObject[],\n    terminateWithSpace: boolean\n  ): void => {\n    // Trim whitespace from end\n    if (mixedTextAndLogicResults.length > 0) {\n      const lastObjIdx = mixedTextAndLogicResults.length - 1;\n      const lastObj = mixedTextAndLogicResults[lastObjIdx];\n      if (lastObj instanceof Text) {\n        const textObj: Text = lastObj;\n        textObj.text = textObj.text.replace(new RegExp(/[ \\t]+$/g), \"\");\n\n        if (terminateWithSpace) {\n          textObj.text += \" \";\n        } else if (textObj.text.length === 0) {\n          // No content left at all? trim the whole object\n          mixedTextAndLogicResults.splice(lastObjIdx, 1);\n\n          // Recurse in case there's more whitespace\n          this.TrimEndWhitespace(mixedTextAndLogicResults, false);\n        }\n      }\n    }\n  };\n\n  public readonly LineOfMixedTextAndLogic = (): ParsedObject[] | null => {\n    // Consume any whitespace at the start of the line\n    // (Except for escaped whitespace)\n    this.Parse(this.Whitespace);\n\n    let result: ParsedObject[] = this.Parse(\n      this.MixedTextAndLogic\n    ) as ParsedObject[];\n\n    if (!result || !result.length) {\n      return null;\n    }\n\n    // Warn about accidentally writing \"return\" without \"~\"\n    const firstText = result[0] as Text;\n    if (firstText && firstText.text && firstText.text.startsWith(\"return\")) {\n      this.Warning(\n        \"Do you need a '~' before 'return'? If not, perhaps use a glue: <> (since it's lowercase) or rewrite somehow?\"\n      );\n    }\n\n    if (result.length === 0) {\n      return null;\n    }\n\n    const lastObj = result[result.length - 1];\n    if (!(lastObj instanceof Divert)) {\n      this.TrimEndWhitespace(result, false);\n    }\n\n    this.EndTagIfNecessary(result);\n\n    // If the line doens't actually contain any normal text content\n    // but is in fact entirely a tag, then let's not append\n    // a newline, since we want the tag (or tags) to be associated\n    // with the line below rather than being completely independent.\n    let lineIsPureTag =\n      result.length > 0 && result[0] instanceof Tag && result[0].isStart;\n\n    if (!lineIsPureTag) {\n      result.push(new Text(\"\\n\"));\n    }\n\n    this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n    return result;\n  };\n\n  public readonly MixedTextAndLogic = (): ParsedObject[] | null => {\n    // Check for disallowed \"~\" within this context\n    const disallowedTilde = this.ParseObject(this.Spaced(this.String(\"~\")));\n    if (disallowedTilde !== null) {\n      this.Error(\n        \"You shouldn't use a '~' here - tildas are for logic that's on its own line. To do inline logic, use { curly braces } instead\"\n      );\n    }\n\n    // Either, or both interleaved\n    let results: ParsedObject[] = this.Interleave<ParsedObject>(\n      this.Optional(this.ContentText),\n      this.Optional(this.InlineLogicOrGlueOrStartTag)\n    );\n\n    // Terminating divert?\n    // (When parsing content for the text of a choice, diverts aren't allowed.\n    //  The divert on the end of the body of a choice is handled specially.)\n    if (!this._parsingChoice) {\n      const diverts: ParsedObject[] = this.Parse(\n        this.MultiDivert\n      ) as ParsedObject[];\n      if (diverts !== null) {\n        // May not have had any results at all if there's *only* a divert!\n        if (results === null) {\n          results = [];\n        }\n\n        // End previously active tag if necessary\n        this.EndTagIfNecessary(results);\n\n        this.TrimEndWhitespace(results, true);\n\n        results.push(...diverts);\n      }\n    }\n\n    if (!results) {\n      return null;\n    }\n\n    return results;\n  };\n\n  public readonly ContentText = () => {\n    return this.ContentTextAllowingEscapeChar();\n  };\n\n  public readonly ContentTextAllowingEscapeChar = (): Text | null => {\n    let sb: string | null = null;\n\n    do {\n      let str = this.Parse(this.ContentTextNoEscape);\n      const gotEscapeChar: boolean = this.ParseString(\"\\\\\") !== null;\n\n      if (gotEscapeChar || str !== null) {\n        if (sb === null) {\n          sb = \"\";\n        }\n\n        if (str !== null) {\n          sb += String(str);\n        }\n\n        if (gotEscapeChar) {\n          const c: string = this.ParseSingleCharacter();\n          sb += c;\n        }\n      } else {\n        break;\n      }\n    } while (true);\n\n    if (sb !== null) {\n      return new Text(sb);\n    }\n\n    return null;\n  };\n\n  // Content text is an unusual parse rule compared with most since it's\n  // less about saying \"this is is the small selection of stuff that we parse\"\n  // and more \"we parse ANYTHING except this small selection of stuff\".\n  public readonly ContentTextNoEscape = (): string | null => {\n    // Eat through text, pausing at the following characters, and\n    // attempt to parse the nonTextRule.\n    // \"-\": possible start of divert or start of gather\n    // \"<\": possible start of glue\n    if (this._nonTextPauseCharacters === null) {\n      this._nonTextPauseCharacters = new CharacterSet(\"-<\");\n    }\n\n    // If we hit any of these characters, we stop *immediately* without bothering to even check the nonTextRule\n    // \"{\" for start of logic\n    // \"|\" for mid logic branch\n    if (this._nonTextEndCharacters === null) {\n      this._nonTextEndCharacters = new CharacterSet(\"{}|\\n\\r\\\\#\");\n      this._notTextEndCharactersChoice = new CharacterSet(\n        this._nonTextEndCharacters\n      );\n      this._notTextEndCharactersChoice.AddCharacters(\"[]\");\n      this._notTextEndCharactersString = new CharacterSet(\n        this._nonTextEndCharacters\n      );\n      this._notTextEndCharactersString.AddCharacters('\"');\n    }\n\n    // When the ParseUntil pauses, check these rules in case they evaluate successfully\n    const nonTextRule: ParseRule = () =>\n      this.OneOf([\n        this.ParseDivertArrow,\n        this.ParseThreadArrow,\n        this.EndOfLine,\n        this.Glue,\n      ]);\n\n    let endChars: CharacterSet | null = null;\n    if (this.parsingStringExpression) {\n      endChars = this._notTextEndCharactersString;\n    } else if (this._parsingChoice) {\n      endChars = this._notTextEndCharactersChoice;\n    } else {\n      endChars = this._nonTextEndCharacters;\n    }\n\n    const pureTextContent: string = this.ParseUntil(\n      nonTextRule,\n      this._nonTextPauseCharacters,\n      endChars\n    );\n\n    if (pureTextContent !== null) {\n      return pureTextContent;\n    }\n\n    return null;\n  };\n\n  /**\n   * End Content section.\n   */\n\n  /**\n   * Begin Divert section.\n   */\n\n  public readonly MultiDivert = (): ParsedObject[] | null => {\n    this.Whitespace();\n\n    let diverts: ParsedObject[] = [];\n\n    // Try single thread first\n    const threadDivert = this.Parse(this.StartThread) as ParsedObject;\n    if (threadDivert) {\n      diverts = [threadDivert];\n\n      return diverts;\n    }\n\n    // Normal diverts and tunnels\n    const arrowsAndDiverts = this.Interleave<ParsedObject>(\n      this.ParseDivertArrowOrTunnelOnwards,\n      this.DivertIdentifierWithArguments\n    );\n\n    if (!arrowsAndDiverts) {\n      return null;\n    }\n\n    diverts = [];\n\n    this.EndTagIfNecessary(diverts);\n\n    // Possible patterns:\n    //  ->                   -- explicit gather\n    //  ->->                 -- tunnel onwards\n    //  -> div               -- normal divert\n    //  ->-> div             -- tunnel onwards, followed by override divert\n    //  -> div ->            -- normal tunnel\n    //  -> div ->->          -- tunnel then tunnel continue\n    //  -> div -> div        -- tunnel then divert\n    //  -> div -> div ->     -- tunnel then tunnel\n    //  -> div -> div ->->\n    //  -> div -> div ->-> div    (etc)\n\n    // Look at the arrows and diverts\n    for (let ii = 0; ii < arrowsAndDiverts.length; ++ii) {\n      const isArrow: boolean = ii % 2 === 0;\n\n      // Arrow string\n      if (isArrow) {\n        // Tunnel onwards\n        if ((arrowsAndDiverts[ii] as any) === \"->->\") {\n          const tunnelOnwardsPlacementValid: boolean =\n            ii === 0 ||\n            ii === arrowsAndDiverts.length - 1 ||\n            ii === arrowsAndDiverts.length - 2;\n\n          if (!tunnelOnwardsPlacementValid) {\n            this.Error(\n              \"Tunnel onwards '->->' must only come at the begining or the start of a divert\"\n            );\n          }\n\n          const tunnelOnwards = new TunnelOnwards();\n          if (ii < arrowsAndDiverts.length - 1) {\n            const tunnelOnwardDivert = asOrNull(\n              arrowsAndDiverts[ii + 1],\n              Divert\n            );\n            tunnelOnwards.divertAfter = tunnelOnwardDivert;\n          }\n\n          diverts.push(tunnelOnwards);\n\n          // Not allowed to do anything after a tunnel onwards.\n          // If we had anything left it would be caused in the above Error for\n          // the positioning of a ->->\n          break;\n        }\n      } else {\n        // Divert\n        const divert = arrowsAndDiverts[ii] as Divert;\n        // More to come? (further arrows) Must be tunnelling.\n        if (ii < arrowsAndDiverts.length - 1) {\n          divert.isTunnel = true;\n        }\n\n        diverts.push(divert);\n      }\n    }\n\n    // Single -> (used for default choices)\n    if (diverts.length === 0 && arrowsAndDiverts.length === 1) {\n      const gatherDivert = new Divert(null);\n      gatherDivert.isEmpty = true;\n      diverts.push(gatherDivert);\n\n      if (!this._parsingChoice) {\n        this.Error(\"Empty diverts (->) are only valid on choices\");\n      }\n    }\n\n    return diverts;\n  };\n\n  public readonly StartThread = (): Divert | null => {\n    this.Whitespace();\n\n    if (this.ParseThreadArrow() === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const divert = this.Expect(\n      this.DivertIdentifierWithArguments,\n      \"target for new thread\",\n      () => new Divert(null)\n    ) as Divert;\n\n    divert.isThread = true;\n\n    return divert;\n  };\n\n  public readonly DivertIdentifierWithArguments = (): Divert | null => {\n    this.Whitespace();\n\n    const targetComponents: Identifier[] = this.Parse(\n      this.DotSeparatedDivertPathComponents\n    ) as Identifier[];\n\n    if (!targetComponents) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const optionalArguments = this.Parse(\n      this.ExpressionFunctionCallArguments\n    ) as Expression[];\n\n    this.Whitespace();\n\n    const targetPath = new Path(targetComponents);\n\n    return new Divert(targetPath, optionalArguments);\n  };\n\n  public readonly SingleDivert = (): Divert | null => {\n    const diverts = this.Parse(this.MultiDivert) as ParsedObject[];\n    if (!diverts) {\n      return null;\n    }\n\n    // Ideally we'd report errors if we get the\n    // wrong kind of divert, but unfortunately we\n    // have to hack around the fact that sequences use\n    // a very similar syntax.\n    // i.e. if you have a multi-divert at the start\n    // of a sequence, it initially tries to parse it\n    // as a divert target (part of an expression of\n    // a conditional) and gives errors. So instead\n    // we just have to blindly reject it as a single\n    // divert, and give a slightly less nice error\n    // when you DO use a multi divert as a divert taret.\n\n    if (diverts.length !== 1) {\n      return null;\n    }\n\n    const singleDivert = diverts[0];\n    if (singleDivert instanceof TunnelOnwards) {\n      return null;\n    }\n\n    const divert = diverts[0] as Divert;\n    if (divert.isTunnel) {\n      return null;\n    }\n\n    return divert;\n  };\n\n  public readonly DotSeparatedDivertPathComponents = (): Identifier[] =>\n    this.Interleave<Identifier>(\n      this.Spaced(this.IdentifierWithMetadata),\n      this.Exclude(this.String(\".\"))\n    );\n\n  public readonly ParseDivertArrowOrTunnelOnwards = (): string | null => {\n    let numArrows: number = 0;\n    while (this.ParseString(\"->\") !== null) {\n      numArrows += 1;\n    }\n\n    if (numArrows === 0) {\n      return null;\n    } else if (numArrows === 1) {\n      return \"->\";\n    } else if (numArrows === 2) {\n      return \"->->\";\n    }\n\n    this.Error(\n      \"Unexpected number of arrows in divert. Should only have '->' or '->->'\"\n    );\n\n    return \"->->\";\n  };\n\n  public readonly ParseDivertArrow = () => this.ParseString(\"->\");\n\n  public readonly ParseThreadArrow = () => this.ParseString(\"<-\");\n\n  /**\n   * End Divert section.\n   */\n\n  /**\n   * Begin Expressions section.\n   */\n\n  public _binaryOperators: InfixOperator[] = [];\n  public _maxBinaryOpLength: number = 0;\n\n  public readonly TempDeclarationOrAssignment = (): ParsedObject | null => {\n    this.Whitespace();\n\n    const isNewDeclaration: boolean = this.ParseTempKeyword();\n\n    this.Whitespace();\n\n    let varIdentifier: Identifier | null = null;\n    if (isNewDeclaration) {\n      varIdentifier = this.Expect(\n        this.IdentifierWithMetadata,\n        \"variable name\"\n      ) as Identifier;\n    } else {\n      varIdentifier = this.Parse(this.IdentifierWithMetadata) as Identifier;\n    }\n\n    if (varIdentifier === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // += -=\n    const isIncrement: boolean = this.ParseString(\"+\") !== null;\n    const isDecrement: boolean = this.ParseString(\"-\") !== null;\n\n    if (isIncrement && isDecrement) {\n      this.Error(\"Unexpected sequence '+-'\");\n    }\n\n    if (this.ParseString(\"=\") === null) {\n      // Definitely in an assignment expression?\n      if (isNewDeclaration) {\n        this.Error(\"Expected '='\");\n      }\n\n      return null;\n    }\n\n    const assignedExpression: Expression = this.Expect(\n      this.Expression,\n      \"value expression to be assigned\"\n    ) as Expression;\n\n    if (isIncrement || isDecrement) {\n      const result = new IncDecExpression(\n        varIdentifier,\n        assignedExpression,\n        isIncrement\n      );\n      return result;\n    }\n\n    const result = new VariableAssignment({\n      variableIdentifier: varIdentifier,\n      assignedExpression,\n      isTemporaryNewDeclaration: isNewDeclaration,\n    });\n\n    return result;\n  };\n\n  public readonly DisallowIncrement = (expr: ParsedObject): void => {\n    if (expr instanceof IncDecExpression) {\n      this.Error(\n        \"Can't use increment/decrement here. It can only be used on a ~ line\"\n      );\n    }\n  };\n\n  public readonly ParseTempKeyword = () => {\n    const ruleId = this.BeginRule();\n\n    if (this.Parse(this.Identifier) === \"temp\") {\n      this.SucceedRule(ruleId);\n      return true;\n    }\n\n    this.FailRule(ruleId);\n    return false;\n  };\n\n  public readonly ReturnStatement = (): ReturnType | null => {\n    this.Whitespace();\n\n    const returnOrDone = this.Parse(this.Identifier);\n    if (returnOrDone !== \"return\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const expr = this.Parse(this.Expression) as Expression;\n\n    const returnObj = new ReturnType(expr);\n\n    return returnObj;\n  };\n\n  // Pratt Parser\n  // aka \"Top down operator precedence parser\"\n  // http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\n  // Algorithm overview:\n  // The two types of precedence are handled in two different ways:\n  //   ((((a . b) . c) . d) . e)\t\t\t#1\n  //   (a . (b . (c . (d . e))))\t\t\t#2\n  // Where #1 is automatically handled by successive loops within the main 'while' in this function,\n  // so long as continuing operators have lower (or equal) precedence (e.g. imagine some series of \"*\"s then \"+\" above.\n  // ...and #2 is handled by recursion of the right hand term in the binary expression parser.\n  // (see link for advice on how to extend for postfix and mixfix operators)\n  public readonly Expression = (\n    minimumPrecedence: number = 0\n  ): Expression | null => {\n    this.Whitespace();\n\n    // First parse a unary expression e.g. \"-a\" or parethensised \"(1 + 2)\"\n    let expr = this.ExpressionUnary();\n    if (expr === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // Attempt to parse (possibly multiple) continuing infix expressions (e.g. 1 + 2 + 3)\n    while (true) {\n      const ruleId = this.BeginRule();\n\n      // Operator\n      const infixOp = this.ParseInfixOperator();\n      if (infixOp !== null && infixOp.precedence > minimumPrecedence) {\n        // Expect right hand side of operator\n        const expectationMessage = `right side of '${infixOp.type}' expression`;\n        const multiaryExpr = this.Expect(\n          () => this.ExpressionInfixRight(expr, infixOp),\n          expectationMessage\n        );\n\n        if (multiaryExpr === null) {\n          // Fail for operator and right-hand side of multiary expression\n          this.FailRule(ruleId);\n\n          return null;\n        }\n\n        expr = this.SucceedRule(ruleId, multiaryExpr) as Expression;\n\n        continue;\n      }\n\n      this.FailRule(ruleId);\n      break;\n    }\n\n    this.Whitespace();\n\n    return expr;\n  };\n\n  public readonly ExpressionUnary = (): Expression | null => {\n    // Divert target is a special case - it can't have any other operators\n    // applied to it, and we also want to check for it first so that we don't\n    // confuse \"->\" for subtraction.\n    const divertTarget = this.Parse(this.ExpressionDivertTarget) as Expression;\n    if (divertTarget !== null) {\n      return divertTarget;\n    }\n\n    let prefixOp: Expression = this.OneOf([\n      this.String(\"-\"),\n      this.String(\"!\"),\n    ]) as Expression;\n\n    // Don't parse like the string rules above, in case its actually\n    // a variable that simply starts with \"not\", e.g. \"notable\".\n    // This rule uses the Identifier rule, which will scan as much text\n    // as possible before returning.\n    if (prefixOp === null) {\n      prefixOp = this.Parse(this.ExpressionNot) as Expression;\n    }\n\n    this.Whitespace();\n\n    // - Since we allow numbers at the start of variable names, variable names are checked before literals\n    // - Function calls before variable names in case we see parentheses\n    let expr = this.OneOf([\n      this.ExpressionList,\n      this.ExpressionParen,\n      this.ExpressionFunctionCall,\n      this.ExpressionVariableName,\n      this.ExpressionLiteral,\n    ]) as Expression | null;\n\n    // Only recurse immediately if we have one of the (usually optional) unary ops\n    if (expr === null && prefixOp !== null) {\n      expr = this.ExpressionUnary();\n    }\n\n    if (expr === null) {\n      return null;\n    } else if (prefixOp !== null) {\n      expr = UnaryExpression.WithInner(expr, prefixOp as any) as Expression;\n    }\n\n    this.Whitespace();\n\n    const postfixOp = this.OneOf([this.String(\"++\"), this.String(\"--\")]);\n\n    if (postfixOp !== null) {\n      const isInc: boolean = postfixOp === \"++\";\n\n      if (!(expr instanceof VariableReference)) {\n        this.Error(\n          `can only increment and decrement variables, but saw '${expr}'.`\n        );\n\n        // Drop down and succeed without the increment after reporting error\n      } else {\n        const varRef = expr as VariableReference;\n        expr = new IncDecExpression(varRef.identifier, isInc);\n      }\n    }\n\n    return expr;\n  };\n\n  public readonly ExpressionNot = (): string | null => {\n    const id = this.Identifier();\n    if (id === \"not\") {\n      return id;\n    }\n\n    return null;\n  };\n\n  public readonly ExpressionLiteral = (): Expression =>\n    this.OneOf([\n      this.ExpressionFloat,\n      this.ExpressionInt,\n      this.ExpressionBool,\n      this.ExpressionString,\n    ]) as Expression;\n\n  public readonly ExpressionDivertTarget = (): Expression | null => {\n    this.Whitespace();\n\n    const divert = this.Parse(this.SingleDivert) as Divert;\n    if (!divert || (divert && divert.isThread)) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    return new DivertTarget(divert);\n  };\n\n  public readonly ExpressionInt = (): NumberExpression | null => {\n    const intOrNull: number = this.ParseInt() as number;\n    if (intOrNull === null) {\n      return null;\n    }\n\n    return new NumberExpression(intOrNull, \"int\");\n  };\n\n  public readonly ExpressionFloat = (): NumberExpression | null => {\n    const floatOrNull: number = this.ParseFloat() as number;\n    if (floatOrNull === null) {\n      return null;\n    }\n\n    return new NumberExpression(floatOrNull, \"float\");\n  };\n\n  public readonly ExpressionString = (): StringExpression | null => {\n    const openQuote = this.ParseString('\"');\n    if (openQuote === null) {\n      return null;\n    }\n\n    // Set custom parser state flag so that within the text parser,\n    // it knows to treat the quote character (\") as an end character\n    this.parsingStringExpression = true;\n\n    let textAndLogic: ParsedObject[] = this.Parse(\n      this.MixedTextAndLogic\n    ) as ParsedObject[];\n\n    this.Expect(this.String('\"'), \"close quote for string expression\");\n\n    this.parsingStringExpression = false;\n\n    if (textAndLogic === null) {\n      textAndLogic = [new Text(\"\")];\n    } else if (textAndLogic.find((c) => c instanceof Divert)) {\n      this.Error(\"String expressions cannot contain diverts (->)\");\n    }\n\n    return new StringExpression(textAndLogic);\n  };\n\n  public readonly ExpressionBool = (): NumberExpression | null => {\n    const id = this.Parse(this.Identifier);\n    if (id === \"true\") {\n      return new NumberExpression(true, \"bool\");\n    } else if (id === \"false\") {\n      return new NumberExpression(false, \"bool\");\n    }\n\n    return null;\n  };\n\n  public readonly ExpressionFunctionCall = (): Expression | null => {\n    const iden = this.Parse(this.IdentifierWithMetadata);\n    if (iden === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const args = this.Parse(this.ExpressionFunctionCallArguments);\n    if (args === null) {\n      return null;\n    }\n\n    return new FunctionCall(iden as Identifier, args as any);\n  };\n\n  public readonly ExpressionFunctionCallArguments = (): Expression[] | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    // \"Exclude\" requires the rule to succeed, but causes actual comma string to be excluded from the list of results\n    const commas: ParseRule = this.Exclude(this.String(\",\"));\n    let args = this.Interleave<Expression>(this.Expression, commas);\n    if (args === null) {\n      args = [];\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\")\"), \"closing ')' for function call\");\n\n    return args;\n  };\n\n  public readonly ExpressionVariableName = (): Expression | null => {\n    const path = this.Interleave<Identifier>(\n      this.IdentifierWithMetadata,\n      this.Exclude(this.Spaced(this.String(\".\")))\n    );\n\n    if (path === null || Story.IsReservedKeyword(path[0].name)) {\n      return null;\n    }\n\n    return new VariableReference(path);\n  };\n\n  public readonly ExpressionParen = (): Expression | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    const innerExpr = this.Parse(this.Expression) as Expression;\n    if (innerExpr === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\")\"), \"closing parenthesis ')' for expression\");\n\n    return innerExpr;\n  };\n\n  public readonly ExpressionInfixRight = (\n    left: Expression | null,\n    op: InfixOperator\n  ) => {\n    if (!left) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const right = this.Parse(() =>\n      this.Expression(op.precedence)\n    ) as Expression;\n    if (right) {\n      // We assume that the character we use for the operator's type is the same\n      // as that used internally by e.g. Runtime.Expression.Add, Runtime.Expression.Multiply etc\n      const expr = new BinaryExpression(left, right, op.type);\n      return expr;\n    }\n\n    return null;\n  };\n\n  private readonly ParseInfixOperator = (): InfixOperator | null => {\n    for (const op of this._binaryOperators) {\n      const ruleId: number = this.BeginRule();\n\n      if (this.ParseString(op.type) !== null) {\n        if (op.requireWhitespace) {\n          if (this.Whitespace() === null) {\n            this.FailRule(ruleId);\n\n            continue;\n          }\n        }\n\n        return this.SucceedRule(ruleId, op) as InfixOperator;\n      }\n\n      this.FailRule(ruleId);\n    }\n\n    return null;\n  };\n\n  public readonly ExpressionList = (): List | null => {\n    this.Whitespace();\n\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // When list has:\n    //  - 0 elements (null list) - this is okay, it's an empty list: \"()\"\n    //  - 1 element - it could be confused for a single non-list related\n    //    identifier expression in brackets, but this is a useless thing\n    //    to do, so we reserve that syntax for a list with one item.\n    //  - 2 or more elements - normal!\n    const memberNames: Identifier[] = this.SeparatedList(\n      this.ListMember,\n      this.Spaced(this.String(\",\"))\n    ) as Identifier[];\n\n    this.Whitespace();\n\n    // May have failed to parse the inner list - the parentheses may\n    // be for a normal expression\n    if (this.ParseString(\")\") === null) {\n      return null;\n    }\n    return new List(memberNames);\n  };\n\n  public readonly ListMember = (): Identifier | null => {\n    this.Whitespace();\n\n    let identifier: Identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier;\n    if (identifier === null) {\n      return null;\n    }\n\n    const dot = this.ParseString(\".\");\n    if (dot !== null) {\n      const identifier2: Identifier = this.Expect(\n        this.IdentifierWithMetadata,\n        `element name within the set ${identifier}`\n      ) as Identifier;\n\n      identifier.name += `.${identifier2?.name}`;\n    }\n\n    this.Whitespace();\n\n    return identifier;\n  };\n\n  public readonly RegisterExpressionOperators = () => {\n    // These will be tried in order, so we need \"<=\" before \"<\"\n    // for correctness\n\n    this.RegisterBinaryOperator(\"&&\", 1);\n    this.RegisterBinaryOperator(\"||\", 1);\n    this.RegisterBinaryOperator(\"and\", 1, true);\n    this.RegisterBinaryOperator(\"or\", 1, true);\n    this.RegisterBinaryOperator(\"==\", 2);\n    this.RegisterBinaryOperator(\">=\", 2);\n    this.RegisterBinaryOperator(\"<=\", 2);\n    this.RegisterBinaryOperator(\"<\", 2);\n    this.RegisterBinaryOperator(\">\", 2);\n    this.RegisterBinaryOperator(\"!=\", 2);\n\n    // (apples, oranges) + cabbages has (oranges, cabbages) === true\n    this.RegisterBinaryOperator(\"?\", 3);\n    this.RegisterBinaryOperator(\"has\", 3, true);\n    this.RegisterBinaryOperator(\"!?\", 3);\n    this.RegisterBinaryOperator(\"hasnt\", 3, true);\n    this.RegisterBinaryOperator(\"^\", 3);\n\n    this.RegisterBinaryOperator(\"+\", 4);\n    this.RegisterBinaryOperator(\"-\", 5);\n    this.RegisterBinaryOperator(\"*\", 6);\n    this.RegisterBinaryOperator(\"/\", 7);\n\n    this.RegisterBinaryOperator(\"%\", 8);\n    this.RegisterBinaryOperator(\"mod\", 8, true);\n  };\n\n  public readonly RegisterBinaryOperator = (\n    op: string,\n    precedence: number,\n    requireWhitespace: boolean = false\n  ): void => {\n    const infix = new InfixOperator(op, precedence, requireWhitespace);\n    this._binaryOperators.push(infix);\n    this._maxBinaryOpLength = Math.max(this._maxBinaryOpLength, op.length);\n  };\n\n  /**\n   * End Expressions section.\n   */\n\n  /**\n   * Begin Include section.\n   */\n\n  private _rootParser: InkParser;\n  private _openFilenames: string[] = [];\n\n  public readonly IncludeStatement = () => {\n    this.Whitespace();\n\n    if (this.ParseString(\"INCLUDE\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    let filename: string = this.Expect(\n      () => this.ParseUntilCharactersFromString(\"\\n\\r\"),\n      \"filename for include statement\"\n    ) as string;\n\n    filename = filename.replace(new RegExp(/[ \\t]+$/g), \"\");\n\n    // Working directory should already have been set up relative to the root ink file.\n    const fullFilename = this.fileHandler.ResolveInkFilename(filename);\n\n    if (this.FilenameIsAlreadyOpen(fullFilename)) {\n      this.Error(\n        `Recursive INCLUDE detected: '${fullFilename}' is already open.`\n      );\n      this.ParseUntilCharactersFromString(\"\\r\\n\");\n      return new IncludedFile(null);\n    } else {\n      this.AddOpenFilename(fullFilename);\n    }\n\n    let includedStory: Story | null = null;\n    let includedString: string = \"\";\n    try {\n      includedString =\n        this._rootParser.fileHandler.LoadInkFileContents(fullFilename);\n    } catch (err) {\n      this.Error(`Failed to load: '${filename}'.\\nError:${err}`);\n    }\n\n    if (includedString) {\n      const parser: InkParser = new InkParser(\n        includedString,\n        filename,\n        this._externalErrorHandler,\n        this._rootParser,\n        this.fileHandler\n      );\n\n      includedStory = parser.ParseStory();\n    }\n\n    this.RemoveOpenFilename(fullFilename);\n\n    // Return valid IncludedFile object even if there were errors when parsing.\n    // We don't want to attempt to re-parse the include line as something else,\n    // and we want to include the bits that *are* valid, so we don't generate\n    // more errors than necessary.\n    return new IncludedFile(includedStory);\n  };\n\n  public readonly FilenameIsAlreadyOpen = (fullFilename: string): boolean =>\n    this._rootParser._openFilenames.includes(fullFilename);\n\n  public readonly AddOpenFilename = (fullFilename: string): void => {\n    this._rootParser._openFilenames.push(fullFilename);\n  };\n\n  public readonly RemoveOpenFilename = (fullFilename: string) => {\n    this._rootParser._openFilenames.splice(\n      this._rootParser._openFilenames.indexOf(fullFilename),\n      1\n    );\n  };\n\n  /**\n   * End Include section.\n   */\n\n  /**\n   * Begin Knot section.\n   */\n\n  public readonly KnotDefinition = (): Knot | null => {\n    const knotDecl: FlowDecl = this.Parse(this.KnotDeclaration) as FlowDecl;\n    if (knotDecl === null) {\n      return null;\n    }\n\n    this.Expect(\n      this.EndOfLine,\n      \"end of line after knot name definition\",\n      this.SkipToNextLine\n    );\n\n    const innerKnotStatements: ParseRule = (): ParsedObject[] =>\n      this.StatementsAtLevel(StatementLevel.Knot);\n\n    const content = this.Expect(\n      innerKnotStatements,\n      \"at least one line within the knot\",\n      this.KnotStitchNoContentRecoveryRule\n    ) as ParsedObject[];\n\n    return new Knot(knotDecl.name, content, knotDecl.args, knotDecl.isFunction);\n  };\n\n  public readonly KnotDeclaration = (): FlowDecl | null => {\n    this.Whitespace();\n\n    if (this.KnotTitleEquals() === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const identifier: Identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier;\n    let knotName: Identifier;\n\n    const isFunc: boolean = identifier?.name === \"function\";\n    if (isFunc) {\n      this.Expect(this.Whitespace, \"whitespace after the 'function' keyword\");\n\n      knotName = this.Parse(this.IdentifierWithMetadata) as Identifier;\n    } else {\n      knotName = identifier;\n    }\n\n    if (knotName === null) {\n      this.Error(`Expected the name of the ${isFunc ? \"function\" : \"knot\"}`);\n      knotName = new Identifier(\"\"); // prevent later null ref\n    }\n\n    this.Whitespace();\n\n    const parameterNames: Argument[] = this.Parse(\n      this.BracketedKnotDeclArguments\n    ) as Argument[];\n\n    this.Whitespace();\n\n    // Optional equals after name\n    this.Parse(this.KnotTitleEquals);\n\n    return new FlowDecl(knotName, parameterNames, isFunc);\n  };\n\n  public readonly KnotTitleEquals = (): string | null => {\n    // 2+ \"=\" starts a knot\n    const multiEquals = this.ParseCharactersFromString(\"=\");\n    if (multiEquals === null || multiEquals.length <= 1) {\n      return null;\n    }\n\n    return multiEquals;\n  };\n\n  public readonly StitchDefinition = (): ParseRuleReturn => {\n    const decl = this.Parse(this.StitchDeclaration) as FlowDecl;\n    if (decl === null) {\n      return null;\n    }\n\n    this.Expect(\n      this.EndOfLine,\n      \"end of line after stitch name\",\n      this.SkipToNextLine\n    );\n\n    const innerStitchStatements: ParseRule = () =>\n      this.StatementsAtLevel(StatementLevel.Stitch);\n\n    const content = this.Expect(\n      innerStitchStatements,\n      \"at least one line within the stitch\",\n      this.KnotStitchNoContentRecoveryRule\n    ) as ParsedObject[];\n\n    return new Stitch(decl.name, content, decl.args, decl.isFunction);\n  };\n\n  public readonly StitchDeclaration = (): FlowDecl | null => {\n    this.Whitespace();\n\n    // Single \"=\" to define a stitch\n    if (this.ParseString(\"=\") === null) {\n      return null;\n    }\n\n    // If there's more than one \"=\", that's actually a knot definition (or divert), so this rule should fail\n    if (this.ParseString(\"=\") !== null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // Stitches aren't allowed to be functions, but we parse it anyway and report the error later\n    const isFunc: boolean = this.ParseString(\"function\") !== null;\n    if (isFunc) {\n      this.Whitespace();\n    }\n\n    const stitchName: Identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier;\n    if (stitchName === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const flowArgs: Argument[] = this.Parse(\n      this.BracketedKnotDeclArguments\n    ) as Argument[];\n\n    this.Whitespace();\n\n    return new FlowDecl(stitchName, flowArgs, isFunc);\n  };\n\n  public readonly KnotStitchNoContentRecoveryRule = (): ParseRuleReturn => {\n    // Jump ahead to the next knot or the end of the file\n    this.ParseUntil(this.KnotDeclaration, new CharacterSet(\"=\"), null);\n\n    const recoveredFlowContent: ParsedObject[] = [new Text(\"<ERROR IN FLOW>\")];\n\n    return recoveredFlowContent;\n  };\n\n  public readonly BracketedKnotDeclArguments = (): Argument[] | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    let flowArguments = this.Interleave<Argument>(\n      this.Spaced(this.FlowDeclArgument),\n      this.Exclude(this.String(\",\"))\n    );\n\n    this.Expect(this.String(\")\"), \"closing ')' for parameter list\");\n\n    // If no parameters, create an empty list so that this method is type safe and\n    // doesn't attempt to return the ParseSuccess object\n    if (flowArguments === null) {\n      flowArguments = [];\n    }\n\n    return flowArguments;\n  };\n\n  public readonly FlowDeclArgument = (): Argument | null => {\n    // Possible forms:\n    //  name\n    //  -> name      (variable divert target argument\n    //  ref name\n    //  ref -> name  (variable divert target by reference)\n    const firstIden = this.Parse(this.IdentifierWithMetadata) as Identifier;\n    this.Whitespace();\n\n    const divertArrow = this.ParseDivertArrow();\n\n    this.Whitespace();\n\n    const secondIden = this.Parse(this.IdentifierWithMetadata) as Identifier;\n\n    if (firstIden == null && secondIden === null) {\n      return null;\n    }\n\n    const flowArg = new Argument();\n    if (divertArrow !== null) {\n      flowArg.isDivertTarget = true;\n    }\n\n    // Passing by reference\n    if (firstIden !== null && firstIden.name === \"ref\") {\n      if (secondIden === null) {\n        this.Error(\"Expected an parameter name after 'ref'\");\n      }\n\n      flowArg.identifier = secondIden;\n      flowArg.isByReference = true;\n    } else {\n      // Simple argument name\n      if (flowArg.isDivertTarget) {\n        flowArg.identifier = secondIden;\n      } else {\n        flowArg.identifier = firstIden;\n      }\n\n      if (flowArg.identifier === null) {\n        this.Error(\"Expected an parameter name\");\n      }\n\n      flowArg.isByReference = false;\n    }\n\n    return flowArg;\n  };\n\n  public readonly ExternalDeclaration = (): ExternalDeclaration | null => {\n    this.Whitespace();\n\n    const external = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier | null;\n    if (external === null || external.name != \"EXTERNAL\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const funcIdentifier: Identifier =\n      (this.Expect(\n        this.IdentifierWithMetadata,\n        \"name of external function\"\n      ) as Identifier | null) || new Identifier(\"\");\n\n    this.Whitespace();\n\n    let parameterNames = this.Expect(\n      this.BracketedKnotDeclArguments,\n      `declaration of arguments for EXTERNAL, even if empty, i.e. 'EXTERNAL ${funcIdentifier}()'`\n    ) as Argument[];\n\n    if (parameterNames === null) {\n      parameterNames = [];\n    }\n\n    const argNames = parameterNames\n      .map((arg) => arg.identifier?.name)\n      .filter(filterUndef);\n\n    return new ExternalDeclaration(funcIdentifier, argNames);\n  };\n\n  /**\n   * End Knot section.\n   */\n\n  /**\n   * Start Logic section.\n   */\n\n  private _identifierCharSet: CharacterSet | null = null;\n\n  get identifierCharSet(): CharacterSet {\n    if (this._identifierCharSet === null) {\n      (this._identifierCharSet = new CharacterSet())\n        .AddRange(\"A\", \"Z\")\n        .AddRange(\"a\", \"z\")\n        .AddRange(\"0\", \"9\")\n        .Add(\"_\");\n\n      // Enable non-ASCII characters for story identifiers.\n      this.ExtendIdentifierCharacterRanges(this._identifierCharSet);\n    }\n\n    return this._identifierCharSet;\n  }\n\n  public readonly LogicLine = (): ParsedObject | null => {\n    this.Whitespace();\n\n    if (this.ParseString(\"~\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // Some example lines we need to be able to distinguish between:\n    // ~ temp x = 5  -- var decl + assign\n    // ~ temp x      -- var decl\n    // ~ x = 5       -- var assign\n    // ~ x           -- expr (not var decl or assign)\n    // ~ f()         -- expr\n    // We don't treat variable decl/assign as an expression since we don't want an assignment\n    // to have a return value, or to be used in compound expressions.\n    const afterTilde: ParseRule = () =>\n      this.OneOf([\n        this.ReturnStatement,\n        this.TempDeclarationOrAssignment,\n        this.Expression,\n      ]);\n\n    let result = this.Expect(\n      afterTilde,\n      \"expression after '~'\",\n      this.SkipToNextLine\n    ) as ParsedObject;\n\n    // Prevent further errors, already reported expected expression and have skipped to next line.\n    if (result === null) {\n      return new ContentList();\n    }\n\n    // Parse all expressions, but tell the writer off if they did something useless like:\n    //  ~ 5 + 4\n    // And even:\n    //  ~ false && myFunction()\n    // ...since it's bad practice, and won't do what they expect if\n    // they're expecting C's lazy evaluation.\n    if (\n      result instanceof Expression &&\n      !(result instanceof FunctionCall || result instanceof IncDecExpression)\n    ) {\n      this.Error(\n        \"Logic following a '~' can't be that type of expression. It can only be something like:\\n\\t~ return\\n\\t~ var x = blah\\n\\t~ x++\\n\\t~ myFunction()\"\n      );\n    }\n\n    // Line is pure function call? e.g.\n    //  ~ f()\n    // Add extra pop to make sure we tidy up after ourselves.\n    // We no longer need anything on the evaluation stack.\n    const funCall = asOrNull(result, FunctionCall);\n    if (funCall) {\n      funCall.shouldPopReturnedValue = true;\n    }\n\n    // If the expression contains a function call, then it could produce a text side effect,\n    // in which case it needs a newline on the end. e.g.\n    //  ~ printMyName()\n    //  ~ x = 1 + returnAValueAndAlsoPrintStuff()\n    // If no text gets printed, then the extra newline will have to be culled later.\n    // Multiple newlines on the output will be removed, so there will be no \"leak\" for\n    // long running calculations. It's disappointingly messy though :-/\n    if (result.Find(FunctionCall)() !== null) {\n      result = new ContentList(result as any, new Text(\"\\n\"));\n    }\n\n    this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n\n    return result as ParsedObject;\n  };\n\n  public readonly VariableDeclaration = (): ParsedObject | null => {\n    this.Whitespace();\n\n    const id = this.Parse(this.Identifier);\n    if (id !== \"VAR\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const varName = this.Expect(\n      this.IdentifierWithMetadata,\n      \"variable name\"\n    ) as Identifier;\n\n    this.Whitespace();\n\n    this.Expect(\n      this.String(\"=\"),\n      \"the '=' for an assignment of a value, e.g. '= 5' (initial values are mandatory)\"\n    );\n\n    this.Whitespace();\n\n    const definition = this.Expect(this.Expression, \"initial value for \");\n\n    const expr = definition as Expression;\n\n    if (expr) {\n      const check =\n        expr instanceof NumberExpression ||\n        expr instanceof StringExpression ||\n        expr instanceof DivertTarget ||\n        expr instanceof VariableReference ||\n        expr instanceof List;\n\n      if (!check) {\n        this.Error(\n          \"initial value for a variable must be a number, constant, list or divert target\"\n        );\n      }\n\n      if (this.Parse(this.ListElementDefinitionSeparator) !== null) {\n        this.Error(\n          \"Unexpected ','. If you're trying to declare a new list, use the LIST keyword, not VAR\"\n        );\n      } else if (expr instanceof StringExpression) {\n        // Ensure string expressions are simple\n        const strExpr = expr as StringExpression;\n        if (!strExpr.isSingleString) {\n          this.Error(\"Constant strings cannot contain any logic.\");\n        }\n      }\n\n      const result = new VariableAssignment({\n        assignedExpression: expr,\n        isGlobalDeclaration: true,\n        variableIdentifier: varName,\n      });\n\n      return result;\n    }\n\n    return null;\n  };\n\n  public readonly ListDeclaration = (): VariableAssignment | null => {\n    this.Whitespace();\n\n    const id = this.Parse(this.Identifier);\n    if (id != \"LIST\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const varName = this.Expect(\n      this.IdentifierWithMetadata,\n      \"list name\"\n    ) as Identifier;\n\n    this.Whitespace();\n\n    this.Expect(\n      this.String(\"=\"),\n      \"the '=' for an assignment of the list definition\"\n    );\n\n    this.Whitespace();\n\n    const definition = this.Expect(\n      this.ListDefinition,\n      \"list item names\"\n    ) as ListDefinition;\n\n    if (definition) {\n      definition.identifier = new Identifier(varName.name);\n      return new VariableAssignment({\n        variableIdentifier: varName,\n        listDef: definition,\n      });\n    }\n\n    return null;\n  };\n\n  public readonly ListDefinition = (): ListDefinition | null => {\n    this.AnyWhitespace();\n\n    const allElements = this.SeparatedList(\n      this.ListElementDefinition,\n      this.ListElementDefinitionSeparator\n    ) as ListElementDefinition[];\n\n    if (allElements === null) {\n      return null;\n    }\n\n    return new ListDefinition(allElements);\n  };\n\n  public readonly ListElementDefinitionSeparator = (): string | null => {\n    this.AnyWhitespace();\n\n    if (this.ParseString(\",\") === null) {\n      return null;\n    }\n\n    this.AnyWhitespace();\n\n    return \",\";\n  };\n\n  public readonly ListElementDefinition = () => {\n    const inInitialList = this.ParseString(\"(\") !== null;\n    let needsToCloseParen = inInitialList;\n\n    this.Whitespace();\n\n    const name = this.Parse(this.IdentifierWithMetadata) as Identifier | null;\n    if (name === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    if (inInitialList) {\n      if (this.ParseString(\")\") != null) {\n        needsToCloseParen = false;\n        this.Whitespace();\n      }\n    }\n\n    let elementValue: number | null = null;\n    if (this.ParseString(\"=\") !== null) {\n      this.Whitespace();\n\n      const elementValueNum = this.Expect(\n        this.ExpressionInt,\n        \"value to be assigned to list item\"\n      ) as NumberExpression;\n\n      if (elementValueNum !== null) {\n        elementValue = elementValueNum.value as number;\n      }\n\n      if (needsToCloseParen) {\n        this.Whitespace();\n\n        if (this.ParseString(\")\") !== null) {\n          needsToCloseParen = false;\n        }\n      }\n    }\n\n    if (needsToCloseParen) {\n      this.Error(\"Expected closing ')'\");\n    }\n\n    return new ListElementDefinition(name, inInitialList, elementValue);\n  };\n\n  public readonly ConstDeclaration = (): ParsedObject | null => {\n    this.Whitespace();\n\n    const id = this.Parse(this.Identifier);\n    if (id !== \"CONST\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const varName = this.Expect(\n      this.IdentifierWithMetadata,\n      \"constant name\"\n    ) as Identifier;\n\n    this.Whitespace();\n\n    this.Expect(\n      this.String(\"=\"),\n      \"the '=' for an assignment of a value, e.g. '= 5' (initial values are mandatory)\"\n    );\n\n    this.Whitespace();\n\n    const expr = this.Expect(\n      this.Expression,\n      \"initial value for \"\n    ) as Expression;\n\n    const check =\n      expr instanceof NumberExpression ||\n      expr instanceof DivertTarget ||\n      expr instanceof StringExpression;\n\n    if (!check) {\n      this.Error(\n        \"initial value for a constant must be a number or divert target\"\n      );\n    } else if (expr instanceof StringExpression) {\n      // Ensure string expressions are simple\n      const strExpr = expr as StringExpression;\n      if (!strExpr.isSingleString) {\n        this.Error(\"Constant strings cannot contain any logic.\");\n      }\n    }\n\n    const result = new ConstantDeclaration(varName, expr);\n\n    return result;\n  };\n\n  public readonly InlineLogicOrGlueOrStartTag = (): ParsedObject =>\n    this.OneOf([this.InlineLogic, this.Glue, this.StartTag]) as ParsedObject;\n\n  public readonly Glue = (): Glue | null => {\n    // Don't want to parse whitespace, since it might be important\n    // surrounding the glue.\n    const glueStr = this.ParseString(\"<>\");\n    if (glueStr !== null) {\n      return new Glue(new RuntimeGlue());\n    }\n\n    return null;\n  };\n\n  public readonly InlineLogic = () => {\n    if (this.ParseString(\"{\") === null) {\n      return null;\n    }\n\n    let wasParsingString = this.parsingStringExpression;\n    let wasTagActive = this.tagActive;\n\n    this.Whitespace();\n\n    const logic = this.Expect(\n      this.InnerLogic,\n      \"some kind of logic, conditional or sequence within braces: { ... }\"\n    ) as ParsedObject;\n\n    if (logic === null) {\n      this.parsingStringExpression = wasParsingString;\n      return null;\n    }\n\n    this.DisallowIncrement(logic);\n\n    let contentList = asOrNull(logic, ContentList);\n    if (!contentList) {\n      contentList = new ContentList(logic as any);\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\"}\"), \"closing brace '}' for inline logic\");\n\n    // Allow nested strings and logic\n    this.parsingStringExpression = wasParsingString;\n\n    // Difference between:\n    //\n    //     1) A thing # {image}.jpg\n    //     2) A {red #red|blue #blue} sequence.\n    //\n    //  When logic ends in (1) we still want tag to continue.\n    //  When logic ends in (2) we want to auto-end the tag.\n    //  Side note: we simply disallow tags within strings.\n    if (!wasTagActive) this.EndTagIfNecessary(contentList);\n\n    return contentList;\n  };\n\n  public readonly InnerLogic = (): ParsedObject | null => {\n    this.Whitespace();\n\n    // Explicitly try the combinations of inner logic\n    // that could potentially have conflicts first.\n\n    // Explicit sequence annotation?\n    const explicitSeqType: SequenceType = this.ParseObject(\n      this.SequenceTypeAnnotation\n    ) as SequenceType;\n\n    if (explicitSeqType !== null) {\n      const contentLists = this.Expect(\n        this.InnerSequenceObjects,\n        \"sequence elements (for cycle/stoping etc)\"\n      ) as ContentList[];\n\n      if (contentLists === null) {\n        return null;\n      }\n\n      return new Sequence(contentLists, explicitSeqType);\n    }\n\n    // Conditional with expression?\n    const initialQueryExpression = this.Parse(\n      this.ConditionExpression\n    ) as Expression;\n    if (initialQueryExpression) {\n      const conditional = this.Expect(\n        () => this.InnerConditionalContent(initialQueryExpression),\n        \"conditional content following query\"\n      ) as Conditional;\n\n      return conditional;\n    }\n\n    // Now try to evaluate each of the \"full\" rules in turn\n    const rules: ParseRule[] = [\n      // Conditional still necessary, since you can have a multi-line conditional\n      // without an initial query expression:\n      // {\n      //   - true:  this is true\n      //   - false: this is false\n      // }\n      this.InnerConditionalContent as ParseRule,\n      this.InnerSequence,\n      this.InnerExpression,\n    ];\n\n    let wasTagActiveAtStartOfScope = this.tagActive;\n\n    // Adapted from \"OneOf\" structuring rule except that in\n    // order for the rule to succeed, it has to maximally\n    // cover the entire string within the { }. Used to\n    // differentiate between:\n    //  {myVar}                 -- Expression (try first)\n    //  {my content is jolly}   -- sequence with single element\n    for (const rule of rules) {\n      const ruleId: number = this.BeginRule();\n\n      const result: ParsedObject = this.ParseObject(rule) as ParsedObject;\n      if (result) {\n        // Not yet at end?\n        if (this.Peek(this.Spaced(this.String(\"}\"))) === null) {\n          this.FailRule(ruleId);\n        } else {\n          // Full parse of content within braces\n          return this.SucceedRule(ruleId, result) as ParsedObject;\n        }\n      } else {\n        this.FailRule(ruleId);\n      }\n    }\n\n    return null;\n  };\n\n  public readonly InnerExpression = (): ParsedObject => {\n    const expr = this.Parse(this.Expression) as Expression;\n    if (expr) {\n      expr.outputWhenComplete = true;\n    }\n\n    return expr;\n  };\n\n  public readonly IdentifierWithMetadata = (): Identifier | null => {\n    const id = this.Identifier();\n    if (id === null) {\n      return null;\n    }\n    return new Identifier(id);\n  };\n\n  // Note: we allow identifiers that start with a number,\n  // but not if they *only* comprise numbers\n  public readonly Identifier = (): string | null => {\n    // Parse remaining characters (if any)\n    const name = this.ParseCharactersFromCharSet(this.identifierCharSet);\n    if (name === null) {\n      return null;\n    }\n\n    // Reject if it's just a number\n    let isNumberCharsOnly: boolean = true;\n    for (let c of name) {\n      if (!(c >= \"0\" && c <= \"9\")) {\n        isNumberCharsOnly = false;\n        break;\n      }\n    }\n\n    if (isNumberCharsOnly) {\n      return null;\n    }\n\n    return name;\n  };\n\n  /**\n   * End Logic section.\n   */\n\n  /**\n   * Begin Sequences section.\n   */\n\n  public _sequenceTypeSymbols: CharacterSet = new CharacterSet(\"!&~$\");\n\n  public readonly InnerSequence = (): Sequence | null => {\n    this.Whitespace();\n\n    // Default sequence type\n    let seqType: SequenceType = SequenceType.Stopping;\n\n    // Optional explicit sequence type\n    const parsedSeqType: SequenceType = this.Parse(\n      this.SequenceTypeAnnotation\n    ) as SequenceType;\n\n    if (parsedSeqType !== null) {\n      seqType = parsedSeqType;\n    }\n\n    const contentLists = this.Parse(this.InnerSequenceObjects) as ContentList[];\n    if (contentLists === null || contentLists.length <= 1) {\n      return null;\n    }\n\n    return new Sequence(contentLists, seqType);\n  };\n\n  public readonly SequenceTypeAnnotation = (): ParseRuleReturn => {\n    let annotation = this.Parse(\n      this.SequenceTypeSymbolAnnotation\n    ) as SequenceType;\n\n    if (annotation === null) {\n      annotation = this.Parse(this.SequenceTypeWordAnnotation) as SequenceType;\n    }\n\n    if (annotation === null) {\n      return null;\n    }\n\n    switch (annotation) {\n      case SequenceType.Once:\n      case SequenceType.Cycle:\n      case SequenceType.Stopping:\n      case SequenceType.Shuffle:\n      case SequenceType.Shuffle | SequenceType.Stopping:\n      case SequenceType.Shuffle | SequenceType.Once:\n        break;\n      default:\n        this.Error(`Sequence type combination not supported: ${annotation}`);\n        return SequenceType.Stopping;\n    }\n\n    return annotation;\n  };\n\n  public readonly SequenceTypeSymbolAnnotation = (): ParseRuleReturn => {\n    if (this._sequenceTypeSymbols === null) {\n      this._sequenceTypeSymbols = new CharacterSet(\"!&~$ \");\n    }\n\n    let sequenceType = 0 as SequenceType;\n    const sequenceAnnotations = this.ParseCharactersFromCharSet(\n      this._sequenceTypeSymbols\n    );\n\n    if (sequenceAnnotations === null) {\n      return null;\n    }\n\n    for (const symbolChar of sequenceAnnotations) {\n      switch (symbolChar) {\n        case \"!\":\n          sequenceType |= SequenceType.Once;\n          break;\n        case \"&\":\n          sequenceType |= SequenceType.Cycle;\n          break;\n        case \"~\":\n          sequenceType |= SequenceType.Shuffle;\n          break;\n        case \"$\":\n          sequenceType |= SequenceType.Stopping;\n          break;\n      }\n    }\n\n    if (sequenceType === (0 as SequenceType)) {\n      return null;\n    }\n\n    return sequenceType;\n  };\n\n  public readonly SequenceTypeWordAnnotation = (): ParseRuleReturn => {\n    const sequenceTypes = this.Interleave<SequenceType | null>(\n      this.SequenceTypeSingleWord,\n      this.Exclude(this.Whitespace)\n    );\n\n    if (sequenceTypes === null || sequenceTypes.length === 0) {\n      return null;\n    }\n\n    if (this.ParseString(\":\") === null) {\n      return null;\n    }\n\n    let combinedSequenceType = 0 as SequenceType;\n    for (const seqType of sequenceTypes) {\n      combinedSequenceType |= seqType!;\n    }\n\n    return combinedSequenceType;\n  };\n\n  public readonly SequenceTypeSingleWord = () => {\n    let seqType: SequenceType | null = null;\n\n    const word = this.Parse(this.IdentifierWithMetadata) as Identifier | null;\n\n    if (word !== null) {\n      switch (word.name) {\n        case \"once\":\n          seqType = SequenceType.Once;\n          break;\n        case \"cycle\":\n          seqType = SequenceType.Cycle;\n          break;\n        case \"shuffle\":\n          seqType = SequenceType.Shuffle;\n          break;\n        case \"stopping\":\n          seqType = SequenceType.Stopping;\n          break;\n      }\n    }\n\n    if (seqType === null) {\n      return null;\n    }\n\n    return seqType;\n  };\n\n  public readonly InnerSequenceObjects = (): ContentList[] => {\n    const multiline = this.Parse(this.Newline) !== null;\n\n    let result: ContentList[] | null = null;\n    if (multiline) {\n      result = this.Parse(this.InnerMultilineSequenceObjects) as ContentList[];\n    } else {\n      result = this.Parse(this.InnerInlineSequenceObjects) as ContentList[];\n    }\n\n    return result;\n  };\n\n  public readonly InnerInlineSequenceObjects = (): ContentList[] | null => {\n    const interleavedContentAndPipes = this.Interleave<ParsedObject>(\n      this.Optional(this.MixedTextAndLogic),\n      this.String(\"|\"),\n      null,\n      false\n    );\n\n    if (interleavedContentAndPipes === null) {\n      return null;\n    }\n\n    const result = [];\n\n    // The content and pipes won't necessarily be perfectly interleaved in the sense that\n    // the content can be missing, but in that case it's intended that there's blank content.\n    let justHadContent: boolean = false;\n    for (const contentOrPipe of interleavedContentAndPipes) {\n      // Pipe/separator\n      if ((contentOrPipe as any) === \"|\") {\n        // Expected content, saw pipe - need blank content now\n        if (!justHadContent) {\n          // Add blank content\n          result.push(new ContentList());\n        }\n\n        justHadContent = false;\n      } else {\n        // Real content\n        const content = contentOrPipe as any;\n        if (content === null) {\n          this.Error(\n            `Expected content, but got ${contentOrPipe} (this is an ink compiler bug!)`\n          );\n        } else {\n          result.push(new ContentList(content));\n        }\n\n        justHadContent = true;\n      }\n    }\n\n    // Ended in a pipe? Need to insert final blank content\n    if (!justHadContent) {\n      result.push(new ContentList());\n    }\n\n    return result;\n  };\n\n  public readonly InnerMultilineSequenceObjects = (): ContentList[] | null => {\n    this.MultilineWhitespace();\n\n    const contentLists = this.OneOrMore(\n      this.SingleMultilineSequenceElement\n    ) as ContentList[];\n    if (contentLists === null) {\n      return null;\n    }\n\n    return contentLists;\n  };\n\n  public readonly SingleMultilineSequenceElement = () => {\n    this.Whitespace();\n\n    // Make sure we're not accidentally parsing a divert\n    if (this.ParseString(\"->\") !== null) {\n      return null;\n    }\n\n    if (this.ParseString(\"-\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const content: ParsedObject[] = this.StatementsAtLevel(\n      StatementLevel.InnerBlock\n    );\n\n    if (content === null) {\n      this.MultilineWhitespace();\n    } else {\n      // Add newline at the start of each branch\n      content.unshift(new Text(\"\\n\"));\n    }\n\n    return new ContentList(content);\n  };\n\n  /**\n   * End Sequences section.\n   */\n\n  /**\n   * Begin Statements section.\n   */\n\n  private _statementRulesAtLevel: ParseRule[][] = [];\n  private _statementBreakRulesAtLevel: ParseRule[][] = [];\n\n  public readonly StatementsAtLevel = (\n    level: StatementLevel\n  ): ParsedObject[] => {\n    // Check for error: Should not be allowed gather dashes within an inner block\n    if (level === StatementLevel.InnerBlock) {\n      const badGatherDashCount = this.Parse(this.GatherDashes) as ParsedObject;\n      if (badGatherDashCount !== null) {\n        this.Error(\n          \"You can't use a gather (the dashes) within the { curly braces } context. For multi-line sequences and conditions, you should only use one dash.\"\n        );\n      }\n    }\n\n    return this.Interleave<ParsedObject>(\n      this.Optional(this.MultilineWhitespace),\n      () => this.StatementAtLevel(level),\n      () => this.StatementsBreakForLevel(level)\n    );\n  };\n\n  public readonly StatementAtLevel = (level: StatementLevel): ParsedObject => {\n    const rulesAtLevel: ParseRule[] =\n      this._statementRulesAtLevel[level as number];\n    const statement = this.OneOf(rulesAtLevel) as ReturnType;\n\n    // For some statements, allow them to parse, but create errors, since\n    // writers may think they can use the statement, so it's useful to have\n    // the error message.\n    if (level === StatementLevel.Top) {\n      if (statement instanceof ReturnType) {\n        this.Error(\"should not have return statement outside of a knot\");\n      }\n    }\n\n    return statement;\n  };\n\n  public readonly StatementsBreakForLevel = (\n    level: StatementLevel\n  ): ParseRuleReturn => {\n    this.Whitespace();\n\n    const breakRules: ParseRule[] =\n      this._statementBreakRulesAtLevel[level as number];\n    const breakRuleResult = this.OneOf(breakRules);\n    if (breakRuleResult === null) {\n      return null;\n    }\n\n    return breakRuleResult;\n  };\n\n  public readonly GenerateStatementLevelRules = () => {\n    const levels = Object.values(StatementLevel);\n\n    this._statementRulesAtLevel = \"f\"\n      .repeat(levels.length)\n      .split(\"f\")\n      .map(() => []);\n\n    this._statementBreakRulesAtLevel = \"f\"\n      .repeat(levels.length)\n      .split(\"f\")\n      .map(() => []);\n\n    for (const level of levels) {\n      const rulesAtLevel: ParseRule[] = [];\n      const breakingRules: ParseRule[] = [];\n\n      // Diverts can go anywhere\n      rulesAtLevel.push(this.Line(this.MultiDivert));\n\n      // Knots can only be parsed at Top/Global scope\n      if (level >= StatementLevel.Top) {\n        rulesAtLevel.push(this.KnotDefinition);\n      }\n\n      rulesAtLevel.push(this.Line(this.Choice));\n\n      rulesAtLevel.push(this.Line(this.AuthorWarning));\n\n      // Gather lines would be confused with multi-line block separators, like\n      // within a multi-line if statement\n      if (level > StatementLevel.InnerBlock) {\n        rulesAtLevel.push(this.Gather);\n      }\n\n      // Stitches (and gathers) can (currently) only go in Knots and top level\n      if (level >= StatementLevel.Knot) {\n        rulesAtLevel.push(this.StitchDefinition);\n      }\n\n      // Global variable declarations can go anywhere\n      rulesAtLevel.push(this.Line(this.ListDeclaration));\n      rulesAtLevel.push(this.Line(this.VariableDeclaration));\n      rulesAtLevel.push(this.Line(this.ConstDeclaration));\n      rulesAtLevel.push(this.Line(this.ExternalDeclaration));\n\n      // Global include can go anywhere\n      rulesAtLevel.push(this.Line(this.IncludeStatement));\n\n      // Normal logic / text can go anywhere\n      rulesAtLevel.push(this.LogicLine);\n      rulesAtLevel.push(this.LineOfMixedTextAndLogic);\n\n      // --------\n      // Breaking rules\n\n      // Break current knot with a new knot\n      if (level <= StatementLevel.Knot) {\n        breakingRules.push(this.KnotDeclaration);\n      }\n\n      // Break current stitch with a new stitch\n      if (level <= StatementLevel.Stitch) {\n        breakingRules.push(this.StitchDeclaration);\n      }\n\n      // Breaking an inner block (like a multi-line condition statement)\n      if (level <= StatementLevel.InnerBlock) {\n        breakingRules.push(this.ParseDashNotArrow);\n        breakingRules.push(this.String(\"}\"));\n      }\n\n      this._statementRulesAtLevel[level as number] = rulesAtLevel;\n      this._statementBreakRulesAtLevel[level as number] = breakingRules;\n    }\n  };\n\n  public readonly SkipToNextLine = (): typeof ParseSuccess => {\n    this.ParseUntilCharactersFromString(\"\\n\\r\");\n    this.ParseNewline();\n\n    return ParseSuccess;\n  };\n\n  // Modifier to turn a rule into one that expects a newline on the end.\n  // e.g. anywhere you can use \"MixedTextAndLogic\" as a rule, you can use\n  // \"Line(MixedTextAndLogic)\" to specify that it expects a newline afterwards.\n  public readonly Line =\n    (inlineRule: ParseRule): ParseRule =>\n    () => {\n      const result = this.ParseObject(inlineRule);\n      if (result === null) {\n        return null;\n      }\n\n      this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n\n      return result;\n    };\n\n  /**\n   * End Statements section.\n   */\n\n  /**\n   * Begin Tags section.\n   */\n\n  public readonly StartTag = (): ParsedObject | null => {\n    this.Whitespace();\n\n    if (this.ParseString(\"#\") === null) {\n      return null;\n    }\n\n    if (this.parsingStringExpression) {\n      this.Error(\n        \"Tags aren't allowed inside of strings. Please use \\\\# if you want a hash symbol.\"\n      );\n    }\n\n    let result: ParsedObject | null = null;\n    if (this.tagActive) {\n      let contentList = new ContentList();\n      contentList.AddContent(new Tag(/*isStart:*/ false));\n      contentList.AddContent(new Tag(/*isStart:*/ true));\n      result = contentList;\n    } else {\n      result = new Tag(/*isStart:*/ true);\n    }\n    this.tagActive = true;\n\n    this.Whitespace();\n\n    return result;\n  };\n\n  public EndTagIfNecessary(outputContentList: ParsedObject[] | null): void;\n  public EndTagIfNecessary(outputContentList: ContentList | null): void;\n  public EndTagIfNecessary(\n    outputContentList: ParsedObject[] | ContentList | null\n  ): void {\n    if (this.tagActive) {\n      if (outputContentList != null) {\n        if (outputContentList instanceof ContentList) {\n          outputContentList.AddContent(new Tag(/*isStart:*/ false));\n        } else {\n          outputContentList.push(new Tag(/*isStart:*/ false));\n        }\n      }\n      this.tagActive = false;\n    }\n  }\n\n  /**\n   * End Tags section.\n   */\n\n  /**\n   * Begin Whitespace section.\n   */\n\n  private _inlineWhitespaceChars: CharacterSet = new CharacterSet(\" \\t\");\n\n  // Handles both newline and endOfFile\n  public readonly EndOfLine = () => this.OneOf([this.Newline, this.EndOfFile]);\n\n  // Allow whitespace before the actual newline\n  public readonly Newline = (): typeof ParseSuccess | null => {\n    this.Whitespace();\n\n    const gotNewline: boolean = this.ParseNewline() !== null;\n\n    // Optional \\r, definite \\n to support Windows (\\r\\n) and Mac/Unix (\\n)\n\n    if (!gotNewline) {\n      return null;\n    }\n\n    return ParseSuccess;\n  };\n\n  public readonly EndOfFile = (): typeof ParseSuccess | null => {\n    this.Whitespace();\n\n    if (!this.endOfInput) return null;\n\n    return ParseSuccess;\n  };\n\n  // General purpose space, returns N-count newlines (fails if no newlines)\n  public readonly MultilineWhitespace = (): typeof ParseSuccess | null => {\n    let newlines: ParseRuleReturn[] | null = this.OneOrMore(this.Newline);\n    if (newlines === null) {\n      return null;\n    }\n\n    // Use content field of Token to say how many newlines there were\n    // (in most circumstances it's unimportant)\n    const numNewlines: number = newlines.length;\n    if (numNewlines >= 1) {\n      return ParseSuccess;\n    }\n\n    return null;\n  };\n\n  public readonly Whitespace = (): typeof ParseSuccess | null => {\n    const doneParsed = this.ParseCharactersFromCharSet(\n      this._inlineWhitespaceChars\n    );\n\n    if (doneParsed !== null) {\n      return ParseSuccess;\n    }\n\n    return null;\n  };\n\n  public readonly Spaced =\n    (rule: ParseRule): ParseRule =>\n    () => {\n      this.Whitespace();\n\n      const result = this.ParseObject(rule);\n      if (result === null) {\n        return null;\n      }\n\n      this.Whitespace();\n\n      return result;\n    };\n\n  public readonly AnyWhitespace = (): typeof ParseSuccess | null => {\n    let anyWhitespace: boolean = false;\n\n    while (this.OneOf([this.Whitespace, this.MultilineWhitespace]) !== null) {\n      anyWhitespace = true;\n    }\n\n    return anyWhitespace ? ParseSuccess : null;\n  };\n\n  public readonly MultiSpaced =\n    (rule: ParseRule): ParseRuleReturn =>\n    () => {\n      this.AnyWhitespace();\n\n      const result = this.ParseObject(rule);\n      if (result === null) {\n        return null;\n      }\n\n      this.AnyWhitespace();\n\n      return result;\n    };\n\n  private _filename: string | null = null;\n  private _externalErrorHandler: ErrorHandler | null = null;\n  private _fileHandler: IFileHandler | null = null;\n\n  /**\n   * End Whitespace section.\n   */\n}\n","import { CompilerOptions } from \"./CompilerOptions\";\nimport { DebugSourceRange } from \"./DebugSourceRange\";\nimport { ErrorType } from \"./Parser/ErrorType\";\nimport { InkParser } from \"./Parser/InkParser\";\nimport { Story } from \"../engine/Story\";\nimport { Story as ParsedStory } from \"./Parser/ParsedHierarchy/Story\";\nimport { DebugMetadata } from \"../engine/DebugMetadata\";\nimport { StringValue } from \"../engine/Value\";\nimport { asOrNull } from \"../engine/TypeAssertion\";\n\nexport { CompilerOptions } from \"./CompilerOptions\";\nexport { InkParser } from \"./Parser/InkParser\";\nexport { StatementLevel } from \"./Parser/StatementLevel\";\nexport { JsonFileHandler } from \"./FileHandler/JsonFileHandler\";\nexport { InkList, Story } from \"../engine/Story\";\n\nexport class Compiler {\n  private _errors: string[] = [];\n  get errors(): string[] {\n    return this._errors;\n  }\n\n  private _warnings: string[] = [];\n  get warnings(): string[] {\n    return this._warnings;\n  }\n\n  private _authorMessages: string[] = [];\n  get authorMessages(): string[] {\n    return this._authorMessages;\n  }\n\n  private _inputString: string;\n  get inputString(): string {\n    return this._inputString;\n  }\n\n  private _options: CompilerOptions;\n  get options(): CompilerOptions {\n    return this._options;\n  }\n\n  private _parsedStory: ParsedStory | null = null;\n  get parsedStory(): ParsedStory {\n    if (!this._parsedStory) {\n      throw new Error();\n    }\n\n    return this._parsedStory;\n  }\n\n  private _runtimeStory: Story | null = null;\n  get runtimeStory(): Story {\n    if (!this._runtimeStory) {\n      throw new Error(\"Compilation failed.\");\n    }\n\n    return this._runtimeStory;\n  }\n\n  private _parser: InkParser | null = null;\n  get parser(): InkParser {\n    if (!this._parser) {\n      throw new Error();\n    }\n\n    return this._parser;\n  }\n\n  private _debugSourceRanges: DebugSourceRange[] = [];\n  get debugSourceRanges(): DebugSourceRange[] {\n    return this._debugSourceRanges;\n  }\n\n  constructor(inkSource: string, options: CompilerOptions | null = null) {\n    this._inputString = inkSource;\n    this._options = options || new CompilerOptions();\n  }\n\n  public readonly Compile = (): Story => {\n    this._parser = new InkParser(\n      this.inputString,\n      this.options.sourceFilename || null,\n      this.OnError,\n      null,\n      this.options.fileHandler\n    );\n\n    this._parsedStory = this.parser.ParseStory();\n\n    if (this.errors.length === 0) {\n      this.parsedStory.countAllVisits = this.options.countAllVisits;\n      this._runtimeStory = this.parsedStory.ExportRuntime(this.OnError);\n    } else {\n      this._runtimeStory = null;\n    }\n\n    return this.runtimeStory;\n  };\n\n  public readonly RetrieveDebugSourceForLatestContent = (): void => {\n    for (const outputObj of this.runtimeStory.state.outputStream) {\n      const textContent = asOrNull(outputObj, StringValue);\n      if (textContent !== null) {\n        const range = new DebugSourceRange(\n          textContent.value?.length || 0,\n          textContent.debugMetadata,\n          textContent.value || \"unknown\"\n        );\n\n        this.debugSourceRanges.push(range);\n      }\n    }\n  };\n\n  public readonly DebugMetadataForContentAtOffset = (\n    offset: number\n  ): DebugMetadata | null => {\n    let currOffset = 0;\n\n    let lastValidMetadata: DebugMetadata | null = null;\n    for (const range of this.debugSourceRanges) {\n      if (range.debugMetadata !== null) {\n        lastValidMetadata = range.debugMetadata;\n      }\n\n      if (offset >= currOffset && offset < currOffset + range.length) {\n        return lastValidMetadata;\n      }\n\n      currOffset += range.length;\n    }\n\n    return null;\n  };\n\n  public readonly OnError = (message: string, errorType: ErrorType) => {\n    switch (errorType) {\n      case ErrorType.Author:\n        this._authorMessages.push(message);\n        break;\n\n      case ErrorType.Warning:\n        this._warnings.push(message);\n        break;\n\n      case ErrorType.Error:\n        this._errors.push(message);\n        break;\n    }\n\n    if (this.options.errorHandler !== null) {\n      this.options.errorHandler(message, errorType);\n    }\n  };\n}\n","import { IFileHandler } from \"../IFileHandler\";\n\nexport class JsonFileHandler implements IFileHandler {\n  constructor(public readonly fileHierarchy: Record<string, string>) {}\n\n  readonly ResolveInkFilename = (filename: string): string => {\n    if (Object.keys(this.fileHierarchy).includes(filename)) return filename;\n    throw new Error(\n      `Cannot locate ${filename}. Are you trying a relative import ? This is not yet implemented.`\n    );\n  };\n\n  readonly LoadInkFileContents = (filename: string): string => {\n    if (Object.keys(this.fileHierarchy).includes(filename)) {\n      return this.fileHierarchy[filename];\n    } else {\n      throw new Error(`Cannot open ${filename}.`);\n    }\n  };\n}\n"],"names":["CompilerOptions","constructor","sourceFilename","pluginNames","countAllVisits","errorHandler","fileHandler","this","DebugSourceRange","length","debugMetadata","text","ErrorType","Debug","ValueType","PushPopType","SymbolType","Argument","identifier","isByReference","isDivertTarget","typeName","asOrNull","obj","type","unsafeTypeAssertion","asOrThrows","Error","asINamedContentOrNull","hasValidName","name","nullIfUndefined","isEquatable","Equals","filterUndef","element","undefined","ParsedObject","_alreadyHadError","_alreadyHadWarning","_debugMetadata","_runtimeObject","content","parent","GetType","AddContent","subContent","sub","Array","isArray","ss","hasOwnProperty","push","InsertContent","index","splice","Find","queryFunc","tObj","nestedResult","FindAll","foundSoFar","found","Warning","message","source","value","hasOwnDebugMetadata","Boolean","story","ancestor","runtimeObject","GenerateRuntimeObject","runtimePath","path","containerForCounting","ancestry","result","reverse","ResolveReferences","context","isWarning","AuthorWarning","warningMessage","super","Path","_components","_componentsString","_isRelative","arguments","componentsString","Component","head","tail","concat","relative","isRelative","componentCount","tailComps","slice","self","lastComponent","lastComponentIdx","containsNamedComponent","i","l","isIndex","GetComponent","PathByAppendingPath","pathToAppend","p","upwardMoves","isParent","join","substring","componentStrings","split","str","test","parseInt","toString","otherPath","PathByAppendingComponent","c","parentId","indexOrName","static","otherComp","Assert","condition","console","warn","trace","AssertType","variable","NullException","throwNullException","InkObject","_path","ownDebugMetadata","DebugLineNumberOfPath","root","rootContentContainer","targetContent","ContentAtPath","dm","startLineNumber","comps","child","container","Container","namedChild","unshift","indexOf","ResolvePath","nearestContainer","contentContainer","ConvertPathToRelative","globalPath","ownPath","minPathLength","Math","min","lastSharedPathCompIndex","ownComp","numUpwardsMoves","newPathComps","up","ToParent","down","CompactPathString","globalPathStr","relativePathStr","Copy","SetChild","prop","StringBuilder","string","Length","Append","AppendLine","AppendFormat","format","args","replace","match","num","Clear","InkListItem","originName","itemName","nameParts","Null","isNull","fullName","otherItem","copy","serialized","JSON","stringify","key","parse","isLikeInkListItem","inkListItem","item","InkList","Map","origins","_originNames","otherList","otherOriginNames","originNames","singleOriginListName","originStory","SetInitialOriginName","listDefinitions","def","TryListGetDefinition","exists","singleElement","Add","Key","Value","myListItem","listValue","_a","FindSingleItemListWithName","AddItem","itemOrItemName","origin","intVal","TryGetValueForItem","foundListDef","ContainsItemWithName","itemVal","ValueForItem","ContainsItemNamed","fromSerializedKey","ContainsKey","has","serializedKey","set","Remove","delete","Count","size","originOfMaxItem","maxOriginName","maxItem","every","initialOriginName","SetInitialOriginNames","initialOriginNames","max","minItem","inverse","list","items","all","Union","union","Intersect","intersection","HasIntersection","Without","listToRemove","Contains","what","GreaterThan","GreaterThanOrEquals","LessThan","LessThanOrEquals","MaxAsList","MinAsList","ListWithSubRange","minBound","maxBound","ordered","orderedItems","minValue","maxValue","Number","MAX_SAFE_INTEGER","isInteger","subList","otherInkList","sort","x","y","localeCompare","sb","valueOf","NaN","StoryException","useEndLineNumber","tryGetValueFromMap","map","val","get","AbstractValue","preferredNumberType","Int","IntValue","Float","isNaN","FloatValue","BoolValue","StringValue","String","DivertTargetValue","ListValue","Create","valueObject","BadCastException","targetType","valueType","isTruthy","Bool","Cast","newType","_isNewline","_isInlineWhitespace","isNewline","isInlineWhitespace","isNonWhitespace","parsedInt","defaultValue","tryParseInt","parsedFloat","parseFloat","tryParseFloat","targetPath","DivertTarget","VariablePointerValue","variableName","contextIndex","_contextIndex","VariablePointer","List","listOrSingleItem","singleValue","oldValue","newValue","oldList","newList","SearchResult","approximate","correctObj","searchResult","_content","namedContent","visitsShouldBeCounted","turnIndexShouldBeCounted","countingAtStartOnly","_pathToFirstLeafContent","namedOnlyContent","namedOnlyContentDict","inkObject","named","existingNamedOnly","AddToNamedContentOnly","countFlags","flags","CountFlags","Visits","Turns","CountStartOnly","flag","pathToFirstLeafContent","internalPathToFirstLeafContent","components","contentObjOrList","contentList","contentObj","TryAddNamedContent","namedContentObj","partialPathStart","partialPathLength","currentContainer","currentObj","comp","foundObj","ContentWithPathComponent","AddContentsOfContainer","otherContainer","component","foundContent","BuildStringOfHierarchy","indentation","pointedObj","appendIndentation","onlyNamed","ControlCommand","commandType","_commandType","CommandType","NotSet","EvalStart","EvalOutput","EvalEnd","Duplicate","PopEvaluatedValue","PopFunction","PopTunnel","BeginString","EndString","NoOp","ChoiceCount","TurnsSince","ReadCount","Random","SeedRandom","VisitIndex","SequenceShuffleIndex","StartThread","Done","End","ListFromInt","ListRange","ListRandom","BeginTag","EndTag","Expression","_prototypeRuntimeConstantExpression","outputWhenComplete","RuntimeContainer","RuntimeControlCommand","GenerateIntoContainer","GenerateConstantIntoContainer","runtimeObj","Void","NativeFunctionCall","functionName","GenerateNativeFunctionsIfNecessary","_nativeFunctions","_name","_isPrototype","_prototype","numberOfParameters","_numberOfParameters","Call","parameters","hasList","CallBinaryListOperation","coercedParams","CoerceValuesToSingleType","coercedType","CallType","parametersOfSingleType","param1","valType","val1","paramCount","_operationFuncs","opForTypeObj","val2","opForType","resultVal","CallListIncrementOperation","v1","v2","op","asBooleanOrThrows","listIntParams","listVal","resultInkList","listItemKey","listItemValue","listItem","intOp","targetInt","itemOrigin","incrementedItem","TryGetItemWithValue","parametersIn","specialCaseList","parametersOut","inkObjectVal","castedValue","t","AddIntBinaryOp","Subtract","Multiply","Divide","floor","Mod","AddIntUnaryOp","Negate","Equal","Greater","Less","NotEquals","Not","And","Or","Max","Min","Pow","pow","Floor","Identity","Ceiling","AddFloatBinaryOp","AddFloatUnaryOp","ceil","AddStringBinaryOp","Has","includes","Hasnt","AddListBinaryOp","AddListUnaryOp","Invert","All","ListMin","ListMax","ValueOfList","divertTargetsEqual","d1","d2","divertTargetsNotEqual","AddOpToNativeFunc","AddOpFuncForType","nativeFunc","NumberExpression","subtype","isInt","isFloat","isBool","numberExpression","UnaryExpression","nativeNameForOp","inner","innerExpression","CallWithName","WithInner","innerNumber","BinaryExpression","left","right","opName","leftExpression","rightExpression","NativeNameForOp","leftUnary","CharacterSet","arg","Set","add","AddRange","start","end","charCodeAt","fromCharCode","AddCharacters","chars","FromRange","CharacterRange","_start","_end","excludes","_correspondingCharSet","_excludes","ToCharacterSet","ii","Define","ChoicePoint","onceOnly","_pathOnChoice","hasCondition","hasStartContent","hasChoiceOnlyContent","isInvisibleDefault","pathOnChoice","choiceTargetObj","choiceTarget","pathStringOnChoice","Pointer","Resolve","Divert","_targetPath","targetObj","targetPointer","_targetPointer","StartOf","targetPathString","hasVariableTarget","variableDivertName","stackPushType","pushesToStack","isExternal","externalArgs","isConditional","otherDivert","targetStr","Function","VariableAssignment","isNewDeclaration","isGlobal","Choice","runtimeChoice","_runtimeChoice","_condition","runtimeContainer","_innerContentContainer","innerContentContainer","startContent","choiceOnlyContent","innerContent","_outerContainer","_returnToR1","_returnToR2","_r1Label","_r2Label","_divertToStartContentOuter","_divertToStartContentInner","_startContentRuntimeContainer","hasWeaveStyleInlineBrackets","varAssign","RuntimeVariableAssignment","RuntimeDivert","varDivert","choiceOnlyRuntimeContent","innerChoiceOnlyContent","indentationDepth","CheckForNamingCollisions","SubFlowAndWeave","StringParserElement","characterIndex","characterInLineIndex","lineIndex","reportedErrorInScope","uniqueId","customFlags","CopyFrom","fromElement","_uniqueIdCounter","SquashFrom","StringParserState","currentElement","_stack","_numElements","errorReportedAlreadyInScope","stackHeight","Push","prevElement","newElement","Pop","expectedRuleId","Peek","PeekPenultimate","Squash","penultimateEl","lastEl","NoteErrorReported","el","ParseSuccess","Symbol","StringParser","ParseRule","hadError","BeginRule","state","FailRule","CancelRule","SucceedRule","stateAtSucceedRule","stateAtBeginRule","RuleDidSucceed","finalResult","Expect","rule","recoveryRule","ParseObject","butSaw","lineRemainder","LineRemainder","ErrorOnLine","ErrorWithParsedObject","lineNumber","errorType","ParseUntilCharactersFromString","SetFlag","trueOrFalse","GetFlag","ruleId","stackHeightBefore","Parse","OneOf","array","OneOrMore","results","Optional","Exclude","OptionalExclude","ParseString","TryAddResultToList","flatten","resultCollection","Interleave","ruleA","ruleB","untilTerminator","firstA","lastMainResult","outerResult","remainingLength","cli","li","success","tempIdx","_chars","ParseSingleCharacter","maxCount","ParseCharactersFromString","ParseUntilCharactersFromCharSet","charSet","ParseCharactersFromCharSet","maxCountOrShouldIncludeStrChars","shouldIncludeChars","startIndex","count","ParseInt","oldIndex","oldCharacterInLineIndex","negative","parsedString","numbersCharacterSet","MIN_SAFE_INTEGER","ParseFloat","leadingInt","afterDecimalPointStr","ParseNewline","strPreProc","PreProcessInputString","inputString","currentCharacter","endOfInput","remainingString","ParseUntil","stopRule","pauseCharacters","endCharacters","pauseAndEnd","values","ruleResultAtPause","partialParsedString","pauseCharacter","CommentEliminator","_commentOrNewlineStartCharacter","_commentBlockEndCharacter","_newlineCharacters","Process","stringList","CommentsAndNewlines","MainInk","newLines","ParseSingleComment","EndOfLineComment","BlockComment","startLineIndex","commentResult","repeat","Conditional","initialCondition","branches","_reJoinTarget","branch","branchContainer","ownExpression","isElse","pathToReJoin","returnDivert","Text","ConstantDeclaration","constantName","constantIdentifier","expression","_expression","assignedExpression","Var","FlowLevel","SequenceType","CustomFlags","StatementLevel","Gather","_b","baseTargetLevel","baseLevelIsAmbiguous","Story","_baseTargetLevel","firstComponent","numberOfComponents","dotSeparatedComponents","_dotSeparatedComponents","filter","argOne","argTwo","WeavePoint","ResolveFromContext","baseTargetObject","ResolveBaseTarget","ResolveTailComponents","originalContext","firstComp","ancestorContext","deepSearch","foundBase","GetChildFromContext","rootTarget","foundComponent","compName","minimumExpectedLevel","foundFlow","FlowBase","flowLevel","childName","minimumLevel","forceDeepSearch","ambiguousChildLevel","weaveContext","Weave","WeavePointNamed","flowContext","shouldDeepSearch","Knot","ContentWithNameAtLevel","Object","ReturnType","returnedExpression","ClosestFlowBase","iamFlowbase","Identifier","hasParameters","subFlowsByName","_subFlowsByName","isFunction","topLevelObjects","isIncludedStory","_rootWeave","_startingSubFlowDivert","_startingSubFlowRuntime","_firstChildFlow","variableDeclarations","SplitWeaveAndSubFlowContent","contentObjs","isRootStory","weaveObjs","subFlowObjs","subFlow","finalContent","ResolveVariableWithName","varName","fromNode","ownerFlow","isArgument","isTemporary","AddNewVariableDeclaration","varDecl","varab","prevDeclError","ResolveWeavePointNaming","foundReturn","CheckForDisallowedFunctionFlowControl","Stitch","GenerateArgumentVariableAssignments","contentIdx","childFlow","childFlowRuntime","existingChild","errorMsg","ValidateTermination","WarningInTermination","paramName","assign","level","weavePointResult","DeepSearchForAnyLevelContent","weaveResultSelf","deepResult","allDiverts","divert","isFunctionCall","allChoices","choice","terminatingObject","terminatingDivert","isTunnel","target","PreProcessTopLevelObjects","_","Arg","jj","symbolType","ContentList","objects","moreObjects","dontFlatten","TrimTrailingWhitespace","RegExp","contentObjRuntime","DontFlattenContainer","VariableReference","containerForCount","pathForCount","pathStringForCount","pathIdentifiers","id","runtimeVarRef","_runtimeVarRef","isConstantReference","isListItemReference","constantValue","constants","RuntimeVariableReference","listItemName","listName","ResolveListItem","parsedPath","targetForCount","targetFlow","FunctionCall","proxyDivert","_proxyDivert","runtimeDivert","isChoiceCount","isTurns","isTurnsSince","isRandom","isSeedRandom","isListRange","isListRandom","isReadCount","_divertTargetToCount","_variableReferenceToCount","shouldPopReturnedValue","foundList","ResolveList","usingProxyDivert","divertTarget","variableDivertTarget","CallExistsWithName","nativeCall","msg","RuntimeInkList","strArgs","attemptingTurnCountOfVariableTarget","targetObject","IsBuiltIn","MultipleConditionExpression","subExpressions","conditionExpressions","isFirst","conditionExpr","_runtimeDivert","runtimeDivertTargetValue","_runtimeDivertTargetValue","otherDivTarget","isDone","isEnd","usageContext","badUsage","foundUsage","usageParent","binaryExprParent","funcCall","ConditionalSingleBranch","parentFunc","isEmpty","isThread","ResolveTargetContent","CheckArgumentValidity","requiresArgCodeGen","targetArguments","argToPass","argExpected","varRef","varPointer","Tunnel","PathAsVariableName","variableTargetName","flowBaseScope","resolveResult","argument","find","a","numArgs","butClause","flowArg","divArgExpr","knotCountPath","CheckExternalArgumentValidity","externalName","external","externals","externalArgCount","argumentNames","ownArgCount","returnString","targetWasFound","isBuiltIn","IsExternal","RuntimePath","GatherPointToResolve","targetRuntimeObj","SequenceDivertToResolve","Sequence","elementContentLists","sequenceType","_sequenceDivertsToResolve","once","Once","cycle","Cycle","stopping","Stopping","shuffle","Shuffle","seqBranchCount","sequenceElements","postShuffleNoOp","lastIdx","skipShuffleDivert","AddDivertToResolve","elementCountToShuffle","postSequenceNoOp","elIndex","sequenceDivert","contentContainerForSequenceBranch","seqBranchCompleteDivert","elementContentList","seqElObject","toResolve","TunnelOnwards","_overrideDivertTarget","_divertAfter","divertAfter","returnRuntimeObj","returnRuntimeContainer","evalStart","evalEnd","cmd","returnDivertObj","ListDefinition","_items","_itemNameToValues","ContainsItem","runtimeListDefinition","allItems","e","itemDefinitions","seriesValue","RuntimeListDefinition","variableAssignment","_elementsByName","ItemNamed","initialValues","itemDef","inInitialList","RuntimeInkListItem","currentValue","explicitValue","variableIdentifier","isNewTemporaryDeclaration","isGlobalDeclaration","listDefinition","isDeclaration","isTemporaryNewDeclaration","listDef","_runtimeAssignment","newDeclScope","Temp","variableReference","resolvedVarAssignment","rootContainer","_rootContainer","namedWeavePoints","_namedWeavePoints","lastParsedSignificantObject","lastObject","lastText","IsGlobalDeclaration","lastWeave","cont","indentIndex","previousWeavePoint","addContentToPreviousWeavePoint","hasSeenChoiceInSection","_unnamedGatherCount","_choiceCount","looseEnds","gatherPointsToResolve","w","weavePoint","existingWeavePoint","existingObj","_c","ConstructWeaveHierarchyFromIndentation","weaveIndentIdx","baseIndentIndex","innerWeaveStartIdx","innerWeaveObj","weaveContentCount","weaveContent","weave","DetermineBaseIndentationFromContent","AddRuntimeForWeavePoint","AddRuntimeForNestedWeave","AddGeneralRuntimeContent","PassLooseEndsToAncestors","AddRuntimeForGather","gather","autoEnter","gatherContainer","looseEndWeavePoint","looseEnd","looseWeavePoint","WeavePointHasLooseEnd","closestInnerWeaveAncestor","closestOuterWeaveAncestor","nested","weaveAncestor","received","ReceiveLooseEnd","receivingWeave","childWeaveLooseEnd","varAss","ContentThatFollowsWeavePoint","returned","parentWeave","laterObj","badTerminationHandler","looseEndFlow","ValidateFlowOfObjectsTerminates","BadNestedTerminationHandler","terminatingObj","conditional","toLowerCase","objFlow","defaultObj","terminated","flowObj","d","innerDivert","CheckForWeavePointNamingCollisions","ancestorFlows","flow","weavePointName","otherContentWithName","isNestedWeave","gatherPoint","_ownExpression","_contentContainer","_conditionalDivert","_innerWeave","isTrueBranch","matchingEquality","isInline","startsWith","duplicatesStackValue","needsEval","GenerateRuntimeForContent","DebugMetadata","endLineNumber","startCharacterNumber","endCharacterNumber","fileName","sourceName","Merge","newDebugMetadata","ExternalDeclaration","AddExternal","FlowDecl","Wrap","_objToWrap","Glue","glue","IncDecExpression","varIdentifier","isIncOrExpression","isInc","varResolveResult","incrementDecrementWord","IncludedFile","includedStory","InfixOperator","precedence","requireWhitespace","parentStory","stitchName","knotWithStitchName","stitch","itemIdentifierList","runtimeRawList","itemIdentifier","ListElementDefinition","parentList","indentifier","ListItem","exports","Tag","tagText","threadAtGeneration","sourcePath","tags","originalThreadIndex","ListDefinitionsOrigin","lists","_lists","_allUnambiguousListValueCache","listOfLists","definition","JsonSerialisation","jArray","skipLast","jTok","JTokenToRuntimeObject","writer","dictionary","WriteObjectStart","WritePropertyStart","WriteRuntimeObject","WritePropertyEnd","WriteObjectEnd","WriteArrayStart","WriteArrayEnd","dict","WriteIntProperty","WriteRuntimeContainer","divTypeKey","WriteProperty","choicePoint","boolVal","WriteBool","WriteInt","floatVal","WriteFloat","strVal","Write","WriteStringStart","WriteStringInner","WriteStringEnd","WriteInkList","divTargetVal","varPtrVal","controlCmd","_controlCommandNames","readCountPath","tag","WriteChoice","jObject","token","firstChar","propValue","varPtr","isDivert","divPushType","readCountVarRef","isVarAss","isGlobalVar","isNewDecl","listContent","rawList","namesAsObjs","nameToVal","JObjectToChoice","JArrayToContainer","toJson","me","removes","space","k","v","some","r","withoutName","hasNameProperty","hasTerminator","namedContainer","WriteNull","JArrayToRuntimeObjList","namedContentItem","namedSubContainer","jObj","WritePropertyNameStart","WritePropertyNameInner","WritePropertyNameEnd","listDefJson","defsObj","allDefs","nameValueKey","nameValue","TOTAL_VALUES","CallStack","elements","callStack","depth","cs","_threads","callstack","currentElementIndex","currentThread","canPop","_threadCounter","_startOfRoot","storyContext","Reset","toCopy","otherThread","Thread","Element","SetJsonToken","jThreads","jThreadTok","jThreadObj","thread","WriteJson","WriteObject","PushThread","newThread","threadIndex","ForkThread","forkedThread","PopThread","canPopThread","elementIsEvaluateFromGame","FunctionEvaluationFromGame","externalEvaluationStackHeight","outputStreamLengthWithPushed","currentPointer","evaluationStackHeightWhenPushed","functionStartInOutputStream","CanPop","pop","GetTemporaryVariableWithName","varValue","temporaryVariables","SetTemporaryVariable","declareNew","contextElement","RetainListOriginsForAssignment","ContextForVariableNamed","ThreadWithIndex","filtered","callStackTrace","isCurrent","pointer","inExpressionEvaluation","previousPointer","jThreadCallstack","jElTok","currentContainerPathStr","jElementObj","pushPopType","currentContainerPathStrToken","threadPointerResult","temps","JObjectToDictionaryRuntimeObjs","clear","prevContentObjPath","prevPath","PointerAtPath","WriteDictionaryRuntimeObjs","resolvedPointer","VariablesState","variableChangedEvent","callback","variableChangedEventCallbacks","batchObservingVariableChanges","_batchObservingVariableChanges","_changedVariablesForBatchObs","_globalVariables","_callStack","$","varContents","patch","TryGetGlobal","_defaultGlobalVariables","SetGlobal","listDefsOrigin","_listDefsOrigin","Proxy","ApplyPatch","namedVarKey","namedVarValue","globals","changedVariables","jToken","varValKey","varValValue","loadedToken","tokenInkObject","keyValKey","keyValValue","dontSaveDefaultValues","defaultVal","RuntimeObjectsEqual","obj1","obj2","GetVariableWithName","GetRawVariableWithName","ValueAtVariablePointer","TryGetDefaultVariableValue","GlobalVariableExistsWithName","variableValue","Assign","setGlobal","ResolveVariablePointer","existingPointer","SnapshotDefaultGlobals","AddChangedVariable","GetContextIndexOfVariableNamed","doubleRedirectionPointer","ObserveVariableChange","PRNG","seed","next","nextFloat","StatePatch","_globals","_changedVariables","visitCounts","_visitCounts","turnIndices","_turnIndices","TryGetVisitCount","SetVisitCount","SetTurnIndex","TryGetTurnIndex","SimpleJson","Reader","ToDictionary","ToArray","_rootObject","Writer","_currentPropertyName","_currentString","_stateStack","_collectionStack","_propertyNameStack","_jsonObject","StartNewObject","newObject","State","Property","currentCollection","currentPropertyName","propertyName","None","StateElement","innerOrContent","WriteFloatProperty","IncrementChildCount","childCount","PropertyName","escape","_addToCurrentObject","error","POSITIVE_INFINITY","NEGATIVE_INFINITY","currEl","Flow","outputStream","currentChoices","jChoiceThreadsObj","LoadFlowChoiceThreads","WriteListRuntimeObjs","hasChoiceThreads","jChoiceThreads","foundActiveThread","jSavedChoiceThread","StoryState","ToJson","indented","LoadJson","json","TextToDictionary","LoadJsonObj","onDidLoadState","VisitCountAtPathString","pathString","visitCountOut","_patch","VisitCountForContainer","containerPathStr","count2","IncrementVisitCountForContainer","currCount","RecordTurnIndexVisitToContainer","currentTurnIndex","TurnsSinceForContainer","index2","callstackDepth","_currentFlow","canContinue","generatedChoices","currentErrors","_currentErrors","currentWarnings","_currentWarnings","variablesState","_variablesState","evaluationStack","_evaluationStack","_currentTurnIndex","currentPathString","hasError","hasWarning","currentText","_outputStreamTextDirty","inTag","outputObj","textContent","controlCommand","_currentText","CleanOutputWhitespace","currentWhitespaceStart","startOfLine","charAt","currentTags","_outputStreamTagsDirty","_currentTags","txt","currentFlowName","currentFlowIsDefaultFlow","kDefaultFlowName","aliveFlowNames","_aliveFlowNamesDirty","_aliveFlowNames","_namedFlows","flowName","keys","kInkSaveStateVersion","kMinCompatibleLoadVersion","divertedPointer","storySeed","previousRandom","didSafeExit","OutputStreamDirty","timeSeed","Date","getTime","GoToStart","mainContentContainer","SwitchFlow_Internal","SwitchToDefaultFlow_Internal","RemoveFlow_Internal","CopyAndStartPatching","namedFlowKey","namedFlowValue","RestoreAfterPatch","ApplyAnyPatch","ApplyCountChanges","newCount","isVisit","WriteIntDictionary","inkVersionCurrent","jSaveVersion","flowsObj","flowsObjDict","flowsObjDictEntries","entries","namedFlowObjKey","namedFlowObjValue","currFlowName","currentDivertTargetPath","divertPath","JObjectToIntDictionary","ResetErrors","ResetOutput","objs","PushToOutputStream","listText","TrySplittingHeadTailWhitespace","textObj","PushToOutputStreamIndividual","PopFromOutputStream","single","headFirstNewlineIdx","headLastNewlineIdx","tailLastNewlineIdx","tailFirstNewlineIdx","listTexts","innerStrStart","innerStrEnd","leadingSpaces","innerStrText","numSpaces","trailingSpaces","includeInOutput","TrimNewlinesFromOutputStream","functionTrimIndex","glueTrimIndex","o","trimIndex","RemoveExistingGlue","callStackElements","outputStreamEndsInNewline","outputStreamContainsContent","removeWhitespaceFrom","inStringEvaluation","PushEvaluationStack","n","PopEvaluationStack","numberOfObjects","PeekEvaluationStack","ForceEnd","TrimWhitespaceFromFunctionEnd","functionStartPoint","PopCallStack","popType","SetChosenPath","incrementingTurnIndex","newPointer","StartFunctionEvaluationFromGame","funcContainer","PassArgumentsToEvaluationStack","TryExitFunctionEvaluationFromGame","CompleteFunctionEvaluationFromGame","originalEvaluationStackHeight","returnedObj","poppedObj","returnVal","AddError","Stopwatch","startTime","ElapsedMilliseconds","Start","Stop","nVal","isFinite","choices","_state","IfAsyncWeCant","_listDefinitions","StartProfiling","EndProfiling","inkVersionMinimumCompatible","onError","onDidContinue","onMakeChoice","onEvaluateFunction","onCompleteEvaluateFunction","onChoosePathString","_prevContainers","allowExternalFunctionFallbacks","_variableObservers","_hasValidatedExternals","_temporaryEvaluationContainer","_asyncContinueActive","_stateSnapshotAtLastNewline","_sawLookaheadUnsafeFunctionAfterNewline","_recursiveContinueCount","_asyncSaving","_profiler","_mainContentContainer","jsonString","_externals","rootObject","versionObj","formatFromFile","listDefsObj","rootToken","JTokenToListDefinitions","ResetState","shouldReturn","VariableStateDidChangeEvent","bind","ResetGlobals","ResetCallstack","originalPointer","ChoosePath","ContinueInternal","SwitchFlow","RemoveFlow","SwitchToDefaultFlow","Continue","ContinueAsync","asyncContinueComplete","millisecsLimitAsync","ValidateExternalBindings","PreContinue","isAsyncTimeLimited","durationStopwatch","ContinueSingleStep","RestoreStateSnapshot","PostContinue","err","PreStep","Step","PostStep","TryFollowDefaultInvisibleChoice","PreSnapshot","change","CalculateNewlineOutputStateChange","OutputStateChange","ExtendedBeyondNewline","NewlineRemoved","DiscardSnapshot","StateSnapshot","PostSnapshot","prevText","currText","prevTagCount","currTagCount","newlineStillExists","NoChange","ContinueMaximally","KnotContainerWithName","pathLengthToUse","CopyStateForBackgroundThreadSave","stateToSave","BackgroundSaveComplete","shouldAddToStream","containerToEnter","VisitContainer","currentContentObj","isLogicOrFlowControl","PerformLogicAndFlowControl","ProcessChoice","contextIdx","NextContent","atStart","VisitChangedContainersDueToDivert","prevAncestor","currentChildOfContainer","currentContainerAncestor","allChildrenEnteredAtStart","enteringAtStart","PopChoiceStringAndTags","choiceOnlyStrVal","showChoice","conditionValue","IsTruthy","startText","choiceOnlyText","divTarget","currentDivert","intContent","errorMessage","CallExternalFunction","evalCommand","output","overrideTunnelReturnTarget","popped","names","expected","contentStackForTag","outputCountConsumed","command","choiceTag","contentStackForString","contentToRetain","rescuedTag","choiceCount","extraNote","eitherCount","maxInt","minInt","randomRange","resultSeed","nextRandom","chosenValue","shuffleIndex","NextSequenceShuffleIndex","listNameVal","generatedListValue","foundItem","targetList","listItemIndex","listEnumerator","randomItem","assignedVal","foundValue","func","funcParams","ChoosePathString","resetCallstack","funcDetail","activityStr","ChooseChoiceIndex","choiceIdx","choiceToChoose","HasFunction","EvaluateFunction","returnTextOutput","trim","outputStreamBefore","stringOutput","textOutput","EvaluateExpression","exprContainer","startCallStackHeight","evalStackHeight","funcName","numberOfArguments","funcDef","fallbackFunctionContainer","foundExternal","lookAheadSafe","valueObj","funcResult","function","returnObj","BindExternalFunctionGeneral","lookaheadSafe","TryCoerce","BindExternalFunction","coercedArgs","apply","UnbindExternalFunction","missingExternals","from","ObserveVariable","observer","ObserveVariables","variableNames","observers","RemoveVariableObserver","specificVariableName","variableObservers","newValueObj","globalTags","TagsAtStartOfFlowContainerWithPathString","TagsForContentAtPath","flowContainer","firstContent","BuildStringOfContainer","IncrementContentPointer","didPop","successfulIncrement","nextAncestor","indexInAncestor","invisibleChoices","numElementsIntVal","seqContainer","numElements","seqCount","loopIndex","iterationIndex","seqPathStr","sequenceHash","randomSeed","random","unpickedIndices","chosen","chosenIndex","currentDebugMetadata","errorTypeStr","lineNum","_hadError","hadWarning","_hadWarning","toplevelObjects","isInclude","_errorHandler","_dontFlattenContainers","_listDefs","ExportRuntime","constDecl","existingDefinition","variableInitialisation","runtimeLists","runtimeVarAss","runtimeStory","RuntimeStory","FlattenContainersIn","originalFoundList","itemInThisList","innerContainers","innerContainer","namedInnerContainer","TryFlattenContainer","parentContainer","Author","ResetError","namedFuncTarget","decl","NameConflictError","typeNameToPrint","typeNameOverride","IsReservedKeyword","knotOrFunction","topLevelContent","flowsFromOtherFiles","file","posOfObj","nonFlowContent","subStory","subStoryObj","StringExpression","isSingleString","otherStr","isStart","inChoice","DefaultFileHandler","rootPath","ResolveInkFilename","LoadInkFileContents","InkParser","_fileHandler","filename","externalErrorHandler","rootParser","ParseStory","StatementsAtLevel","Top","_rootParser","SeparatedList","mainRule","separatorRule","firstElement","allElements","nextElementRuleId","nextElement","CreateDebugMetadata","stateAtStart","stateAtEnd","md","_filename","parsedObj","parsedListObjs","parsedListObj","OnStringParserError","fullMessage","_externalErrorHandler","Whitespace","IdentifierWithMetadata","ExtendIdentifierCharacterRanges","identifierCharSet","characterRanges","ListAllCharacterRanges","charRange","_parsingChoice","onceOnlyChoice","bullets","optionalName","BracketedName","ChoiceCondition","startTextAndLogic","MixedTextAndLogic","optionOnlyContent","EndTagIfNecessary","optionOnlyTextAndLogic","innerTextAndLogic","diverts","MultiDivert","emptyContent","divObj","div","conditions","ChoiceSingleCondition","ChoiceConditionsSpace","Newline","condExpr","DisallowIncrement","gatherDashCountObj","GatherDashes","gatherDashCount","ParseDashNotArrow","InnerConditionalContent","initialQueryExpression","ConditionExpression","alternatives","canBeInline","InlineConditionalBranches","MultilineConditionalBranches","soleContent","InnerBlock","elseBranch","SingleMultilineCondition","emptyTrueBranch","earlierBranchesHaveOwnExpression","isLast","alt","finalClause","trueBranch","MultilineWhitespace","multipleConditions","expr","ElseExpression","_nonTextPauseCharacters","_nonTextEndCharacters","_notTextEndCharactersChoice","_notTextEndCharactersString","TrimEndWhitespace","mixedTextAndLogicResults","terminateWithSpace","lastObjIdx","lastObj","LineOfMixedTextAndLogic","firstText","EndOfLine","SkipToNextLine","Spaced","ContentText","InlineLogicOrGlueOrStartTag","ContentTextAllowingEscapeChar","ContentTextNoEscape","gotEscapeChar","endChars","parsingStringExpression","pureTextContent","ParseDivertArrow","ParseThreadArrow","threadDivert","arrowsAndDiverts","ParseDivertArrowOrTunnelOnwards","DivertIdentifierWithArguments","tunnelOnwards","tunnelOnwardDivert","gatherDivert","targetComponents","DotSeparatedDivertPathComponents","optionalArguments","ExpressionFunctionCallArguments","SingleDivert","numArrows","_binaryOperators","_maxBinaryOpLength","TempDeclarationOrAssignment","ParseTempKeyword","isIncrement","isDecrement","ReturnStatement","minimumPrecedence","ExpressionUnary","infixOp","ParseInfixOperator","expectationMessage","multiaryExpr","ExpressionInfixRight","ExpressionDivertTarget","prefixOp","ExpressionNot","ExpressionList","ExpressionParen","ExpressionFunctionCall","ExpressionVariableName","ExpressionLiteral","postfixOp","ExpressionFloat","ExpressionInt","ExpressionBool","ExpressionString","intOrNull","floatOrNull","textAndLogic","iden","commas","innerExpr","memberNames","ListMember","identifier2","RegisterExpressionOperators","RegisterBinaryOperator","infix","_openFilenames","IncludeStatement","fullFilename","FilenameIsAlreadyOpen","AddOpenFilename","includedString","RemoveOpenFilename","KnotDefinition","knotDecl","KnotDeclaration","KnotStitchNoContentRecoveryRule","KnotTitleEquals","knotName","isFunc","parameterNames","BracketedKnotDeclArguments","multiEquals","StitchDefinition","StitchDeclaration","flowArgs","flowArguments","FlowDeclArgument","firstIden","divertArrow","secondIden","funcIdentifier","argNames","_identifierCharSet","LogicLine","funCall","VariableDeclaration","ListElementDefinitionSeparator","ListDeclaration","AnyWhitespace","needsToCloseParen","elementValue","elementValueNum","ConstDeclaration","InlineLogic","StartTag","RuntimeGlue","wasParsingString","wasTagActive","tagActive","logic","InnerLogic","explicitSeqType","SequenceTypeAnnotation","contentLists","InnerSequenceObjects","rules","InnerSequence","InnerExpression","isNumberCharsOnly","_sequenceTypeSymbols","seqType","parsedSeqType","annotation","SequenceTypeSymbolAnnotation","SequenceTypeWordAnnotation","sequenceAnnotations","symbolChar","sequenceTypes","SequenceTypeSingleWord","combinedSequenceType","word","InnerMultilineSequenceObjects","InnerInlineSequenceObjects","interleavedContentAndPipes","justHadContent","contentOrPipe","SingleMultilineSequenceElement","_statementRulesAtLevel","_statementBreakRulesAtLevel","StatementAtLevel","StatementsBreakForLevel","rulesAtLevel","statement","breakRules","breakRuleResult","GenerateStatementLevelRules","levels","breakingRules","Line","inlineRule","_inlineWhitespaceChars","EndOfFile","newlines","anyWhitespace","MultiSpaced","fullRootInkPath","ParsingString","TagActive","outputContentList","LatinBasic","LatinExtendedA","LatinExtendedB","Greek","Cyrillic","Armenian","Hebrew","Arabic","Korean","errors","_errors","warnings","_warnings","authorMessages","_authorMessages","_inputString","options","_options","parsedStory","_parsedStory","_runtimeStory","parser","_parser","debugSourceRanges","_debugSourceRanges","inkSource","Compile","OnError","RetrieveDebugSourceForLatestContent","range","DebugMetadataForContentAtOffset","offset","currOffset","lastValidMetadata","fileHierarchy"],"mappings":"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"}